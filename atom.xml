<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lennybai&#39; Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lennybai.cn/"/>
  <updated>2016-12-12T07:32:19.652Z</updated>
  <id>http://lennybai.cn/</id>
  
  <author>
    <name>Lenny Bai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法导论--分治策略</title>
    <link href="http://lennybai.cn/2016/12/12/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"/>
    <id>http://lennybai.cn/2016/12/12/算法导论-分治策略/</id>
    <published>2016-12-12T02:09:14.000Z</published>
    <updated>2016-12-12T07:32:19.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>　　算法中有两个非常重要的思想分别是：分治策略和动态规划。它们通常可以将处理复杂的问题，转化为处理Ｎ个相关的子问题。通过这种方式，给予人们清晰的思路的同时，降低处理问题的难度。这一篇文章我们来介绍分治策略，并给出几个经典的算法来进行展示。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　分治策略中，往往是通过递归去求解问题，并在每层递归中应用如下三个步骤:</p>
<ol>
<li>分解:将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>
<li>解决:递归的求解子问题，如果子问题的规模足够小，则停止递归，直接求解。</li>
<li>合并:讲子问题的解组合成原问题的解。</li>
</ol>
<a id="more"></a>
<h1 id="算法举例"><a href="#算法举例" class="headerlink" title="算法举例"></a>算法举例</h1><p>　　在上一篇文章里，我们看到的归并排序其实使用的就是分治思想。这里我们再列举两个常用的，并且使用分治思想的算法:堆排序和快速排序。</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>　　堆排序的时间复杂度为O(nlogn)，并且所需的额外存储数量固定。堆通常使用数组进行存储，它可以被看成一个近似的完全二叉树，它的每一个节点对应着数组中的一个元素。接下来我们试着去实现堆排序。<br>　　首先我们来理解一下最大堆。如果按照刚才我们所提到的，将堆看做成二叉树。那么如果是最大堆，其特点是A[PARENT(i)]&gt;=A[i]。这个公示代表着，任何一个节点不大于其父节点。这里我们用伪代码表示一下父节点和左右子节点的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">PARENT(i)</div><div class="line">        return [i/2]</div><div class="line">LEFT(i)</div><div class="line">        return 2i</div><div class="line">RIGHT(i)</div><div class="line">        return 2i+1</div></pre></td></tr></table></figure></p>
<p>　　接下来我们讨论一下堆排序算法。堆排序的一个重要环节是调节堆。详细的说，比如我们目标是构建最大堆，在Ｎ个节点的树中总会有不满足最大堆要求的父子节点关系，那么我们就要进行调整。<br>　　堆排序的第一个环节就是构建最大堆。这里我们假设某个节点的两个子节点都已经是最大树的根节点，在这种情况下，再对该节点进行调整是最容易的。所以我们构建最大堆的思路是先讲子树构建成最大堆，然后开始父节点构建。这样我们将会完成最大堆的构造。然而，这里大家一定要注意，最大堆构建完成并不代表着数组已经排序完成。比如(16,14,10,8,7,9,3)就是最大堆，但是并不是有序的。它只保证了其父节点不小于该节点。<br>　　最后我们来完成排序工作。具体的步骤就是，讲根节点与最后一个节点交换，并从树种去除，然后对树进行调整。不断的迭代这个过程，完成最终的排序工作。<br>　　这里开始为自己的表达能力感到捉急。我们还是来看伪代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//第一步，调整堆</div><div class="line">MAX-HEAPIFY(A,i)</div><div class="line">        l = LEFT(i)</div><div class="line">        r = RIGHT(i)</div><div class="line">        largest = i</div><div class="line">        if l &lt;= heapsize and A[l] &gt; A[i]</div><div class="line">                large = l</div><div class="line">        if r &lt;= heapsize and A[r] &gt; A[i]</div><div class="line">                largest = r</div><div class="line">        if largest != i</div><div class="line">                exchange(A[i],a[largest])</div><div class="line">                MAX-HEAPIFY(A,largest)</div></pre></td></tr></table></figure></p>
<p>　　第一步，通过递归来调整以i为根节点的子树为最大堆。以此为基础，我们讲堆从子节点向上遍历，不断地调整子树为最大树来完成最大堆的构建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//第二步，构建最大堆</div><div class="line">BUILD-MAX-HEAP(A)</div><div class="line">        A.heapsize = A.length</div><div class="line">        for i = [A.length/2] downto 1</div><div class="line">                MAX-HEAPIFY(A,i)</div></pre></td></tr></table></figure></p>
<p>　　在完成最大堆的构建之后，我们已经完成了堆排序最核心的两个步骤，那么我们现在完成堆排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//堆排序</div><div class="line">HEAP-SORT(A)</div><div class="line">        BUILD-MAX-HEAP(A)</div><div class="line">        for i = A.length downto 2</div><div class="line">                exchange A[i] with a[i]</div><div class="line">                A.heapsize = A.heapsize-1</div><div class="line">                MAX-HEAPIFY(A,1)</div></pre></td></tr></table></figure></p>
<p>  　锵锵锵锵，堆排序完成。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>　　另一个使用分治思想的常用算法就是快速排序。快速排序的期望时间复杂度是O(nlogn)。但是最坏情况的时间复杂度又O(n*n)。虽然看起来最坏情况的时间复杂度很差，但是实际排序应用中它往往是最好的选择，因为它的平均性很好，而且O(nlogn)的常数因子非常小。<br>　　快速排序的三步分治过程:</p>
<ol>
<li>分解:　将数组A[p..r]，以A[q]为界换分为两个子数组，子数组可以为空,q可以自由选择。使得A[p..q-1]中的元素都小于A[q],A[q+1..r]中的元素都大于A[q]。</li>
<li>解决:　通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序</li>
<li>合并: 因为子数组都是原址排序，所以不需要合并操作:数组A[p..r]已经有序</li>
</ol>
<p>　　来看具体的伪代码实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PARTITION(A,p,r)</div><div class="line">        x = A[r]</div><div class="line">        i = p - 1</div><div class="line">        for j = p to r - 1</div><div class="line">                if A[j] &lt;= x</div><div class="line">                        i = i + 1</div><div class="line">                        exchange A[i] with A[j]</div><div class="line">        exchage A[i+1] with A[r]</div><div class="line">        return i + 1</div></pre></td></tr></table></figure></p>
<p>　　在快速排序中，PARTITION是非常关键的部分，它的作用有两个，第一个是选定界限值q，第二个就是对输入数组进行原址重排。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">QUICKSORT(A,p,r)</div><div class="line">        if p &lt; r</div><div class="line">                q = PARTITION(A,p,r)</div><div class="line">                QUICKSORT(A,p,q-1)</div><div class="line">                QUICKSORT(A,q+1,r)</div></pre></td></tr></table></figure></p>
<p>　　快速排序完成</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;　　算法中有两个非常重要的思想分别是：分治策略和动态规划。它们通常可以将处理复杂的问题，转化为处理Ｎ个相关的子问题。通过这种方式，给予人们清晰的思路的同时，降低处理问题的难度。这一篇文章我们来介绍分治策略，并给出几个经典的算法来进行展示。&lt;/p&gt;
&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;　　分治策略中，往往是通过递归去求解问题，并在每层递归中应用如下三个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分解:将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。&lt;/li&gt;
&lt;li&gt;解决:递归的求解子问题，如果子问题的规模足够小，则停止递归，直接求解。&lt;/li&gt;
&lt;li&gt;合并:讲子问题的解组合成原问题的解。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="读书笔记" scheme="http://lennybai.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://lennybai.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
      <category term="分之策略" scheme="http://lennybai.cn/tags/%E5%88%86%E4%B9%8B%E7%AD%96%E7%95%A5/"/>
    
      <category term="快速排序" scheme="http://lennybai.cn/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="http://lennybai.cn/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-two sum</title>
    <link href="http://lennybai.cn/2016/12/09/leetcode-twosum/"/>
    <id>http://lennybai.cn/2016/12/09/leetcode-twosum/</id>
    <published>2016-12-09T07:56:03.000Z</published>
    <updated>2016-12-09T08:43:56.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="twoSum"><a href="#twoSum" class="headerlink" title="twoSum"></a><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="external">twoSum</a></h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution.</p>
<a id="more"></a>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><blockquote>
<p>Given nums = [2, 7, 11, 15], target = 9,</p>
<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>　　本题思路并不难。可以从第一个数开始遍历，与后面的所有剩余的数字进行加法运算，如果符合预期则返回。否则继续遍历。这里有一个很明显的问题就是增加了很多不必要的运算。算法时间复杂度较高。<br>　　一个很巧妙的算法是通过map存储已经遍历过的数字。key存储其值，value存储其索引。通过对数字从头到尾遍历。计算目标值(target-当前值)，并到map中查找，如果存在则返回，若不存在，将当前值存储到map中继续遍历。这样只需遍历一边数组就可完成整个算法。</p>
<h3 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; record;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> numberToFind = target - nums[i];</div><div class="line">            <span class="keyword">if</span>(record.find(numberToFind) != record.end())</div><div class="line">            &#123;</div><div class="line">                result.push_back(record[numberToFind]);</div><div class="line">                result.push_back(i);</div><div class="line">                <span class="keyword">return</span> result;</div><div class="line">            &#125;</div><div class="line">            record[nums[i]]=i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    Solution s;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>&#125;;</div><div class="line">    <span class="keyword">int</span> target = <span class="number">9</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : s.twoSum(test, target))</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p><a href="https://github.com/geeklenny/leetcode" target="_blank" rel="external">github代码链接</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;twoSum&quot;&gt;&lt;a href=&quot;#twoSum&quot; class=&quot;headerlink&quot; title=&quot;twoSum&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;twoSum&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution.&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="leetcode" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/leetcode/"/>
    
    
      <category term="编程" scheme="http://lennybai.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="leetcode" scheme="http://lennybai.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑</title>
    <link href="http://lennybai.cn/2016/12/06/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    <id>http://lennybai.cn/2016/12/06/编程珠玑/</id>
    <published>2016-12-06T02:27:32.000Z</published>
    <updated>2016-12-08T02:16:13.648Z</updated>
    
    <content type="html"><![CDATA[<p>编程珠玑，悟性太低，择日再来一遍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编程珠玑，悟性太低，择日再来一遍。&lt;/p&gt;

    
    </summary>
    
      <category term="读书笔记" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编程珠玑" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
    
      <category term="读书笔记" scheme="http://lennybai.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="编程珠玑" scheme="http://lennybai.cn/tags/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
  </entry>
  
  <entry>
    <title>网站浏览记录</title>
    <link href="http://lennybai.cn/2016/12/05/%E7%BD%91%E7%AB%99%E6%B5%8F%E8%A7%88%E8%AE%B0%E5%BD%95/"/>
    <id>http://lennybai.cn/2016/12/05/网站浏览记录/</id>
    <published>2016-12-05T07:04:18.000Z</published>
    <updated>2016-12-07T08:40:33.538Z</updated>
    
    <content type="html"><![CDATA[<p>　　我习惯每天花上一些时间，根据今天的疑问去搜索一些博客读一读。经常会看到一些让人为之振奋的讲解，但也因为读的多读的泛，让自己很难记起某些知识点的具体位置。这让自己想再次翻阅的时候很是焦灼。现在想想何不记录一番，方便以后查阅呢？</p>
<a id="more"></a>
<h3 id="大型网站架构"><a href="#大型网站架构" class="headerlink" title="大型网站架构"></a>大型网站架构</h3><ol>
<li><a href="http://www.cnblogs.com/elves/p/4259188.html" target="_blank" rel="external">大型网站改进历程</a></li>
<li><a href="http://www.cnblogs.com/itfly8/p/5006197.html" target="_blank" rel="external">大型网站架构案例</a></li>
</ol>
<h3 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h3><ol>
<li><a href="http://www.360sdn.com/architect/2015/0504/8691.html" target="_blank" rel="external">mysql+memcached</a></li>
<li><a href="http://www.voidcn.com/blog/bantiaomichong/article/p-6158870.html" target="_blank" rel="external">mysql+redis</a></li>
</ol>
<p>###　编程珠玑<br><a href="http://www.hawstein.com/posts/make-thiner-programming-pearls.html" target="_blank" rel="external">把编程珠玑读薄</a><br><a href="http://mingyangshang.github.io/2016/01/01/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/" target="_blank" rel="external">编程珠玑</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　我习惯每天花上一些时间，根据今天的疑问去搜索一些博客读一读。经常会看到一些让人为之振奋的讲解，但也因为读的多读的泛，让自己很难记起某些知识点的具体位置。这让自己想再次翻阅的时候很是焦灼。现在想想何不记录一番，方便以后查阅呢？&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="网站地址" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BD%91%E7%AB%99%E5%9C%B0%E5%9D%80/"/>
    
    
      <category term="网址推荐" scheme="http://lennybai.cn/tags/%E7%BD%91%E5%9D%80%E6%8E%A8%E8%8D%90/"/>
    
      <category term="学习笔记" scheme="http://lennybai.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>effective c++小记</title>
    <link href="http://lennybai.cn/2016/12/02/effective-c-%E5%B0%8F%E8%AE%B0/"/>
    <id>http://lennybai.cn/2016/12/02/effective-c-小记/</id>
    <published>2016-12-02T08:51:35.000Z</published>
    <updated>2016-12-06T02:30:28.958Z</updated>
    
    <content type="html"><![CDATA[<p>more effective c++</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;more effective c++&lt;/p&gt;

    
    </summary>
    
      <category term="读书笔记" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="more effective c++" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/more-effective-c/"/>
    
    
      <category term="读书笔记" scheme="http://lennybai.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="more effective c++" scheme="http://lennybai.cn/tags/more-effective-c/"/>
    
  </entry>
  
  <entry>
    <title>算法导论(1)——写好伪代码</title>
    <link href="http://lennybai.cn/2016/12/02/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA1/"/>
    <id>http://lennybai.cn/2016/12/02/算法导论1/</id>
    <published>2016-12-02T08:51:00.000Z</published>
    <updated>2016-12-09T03:11:06.459Z</updated>
    
    <content type="html"><![CDATA[<p>　　在学习各种编程语言的时候，数据结构与算法一般都会作为重点课程来指出。而谈到算法，算法导论一书又常常被大家提起。然而作为一个编程界的老鸟，技术层面的菜鸟，最近才开始啃算法导论，实属令自己汗颜。不过拾起总比放下的要好，所以这里根据自己的理解做一些记录。并在阅读初期就设定了一些目标，包括理解并学习各种常用算法及其设计思路，<strong><em>学习并写好伪代码</em></strong>等。</p>
<a id="more"></a>
<h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p>　　书中讲到，算法就是任何良定义的计算过程。算法的目的是解决问题。问题陈述说明了期望的输入和输出，而算法则描述一个特定的计算过程来实现输入输出的关系。</p>
<h3 id="算法的描述（伪代码）"><a href="#算法的描述（伪代码）" class="headerlink" title="算法的描述（伪代码）"></a>算法的描述（伪代码）</h3><p>　　算法可以使用英语说明，也可以用中文说明，当然也可以说明成计算机程序。它的唯一要求是这个说明必须精确的描述所需要遵循的计算过程。<br>　　我个人更欣赏将算法描述为用一种伪代码书写的程序。它的优势在于，能够使用最清晰最简洁的方法来说明给定的算法。并且根据伪代码可以将算法转化成各种所需的编程语言。</p>
<h3 id="如何写好伪代码"><a href="#如何写好伪代码" class="headerlink" title="如何写好伪代码"></a>如何写好伪代码</h3><p>　　在我们常用的编程语言中，通常按照所需的命名规范和运算逻辑的使用，讲所想的用该语言展示出来。伪代码同样也可以按照相似的方法展示。其实伪代码并没有明确的规范要求，但是在算法导论一书中，他列出了一些所谓的约定。当然，这些约定我们可以不去遵守。但是如果按着约定去书写伪代码的话，会使我们的伪代码变得清晰易懂，何乐不为。</p>
<ul>
<li>缩进表示块结构。参考python的语言结构。　</li>
<li>while,for,if-else等结构具有和c语言等相同的解释。但是方便理解，我们去除额外的细节，表示重点。比如当一个for循环时，当循环上升时使用to，下降时使用downto，步数使用by。</li>
<li>//表示注释</li>
<li>变量直接使用无需声明。一般变量默认为局部变量。</li>
<li>数据访问通过数组名和下标的方式访问。</li>
<li>使用error表示过程中出现错误。</li>
</ul>
<p>　　伪代码的使用方法和约定都比较宽松，目的都是能够写出清晰易懂的伪代码。</p>
<h3 id="伪代码实践"><a href="#伪代码实践" class="headerlink" title="伪代码实践"></a>伪代码实践</h3><p>   这里列举一个插入排序的算法的伪代码实现，大家一起来感受一下气场。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">INSERT-SORT(A)</div><div class="line">    for j=2 to A.length</div><div class="line">        key=A[j]</div><div class="line">        // Insert A[j] into the sorted sequence A[1..j-1].</div><div class="line">        i = j-1;</div><div class="line">      while i&gt;0 and A[i]&gt;key</div><div class="line">          A[i+1]=A[j]</div><div class="line">          i = i-1</div><div class="line">      A[i+1]=key</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在学习各种编程语言的时候，数据结构与算法一般都会作为重点课程来指出。而谈到算法，算法导论一书又常常被大家提起。然而作为一个编程界的老鸟，技术层面的菜鸟，最近才开始啃算法导论，实属令自己汗颜。不过拾起总比放下的要好，所以这里根据自己的理解做一些记录。并在阅读初期就设定了一些目标，包括理解并学习各种常用算法及其设计思路，&lt;strong&gt;&lt;em&gt;学习并写好伪代码&lt;/em&gt;&lt;/strong&gt;等。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
    
      <category term="读书笔记" scheme="http://lennybai.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法导论" scheme="http://lennybai.cn/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>elasticsearch上手练</title>
    <link href="http://lennybai.cn/2016/12/02/elasticsearch%E4%B8%8A%E6%89%8B%E7%BB%83/"/>
    <id>http://lennybai.cn/2016/12/02/elasticsearch上手练/</id>
    <published>2016-12-02T08:50:07.000Z</published>
    <updated>2016-12-06T02:31:47.066Z</updated>
    
    <content type="html"><![CDATA[<p>elasticsearch</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;elasticsearch&lt;/p&gt;

    
    </summary>
    
      <category term="程序设计" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="elasticsearch" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/elasticsearch/"/>
    
    
      <category term="程序设计" scheme="http://lennybai.cn/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="elasticsearch" scheme="http://lennybai.cn/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>c++线程池</title>
    <link href="http://lennybai.cn/2016/12/02/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://lennybai.cn/2016/12/02/c-线程池/</id>
    <published>2016-12-02T08:48:44.000Z</published>
    <updated>2016-12-06T02:32:20.075Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="程序设计" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c++线程池" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="程序设计" scheme="http://lennybai.cn/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c++ 线程池" scheme="http://lennybai.cn/tags/c-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>redis学习之参考文档</title>
    <link href="http://lennybai.cn/2016/12/02/redis%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"/>
    <id>http://lennybai.cn/2016/12/02/redis学习之参考文档/</id>
    <published>2016-12-02T02:21:38.000Z</published>
    <updated>2016-12-02T06:09:24.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-认识redis"><a href="#1-认识redis" class="headerlink" title="1. 认识redis"></a>1. 认识redis</h1><p>　　redis是一个key-value的存储系统。它支持网络、可基于内存亦可持久化的日志型、key-value数据库。value值可支持string,map,list,sets和sorted sets等类型。<br>　　详细的说，redis相对其它key-value缓存产品(如memcached)有三个特点：</p>
<ul>
<li>支持持久化，可将内存中的数据保持到磁盘中，重启时可再次加载进行使用。</li>
<li>不仅仅支持简单的key-value类型的数据，同事还提供list,set,zset,hash等数据结构的存储</li>
<li>支持数据备份,master-slave模式</li>
</ul>
<a id="more"></a>
<p>  除此之外，redis还具备一下特点:</p>
<ul>
<li>极高的性能：　读110000次/s，　写的速度81000次/s</li>
<li>丰富的数据类型</li>
<li>原子性：所有操作都是原子性的。</li>
<li>丰富的特性: 支持通知、key过期，publish/subscribe等</li>
</ul>
<h1 id="2-使用redis"><a href="#2-使用redis" class="headerlink" title="2.使用redis"></a>2.使用redis</h1><p>　　对于一个工具，我们更关心的是如何使用。这里我从官方的文档中摘录出一些我自己比较感性去的部分罗列与此。和大家分享。</p>
<h2 id="2-1-配置Redis"><a href="#2-1-配置Redis" class="headerlink" title="2.1　配置Redis"></a>2.1　配置Redis</h2><p>　　如何正确的使用配置文件，有利于我们更好的使用redis。这里我们认识一下常用命令。我安装了redis-cli，这里直接使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">lennybai@lennybai:~$ redis-cli</div><div class="line">127.0.0.1:6379&gt; CONFIG GET loglevel</div><div class="line">1) <span class="string">"loglevel"</span></div><div class="line">2) <span class="string">"notice"</span></div><div class="line">127.0.0.1:6379&gt; config get *</div><div class="line">  1) <span class="string">"dbfilename"</span></div><div class="line">  2) <span class="string">"dump.rdb"</span></div><div class="line">  3) <span class="string">"requirepass"</span></div><div class="line">  4) <span class="string">""</span></div><div class="line">  5) <span class="string">"masterauth"</span></div><div class="line">  6) <span class="string">""</span></div><div class="line">  7) <span class="string">"unixsocket"</span></div><div class="line">  8) <span class="string">""</span></div><div class="line">  9) <span class="string">"logfile"</span></div><div class="line"> 10) <span class="string">"/var/log/redis/redis-server.log"</span></div><div class="line"> 11) <span class="string">"pidfile"</span></div><div class="line">..........后面省略</div></pre></td></tr></table></figure></p>
<p>　　我们可以通过config　get key获取配置文件中某项配置的值。并可以通过config set config_string_name new_config_value来更新其值。<br>　　下面对一些常用的配置项进行说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>　说明  </th>
</tr>
</thead>
<tbody>
<tr>
<td>daemonize</td>
<td>是否设为守护进程</td>
</tr>
<tr>
<td>pidfile</td>
<td>设置守护进程pid存储文件的位置</td>
</tr>
<tr>
<td>port</td>
<td>指定redis端口(默认6379)</td>
</tr>
<tr>
<td>databases</td>
<td>设置redis内置数据库的数量。通过select切换</td>
</tr>
<tr>
<td>save</td>
<td>指定同步到文件的规则</td>
</tr>
<tr>
<td>maxclient</td>
<td>最大客户连接数，0为不设限制</td>
</tr>
<tr>
<td>maxmemory</td>
<td>最大分配内存</td>
</tr>
</tbody>
</table>
<p>对于命令还有很多，大家可以在需要时自行查看。</p>
<h2 id="2-2-redis数据类型"><a href="#2-2-redis数据类型" class="headerlink" title="2.2　redis数据类型"></a>2.2　redis数据类型</h2><p>　　数据类型对于redis相对其他缓存产品而言，其丰富的数据格式是它的一大特色。这里做一下简单的介绍。</p>
<h3 id="string字符串类型"><a href="#string字符串类型" class="headerlink" title="string字符串类型"></a>string字符串类型</h3><p>　　string类型是最基本的类型，它和memcached一样的类型.一个key对应一个value。redis中，string是二进制安全的，也就是说它可以存储任何数据(如图片或者序列化的对象)。一个键的最大存储为512MB.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; SET name <span class="string">"redis.net.cn"</span></div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; GET name</div><div class="line"><span class="string">"redis.net.cn"</span></div></pre></td></tr></table></figure></p>
<h3 id="hash（哈希"><a href="#hash（哈希" class="headerlink" title="hash（哈希)"></a>hash（哈希)</h3><p>Redis hash是一个键值组合，它是一个string类型的field和value的映射表。特别适合存储对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; HMSET user:1 username redis.net.cn password redis.net.cn points 200</div><div class="line">OK</div><div class="line">redis 127.0.0.1:6379&gt; HGETALL user:1</div><div class="line">1) <span class="string">"username"</span></div><div class="line">2) <span class="string">"redis.net.cn"</span></div><div class="line">3) <span class="string">"password"</span></div><div class="line">4) <span class="string">"redis.net.cn"</span></div><div class="line">5) <span class="string">"points"</span></div><div class="line">6) <span class="string">"200"</span></div></pre></td></tr></table></figure></p>
<p>每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
<h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h3><p>　　redis　list列表是简单的string类型列表。可以添加一个元素在列表的头部或者尾部。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; lpush redis.net.cn redis</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis 127.0.0.1:6379&gt; lpush redis.net.cn mongodb</div><div class="line">(<span class="built_in">integer</span>) 2</div><div class="line">redis 127.0.0.1:6379&gt; lpush redis.net.cn rabitmq</div><div class="line">(<span class="built_in">integer</span>) 3</div><div class="line">redis 127.0.0.1:6379&gt; lrange redis.net.cn 0 10</div><div class="line">1) <span class="string">"rabitmq"</span></div><div class="line">2) <span class="string">"mongodb"</span></div><div class="line">3) <span class="string">"redis"</span></div><div class="line">redis 127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>
<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>
<h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h3><p>　　Redis的set是string类型的无序集合。它是通过hash表实现的。增添和查找的复杂度为O(1).</p>
<blockquote>
<p>sadd key member</p>
</blockquote>
<p>实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; sadd redis.net.cn redis</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis 127.0.0.1:6379&gt; sadd redis.net.cn mongodb</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">redis 127.0.0.1:6379&gt; smembers redis.net.cn</div><div class="line"></div><div class="line">1) <span class="string">"rabitmq"</span></div><div class="line">2) <span class="string">"mongodb"</span></div><div class="line">3) <span class="string">"redis"</span></div></pre></td></tr></table></figure>
<h3 id="zset（有序集合"><a href="#zset（有序集合" class="headerlink" title="zset（有序集合)"></a>zset（有序集合)</h3><p>　　zset是一个有序的string集合，且不允许成员重复。每个成员会关联一个double类型的分数。通过分数进行排序。成员唯一，但是分数可以重复。</p>
<blockquote>
<p>zadd key score member</p>
</blockquote>
<p>实例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 redis</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 mongodb</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</div><div class="line">(<span class="built_in">integer</span>) 0</div><div class="line">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE redis.net.cn 0 1000</div><div class="line"></div><div class="line">1) <span class="string">"redis"</span></div><div class="line">2) <span class="string">"mongodb"</span></div><div class="line">3) <span class="string">"rabitmq"</span></div></pre></td></tr></table></figure>
<h2 id="2-3-Redis命令"><a href="#2-3-Redis命令" class="headerlink" title="2.3 Redis命令"></a>2.3 Redis命令</h2><p>  通过介绍redis的命令，了解redis的使用</p>
<h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>　　redis可以通过ping命令检测redis的运行情况。若正常运行，则返回pung<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; PING</div><div class="line"></div><div class="line">PONG</div></pre></td></tr></table></figure></p>
<h3 id="key相关命令"><a href="#key相关命令" class="headerlink" title="key相关命令"></a>key相关命令</h3><table>
<thead>
<tr>
<th>命令　</th>
<th>　说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set key</td>
<td>插入一个key-value</td>
</tr>
<tr>
<td>del key</td>
<td>删除一个key-value.正确返回１，错误返回０</td>
</tr>
<tr>
<td>dump key</td>
<td>序列化key。正确返回序列化后字符串，错误返回nil</td>
</tr>
</tbody>
</table>
<p>exists key ｜　检测键值是否存在<br>expire key seconds | 设置键值过期时间，时间到了自动删除<br>move key db ｜　将当前数据库的key移动到其他数据库<br>persist key | 移除过期时间，永久保存<br>rename key new key | 重命名key<br>type key | 返回key的类型</p>
<h3 id="publish-subscribe命令"><a href="#publish-subscribe命令" class="headerlink" title="publish\subscribe命令"></a>publish\subscribe命令</h3><p>　　pub\sub是一个消息通信模式。通过subscribe订阅消息，然后通过publish发送消息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#订阅者</span></div><div class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</div><div class="line"></div><div class="line">Reading messages... (press Ctrl-C to quit)</div><div class="line">1) <span class="string">"subscribe"</span></div><div class="line">2) <span class="string">"redisChat"</span></div><div class="line">3) (<span class="built_in">integer</span>) 1</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#发送者</span></div><div class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">"Redis is a great caching technique"</span></div><div class="line"></div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line"></div><div class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class="string">"Learn redis by w3cschool.cc"</span></div><div class="line"></div><div class="line">(<span class="built_in">integer</span>) 1</div><div class="line"></div><div class="line"><span class="comment"># 订阅者的客户端会显示如下消息</span></div><div class="line">1) <span class="string">"message"</span></div><div class="line">2) <span class="string">"redisChat"</span></div><div class="line">3) <span class="string">"Redis is a great caching technique"</span></div><div class="line">1) <span class="string">"message"</span></div><div class="line">2) <span class="string">"redisChat"</span></div><div class="line">3) <span class="string">"Learn redis by w3cschool.cc"</span></div></pre></td></tr></table></figure>
<p>　　通过unsubscribe退订频道。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>　　Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开始事务。</li>
<li>命令入队。</li>
<li>执行事务。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; MULTI</div><div class="line">OK</div><div class="line"></div><div class="line">redis 127.0.0.1:6379&gt; SET book-name <span class="string">"Mastering C++ in 21 days"</span></div><div class="line">QUEUED</div><div class="line"></div><div class="line">redis 127.0.0.1:6379&gt; GET book-name</div><div class="line">QUEUED</div><div class="line"></div><div class="line">redis 127.0.0.1:6379&gt; SADD tag <span class="string">"C++"</span> <span class="string">"Programming"</span> <span class="string">"Mastering Series"</span></div><div class="line">QUEUED</div><div class="line"></div><div class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</div><div class="line">QUEUED</div><div class="line"></div><div class="line">redis 127.0.0.1:6379&gt; EXEC</div><div class="line">1) OK</div><div class="line">2) <span class="string">"Mastering C++ in 21 days"</span></div><div class="line">3) (<span class="built_in">integer</span>) 3</div><div class="line">4) 1) <span class="string">"Mastering Series"</span></div><div class="line">   2) <span class="string">"C++"</span></div><div class="line">   3) <span class="string">"Programming"</span></div></pre></td></tr></table></figure>
<p>  discard取消事务执行。</p>
<h3 id="INFO"><a href="#INFO" class="headerlink" title="INFO　"></a>INFO　</h3><p>查看当前redis所有信息</p>
<h3 id="脚本支持"><a href="#脚本支持" class="headerlink" title="脚本支持"></a>脚本支持</h3><p>　 redis内置lua解析器</p>
<h1 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3 参考文献"></a>3 参考文献</h1><ul>
<li>[1]: <a href="http://www.redis.net.cn/tutorial/3501.html" target="_blank" rel="external">redis官方文档</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-认识redis&quot;&gt;&lt;a href=&quot;#1-认识redis&quot; class=&quot;headerlink&quot; title=&quot;1. 认识redis&quot;&gt;&lt;/a&gt;1. 认识redis&lt;/h1&gt;&lt;p&gt;　　redis是一个key-value的存储系统。它支持网络、可基于内存亦可持久化的日志型、key-value数据库。value值可支持string,map,list,sets和sorted sets等类型。&lt;br&gt;　　详细的说，redis相对其它key-value缓存产品(如memcached)有三个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持持久化，可将内存中的数据保持到磁盘中，重启时可再次加载进行使用。&lt;/li&gt;
&lt;li&gt;不仅仅支持简单的key-value类型的数据，同事还提供list,set,zset,hash等数据结构的存储&lt;/li&gt;
&lt;li&gt;支持数据备份,master-slave模式&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="redis官方文档" scheme="http://lennybai.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/redis%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="redis" scheme="http://lennybai.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>g++ template class</title>
    <link href="http://lennybai.cn/2016/11/25/g-template-class/"/>
    <id>http://lennybai.cn/2016/11/25/g-template-class/</id>
    <published>2016-11-25T05:31:50.000Z</published>
    <updated>2016-11-25T05:33:01.003Z</updated>
    
    <content type="html"><![CDATA[<p>g++模板类，定义不能与声明分离</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;g++模板类，定义不能与声明分离&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux 小技巧</title>
    <link href="http://lennybai.cn/2016/11/22/linux-%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://lennybai.cn/2016/11/22/linux-小技巧/</id>
    <published>2016-11-22T01:27:34.000Z</published>
    <updated>2016-11-22T09:51:22.241Z</updated>
    
    <content type="html"><![CDATA[<p>##　命令行对错误信息的处理<br>　　在使用控制台的时候，往往在得到正确结果的同时，也会跟随者一些并不重要的错误信息，比如:</p>
<p><img src="http://ogelzbmrh.bkt.clouddn.com/findmysql.png" alt="find mysql"></p>
<p>　　我们发现，当我们使用find命令去搜索mysql相关的内容的时候，除了我们想要的路径信息外，还有很多不必要的”permission denied”错误信息。这时候我们就可以通过将错误重定向到/dev/null来解决这个问题:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find / -name mysql 2&gt;/dev/null</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##　命令行对错误信息的处理&lt;br&gt;　　在使用控制台的时候，往往在得到正确结果的同时，也会跟随者一些并不重要的错误信息，比如:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ogelzbmrh.bkt.clouddn.com/findmysql.png&quot; alt=&quot;fin
    
    </summary>
    
      <category term="操作系统" scheme="http://lennybai.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="使用技巧" scheme="http://lennybai.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="linux" scheme="http://lennybai.cn/tags/linux/"/>
    
      <category term="系统相关" scheme="http://lennybai.cn/tags/%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>了解c++11</title>
    <link href="http://lennybai.cn/2016/11/14/%E4%BA%86%E8%A7%A3c-11/"/>
    <id>http://lennybai.cn/2016/11/14/了解c-11/</id>
    <published>2016-11-14T06:48:10.000Z</published>
    <updated>2016-11-23T01:07:19.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>　　起草本文的目的主要有两点：第一点，在c++11学习的过程中做一些摘要总结，尽量取其精华，为自己梳理出来一个比较清晰的记忆脉络；第二点，不得不说的就是随着年纪的增长，记忆力也开始变得并不那么可靠，做些记录，定期回头看看总是好的。<br>　　文章会对c++11（其实是c++1x更准确些）的背景进行简要的概述，并尽量详细且准确的阐述c++11的新的特性。共同学习，不断进步。</p>
<h2 id="1-1-c-11概述"><a href="#1-1-c-11概述" class="headerlink" title="1.1 c++11概述"></a>1.1 c++11概述</h2><p>　　我们生活中常常谈论的c++更多的是指传统c++，又或是可以称为c++98的版本。c++11也并不是什么神秘的新语言，而是基于传统c++发布13年后的第一次重大修订。它主要基于现在软件行业发展的新需求与新诉求进行的一种调整——增加新特性并弃用部分特性。</p>
<a id="more"></a>
<h2 id="1-2-文章小贴士"><a href="#1-2-文章小贴士" class="headerlink" title="1.2 文章小贴士"></a>1.2 文章小贴士</h2><h3 id="1-2-1-笔者开发运行环境"><a href="#1-2-1-笔者开发运行环境" class="headerlink" title="1.2.1 笔者开发运行环境"></a>1.2.1 笔者开发运行环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; lennybai@lennybai~$ lsb_release <span class="_">-a</span></div><div class="line">&gt; No LSB modules are available.</div><div class="line">&gt; Distributor ID:	Ubuntu</div><div class="line">&gt; Description:	Ubuntu 16.04.1 LTS</div><div class="line">&gt; Release:	16.04</div><div class="line">&gt; Codename:	xenial</div><div class="line"></div><div class="line">&gt; lennybai@lennybai:~$ g++ --version</div><div class="line">&gt; g++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609</div><div class="line">&gt; Copyright (C) 2015 Free Software Foundation, Inc.</div><div class="line">&gt; This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions.  There is NO</div><div class="line">warranty; not even <span class="keyword">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</div></pre></td></tr></table></figure>
<h3 id="1-2-2-小贴士"><a href="#1-2-2-小贴士" class="headerlink" title="1.2.2 小贴士"></a>1.2.2 小贴士</h3><blockquote>
<p>g++ main.cpp -std=c++11　　</p>
</blockquote>
<p>若使用c++11，请记得添加编译选项</p>
<h3 id="1-2-3-原创提醒"><a href="#1-2-3-原创提醒" class="headerlink" title="1.2.3 原创提醒"></a>1.2.3 原创提醒</h3><p>　　本文主要目的在于个人学习与记录，如果能够有幸帮助到同样在修行的同僚那自然是件幸事，引用还望注明出处。笔者在写作过程中也会大量的阅读各种文章以增强理解，当然，会尽最大可能去注明文章引用，如果存在问题，希望指正。</p>
<hr>
<h1 id="二、正篇"><a href="#二、正篇" class="headerlink" title="二、正篇"></a>二、正篇</h1><p>　　对于学习新东西，我的习惯一般都是先google或者baidu看大量的博客来给自己洗脑，让自己有一定的知识轮廓。接下来就会开始啃官方文档，或者阅读刚刚浏览过的博客中推荐的各种书籍。当然，如果有个不错的视频教程让自己快进着点一点最好不过了，很多效果一目了然。</p>
<p>　　在stackoverflow上，有人给出了不错的<a href="http://stackoverflow.com/a/388282" target="_blank" rel="external">书籍大纲</a>，这些对于积累知识的初学者更有益。对于那些对于传统c++已经很熟悉，只是希望快速的了解c++11的新特性，并择机使用的选手来说，实验楼的<a href="https://www.shiyanlou.com/courses/605/labs/2022/document" target="_blank" rel="external">《C++ 11/14 高速上手教程》</a>免费在线课程可能会更有帮助。</p>
<p>　　本文主要基于实验楼的课程大纲进行整理，并进行部分知识点的拓展完善。</p>
<h2 id="2-1-弃用-deprecated-特性"><a href="#2-1-弃用-deprecated-特性" class="headerlink" title="2.1 弃用(deprecated)特性"></a>2.1 弃用(deprecated)特性</h2><p>　　c++11提及到部分弃用特性。这里弃用并不等于废除并从标准中移除，而是警醒程序员在使用c++的时候能够意识到某些特性应避免使用。其实可能为了保证兼容性，这些特性可能永远不会被剔除出去（通常情况下是在编译的时，会显示一个弃用的warning），依旧可以被使用。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lennybai@lennybai:~/Desktop/cpp11$ g++ main.cpp -std=c++11</div><div class="line">main.cpp: In <span class="keyword">function</span> ‘int main()’:</div><div class="line">main.cpp:7:15: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</div><div class="line">     char* a = <span class="string">"hello world"</span>;</div></pre></td></tr></table></figure></p>
<p>　　但是我们应该尽量遵循语言的发展与变迁，适当的改变自己对语言的使用方式。一个不恰当的例子，就好比黑白彩电置于当今社会，依然可以被使用，但是有更好的选择时为什么不去尝试呢？</p>
<h3 id="2-1-1-被移除或者弃用的特性"><a href="#2-1-1-被移除或者弃用的特性" class="headerlink" title="2.1.1 被移除或者弃用的特性"></a>2.1.1 被移除或者弃用的特性</h3><blockquote>
<ul>
<li>std::auto_ptr 被 std::unique_ptr 取代。</li>
<li>exception specifications</li>
<li>bool 类型的 ++ 操作被弃用。</li>
<li>export: 用法已被去掉,但关键字还是被保留了,给将来可能的特性使用</li>
<li>函数对象的基类(std::unary_function, std::binary_function)、函数指针适配器、类型成员指针适配器以及绑定器 (binder)。</li>
<li><a href="http://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022330.html" target="_blank" rel="external">顺序点</a> (sequence point): 这个术语正被更为易懂的描述所取代。一个运算可以发生 (is sequenced before) 在另一个运算之前; 又或者两个运算彼此之间没有顺序关系 (are unsequenced)。</li>
</ul>
</blockquote>
<p>　　就像前面提到的，被弃用的特性应该引起一定的重视。这里主要参考维基百科上面提到的内容列出了一些已经被弃用的特性。在以后的学习过程中也会不断完善这一部分。</p>
<h2 id="2-2-新特性"><a href="#2-2-新特性" class="headerlink" title="2.2 新特性"></a>2.2 新特性</h2><p>　　对于c++11的新特性应该是阅读本文的客官们更关心的。c++11新特性包括但不完全是：lambda表达式，类型推断关键字auto、decltype和对模板的大量改进。在这一章节我们进行详细阐述。</p>
<h3 id="2-2-1-自动类型推断（auto-decltype）"><a href="#2-2-1-自动类型推断（auto-decltype）" class="headerlink" title="2.2.1 自动类型推断（auto/decltype）"></a>2.2.1 自动类型推断（auto/decltype）</h3><p>　　对于传统c++而言，变量的类型都必须明确定义。虽然已经习惯传统c++编程的朋友们在声明或者定义基本类型(如int、char等)的变量时，并没有太多不妥的感觉。然而，可能也会在使用复杂模板时，觉得代码有点又丑又长。比如常见的迭代器声明:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( <span class="built_in">map</span> &lt; <span class="keyword">int</span>,UserDefClass&lt;userDefTemptype&gt; &gt;::iterator itr= userMap.begin(); itr !=userMap.end(); ++itr)</div></pre></td></tr></table></figure></p>
<p>　　这里我列出了一个比较夸张的例子，目的是希望指出自动类型推断存在的意义。它其实已经很普遍的存在于现代编程语言之中(如python, javascript等脚本语言)。而在c++11中，通过对传统c++中auto关键字的修改得到自动类型推断的支持。<br>　　auto关键字在传统c++中用来指定存储期，一般用于指明具有自动生命周期的变量。最常见的就是函数内的局部变量。编译器在做编译时，对一般不是static修饰的变量，则默认赋予auto类型，所以auto关键字几乎很少被使用。在传统c++中，auto关键字的使用方法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> <span class="keyword">int</span> a;</div></pre></td></tr></table></figure></p>
<p>　　而在c++11中，auto的功能变为了类型自动推断,编译器会根据初始代码推断所声明变量的真实类型。将类型判断的工作由程序员交给了编译器，这样，在一定程度提高了代码开发的效率。而且，大部分情况下会直观的发现，代码变的更简短(当然int类型还是要比auto少一个字符)。这里是使用auto对上面繁重代码的优化:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> itr= userMap.begin(); itr !=userMap.end(); ++itr)</div></pre></td></tr></table></figure></p>
<p>　　有没有很酷！接下来我们来看一下auto的具体使用，来更详细的了解一下它的功能。同时，也要学习一下它的使用规则。auto在c++11中，最容易理解的使用方式莫过于变量定义时的类型推断:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">auto</span> b = <span class="string">'A'</span>;</div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">c</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a:"</span> &lt;&lt; <span class="keyword">typeid</span>(a).name() &lt;&lt; <span class="built_in">endl</span>;    　<span class="comment">// “a:i”</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b:"</span> &lt;&lt; <span class="keyword">typeid</span>(b).name() &lt;&lt; <span class="built_in">endl</span>;    　<span class="comment">// "b:c"</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"c:"</span> &lt;&lt; <span class="keyword">typeid</span>(c).name() &lt;&lt; <span class="built_in">endl</span>;    　<span class="comment">// "c:PKc"</span></div></pre></td></tr></table></figure></p>
<p>　　这里我们可以看到，对于变量可以不用明确的去定义其类型，而是用auto代替。其最终效果与传统c++的变量定义效果没有差别。这里可以通过typeid函数进行验证(#include&lt; typeinfo &gt;).<br>　　在很多对于auto的讲解中，它常常被称作占位符。所谓占位符，我的理解是它不能像数据类型那样去声明一个变量。所以使用auto的变量必须进行初始化。理所当然的，也就不能使用c++类型转化将变量转换为auto类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> a;         <span class="comment">//error: declaration of ‘auto a’ has no initializer</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> value1 = <span class="number">10</span>;</div><div class="line"><span class="keyword">auto</span> value2 = (<span class="keyword">auto</span>)value1;    <span class="comment">// error: invalid use of ‘auto’</span></div><div class="line"><span class="keyword">auto</span> value3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">auto</span>&gt;(value１);    <span class="comment">// error: invalid use of ‘auto’</span></div></pre></td></tr></table></figure></p>
<p>　　c++11已经彻底废弃了原有auto的使用方式，如代码所示:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">//error: two or more data types in declaration of ‘a’</span></div></pre></td></tr></table></figure></p>
<p>　　auto可以接受c++的变量名表列的方式定义多个变量，但所有变量应具有相同的数据类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> a1=<span class="number">10</span>, a2=<span class="number">20</span>, a3=<span class="number">30</span>;</div><div class="line"><span class="keyword">auto</span> a4=<span class="number">10</span>, a5=<span class="number">20.0</span>, a6 = <span class="string">'A'</span>;    <span class="comment">// error: conflicting declaration</span></div></pre></td></tr></table></figure></p>
<p>　　auto在初始化时，会自动去除引用、const、volatile的语意。这种说法可能很难理解。其实就是如果原始变量为引用、const、volatile类型，auto初始化时需要自行指明。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">int</span> refa = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> &amp;refb = refa;</div><div class="line"><span class="keyword">auto</span> refc = refb;</div><div class="line"><span class="keyword">auto</span> &amp;refd = refb;</div><div class="line">refa = <span class="number">100</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"refa: "</span> &lt;&lt; <span class="keyword">typeid</span>(refa).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; refa &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 100</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"refb: "</span> &lt;&lt; <span class="keyword">typeid</span>(refb).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; refb &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 100</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"refc: "</span> &lt;&lt; <span class="keyword">typeid</span>(refc).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; refc &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 10</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"refd: "</span> &lt;&lt; <span class="keyword">typeid</span>(refd).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; refd &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 100</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> arrA[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line"><span class="keyword">auto</span> arrB = arrA;</div><div class="line"><span class="keyword">auto</span> &amp;refArrB = arrA;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"arrA: "</span> &lt;&lt; <span class="keyword">typeid</span>(arrA).name() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// A3_i</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"arrB: "</span> &lt;&lt; <span class="keyword">typeid</span>(arrB).name() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//Pi</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"refArrB: "</span> &lt;&lt; <span class="keyword">typeid</span>(refArrB).name() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// A3_i</span></div></pre></td></tr></table></figure></p>
<p>　　auto关键字不仅可以配合变量使用，它在对传统c++函数的代码优化上也可以说是大放异彩。特别是针对那些具有模板类型的函数，更是让我们在编写时变的简单高效。我们来看第一个例子。这里我们在模板函数中使用auto定义了一个站位变量。这样就使得该变量在随着传入值的类型发生变化时，自动进行类型转换。是不是很方便。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx,<span class="keyword">typename</span> _Ty&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(_Tx x, _Ty y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> v = x*y;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//call func</span></div><div class="line">func3(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">// 2</span></div><div class="line">func3(<span class="number">1.1</span>,<span class="number">2.2</span>);    <span class="comment">// 2.42</span></div></pre></td></tr></table></figure>
<p>　　auto关键字可以在函数中使用，那我们自然会想到，它能不能作为函数的返回值占位符。c++11自然提供了这种机制。但是用法可能和我们预期有一定的差距。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">auto func(int x, int y)-&gt;int</div><div class="line">&#123;</div><div class="line">    return x+y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　在c++11中，这样的返回值看起来很奇葩。使用auto来标注函数返回值时，还需要在末尾指定返回类型。会不会觉得还不如不用auto类型。但我觉得制定标准的人肯定也会考虑到这个问题。自然就去搜索了一些相关内容:</p>
<ol>
<li>在函数返回值特别长的时候放在末尾，会显得好看。</li>
<li>c++14会把返回值去掉，让编译器直接支持自动推倒（c++14确实是做到了）</li>
<li>出现在函数后面的表达式在代码编译时也是出现在函数之后的，这就使得很多函数中的临时变量可以出现在这个表达式中。这个我们在后面的decltype使用中可以看到效果。(显然，这个才是我认为最重要的)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//c++14　支持</span></div><div class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> x+y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　这种auto作为函数返回值占位符的用法，会使编写复杂的模板函数时变得相当简单和灵活。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">template &lt;typename _Tx, typename _Ty&gt;</div><div class="line">auto func(_Tx x, _Ty y) -&gt; decltype(x*y)</div><div class="line">&#123;</div><div class="line">    return x*y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//call func</div><div class="line">auto funcA = func(1,2);</div><div class="line">cout &lt;&lt; funcA &lt;&lt; endl;    // 2</div><div class="line">funcA = func(1.1,2.2);</div><div class="line">cout &lt;&lt; funcA &lt;&lt; endl;    // 2</div><div class="line">auto funcB = func(1.1,2.2);</div><div class="line">cout &lt;&lt; funcB &lt;&lt; endl;    // 2.42</div></pre></td></tr></table></figure>
<p>  这里用到了decltype(declared type)，它可以用来通过传入的参数来声明类型。这样func这个模板函数的会很方便的随着模板传入类型来自动改变返回值类型。bravo！</p>
<p>  decltype不存在太多的歧义，这里直接列出代码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">int declint = 10;</div><div class="line">decltype(declint) declintt;</div><div class="line"></div><div class="line">vector&lt;int&gt; vec;</div><div class="line">typedef decltype(vec.begin()) vectype;</div><div class="line"></div><div class="line">decltype(declint) temp1 = declint;</div><div class="line">decltype((declint)) temp2 = declint; //decltype(())定义的是引用类型</div><div class="line">decltype((declint)) temp3;    // error: ‘temp3’ declared as reference but not initialized</div></pre></td></tr></table></figure>
<p>　　接下来我们说一下刚才我们提到的函数返回类型后置的问题。我们已经知道通过decltype可以根据传入参数获取最终的数据类型。那么我们将下面代码进行修改：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// origin, ok~</div><div class="line">template &lt;typename _Tx, typename _Ty&gt;</div><div class="line">auto func(_Tx x, _Ty y) -&gt; decltype(x*y)</div><div class="line">&#123;</div><div class="line">    return x*y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　　一般想法是认为，返回值不就是decltype(x*y)类型么？　那我们直接放前面不是更方便。好的，我们改写一下.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// update</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</div><div class="line"><span class="keyword">decltype</span>(x*y) func(_Tx x, _Ty y)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> x*y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  然而：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">lennybai@lennybai:~/project/cpp11$ g++ main.cpp -std=c++11</div><div class="line">main.cpp:16:10: error: ‘x’ was not declared <span class="keyword">in</span> this scope</div><div class="line"> decltype(x*y) func4(_Tx x, _Ty y)</div><div class="line">          ^</div><div class="line">main.cpp:16:10: error: ‘x’ was not declared <span class="keyword">in</span> this scope</div><div class="line">main.cpp:16:12: error: ‘y’ was not declared <span class="keyword">in</span> this scope</div><div class="line"> decltype(x*y) func4(_Tx x, _Ty y)</div><div class="line">            ^</div></pre></td></tr></table></figure>
<p>　　是的，结果就是这么神奇。这也说明　’function-&gt;expr‘ 中的expr是出现在函数之后的。如果不使用auto占位符，而直接使用decltype(x*y)声明函数类型。由于x,y在函数运行前尚未明确类型，所以这里就会出现编译错误。</p>
<p>　　在这一小节最后需要指出的是，auto是不能作为参数占位符出现的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 客官不可以哦</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">auto</span> x)</span></span></div><div class="line">&#123;</div><div class="line">     <span class="comment">//do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-2-指针空值nullptr"><a href="#2-2-2-指针空值nullptr" class="headerlink" title="2.2.2 指针空值nullptr"></a>2.2.2 指针空值nullptr</h3><p>　　在传统c++中，通常使用NULL来标识空指针。NULL通常是一个与0相关的宏定义。这里是/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h中对NULL的定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (_STDDEF_H) || defined (__need_NULL)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span> NULL		<span class="comment">/* in case &lt;stdio.h&gt; has defined it. */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUG__</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL __null</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>   <span class="comment">/* G++ */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __cplusplus</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>   <span class="comment">/* C++ */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* C++ */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">/* G++ */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>	<span class="comment">/* NULL not defined and &lt;stddef.h&gt; or need NULL.  */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span>	__need_NULL</span></div></pre></td></tr></table></figure></p>
<p>　　我们发现在传统C++中，NULL被定义为0。由于没有类型限制，它可以被强制转换为各种其他数据类型。最常见的例子就是当出现函数重载时会发生混乱。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"call func(int n) : "</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"call func(int *p) : "</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</div><div class="line"></div><div class="line">func(<span class="literal">NULL</span>); <span class="comment">// error: call of overloaded ‘func(NULL)’ is ambiguous</span></div></pre></td></tr></table></figure></p>
<p>　　为了区分不同类型的空指针，C++11引入了nullptr_t类型的指针空值nullptr。它可以自动隐性的转换为所需的成员指针或者函数指针的类型。从而使程序更加清晰明了。值得注意的是，nullptr只能用来标识指针类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"call func(int n) : "</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"call func(int *p) : "</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> nIntNull = <span class="literal">NULL</span>;        <span class="comment">// ok</span></div><div class="line">    <span class="keyword">int</span> *pIntNull = <span class="literal">NULL</span>;        <span class="comment">// ok</span></div><div class="line">    <span class="keyword">int</span> *pIntNullptr = <span class="literal">nullptr</span>;    <span class="comment">// ok</span></div><div class="line">    <span class="keyword">int</span> nIntNullptr = <span class="literal">nullptr</span>;    <span class="comment">// error: cannot convert ‘std::nullptr_t’ to ‘int’ in initialization</span></div><div class="line"></div><div class="line">    func(<span class="literal">NULL</span>); <span class="comment">// error: call of overloaded ‘func(NULL)’ is ambiguous</span></div><div class="line">    func(<span class="literal">nullptr</span>); <span class="comment">// call func(int *p)</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-2-3-常量区分符constexpr"><a href="#2-2-3-常量区分符constexpr" class="headerlink" title="2.2.3 常量区分符constexpr"></a>2.2.3 常量区分符constexpr</h3><p>　　常量表达式在c++中还是很常见的，特别是在数组或者容器等初始化时传入的大小通常为常量表达式。在C++中，常量表达式通常被解释为在编译时可以明确其值的表达式。最常见的常量表达式就是被const标识的变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n = <span class="number">1</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, n&gt; a1; <span class="comment">// error, n is not a constant expression</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> cn = <span class="number">2</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, cn&gt; a2; <span class="comment">// OK, cn is a constant expression</span></div></pre></td></tr></table></figure></p>
<p>　　其实，在我们进行程序设计的时候，常常会发现很多情况是需要根据运行情况去获取一个值，然后再进行数据或者容器大小的分配。而这些值我们在给定条件值之后，很容易就会被推导出来。而对于计算机来说，却需要在每次运行时不断重复相同的推倒工作。那么我们可能会觉得，如果可以像常量表达式那样在编译时就确定其值，是不是在运行时就可以得到更高的运行效率呢。c++为我们提供了常量区分符constexpr来实现这一效果。<br>　　constexpr用来标示一个变量或者函数为常量表达式，也是告诉编译器需要去验证它们是不是一个常量表达式。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">int x;</div><div class="line">struct A &#123;</div><div class="line">    constexpr A(bool b) : m(b?42:x) &#123; &#125;</div><div class="line">    int m;</div><div class="line">&#125;;</div><div class="line">constexpr int v = A(true).m; // OK</div><div class="line">constexpr int w = A(false).m; // error: non-const x</div><div class="line">constexpr int mf = 20;          // 20是常量表达式</div><div class="line">constexpr int limit = mf + 1;   // mf + 1是常量表达式</div><div class="line">constexpr int sz = size();      // 只有当size是一个constexpr函数时才是一条正确的声明语句</div><div class="line"></div><div class="line">constexpr int A()</div><div class="line">&#123;</div><div class="line">    return 10;</div><div class="line">&#125;</div><div class="line"></div><div class="line">constexpr int fibonacci1(const int n) &#123;</div><div class="line">    return n == 1 || n == 2 ? 1 : fibonacci1(n-1)+fibonacci1(n-2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// c++11 error error: body of constexpr function ‘constexpr int fibonacci2(int)’ not a return-statement</div><div class="line">// c++14 OK</div><div class="line"> constexpr int fibonacci2(const int n) &#123;</div><div class="line">     if(n == 1) return 1;</div><div class="line">  　 if(n == 2) return 1;</div><div class="line">  　 return fibonacci2(n-1)+fibonacci2(n-2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int i1 = 10;</div><div class="line">const int i2 = i1;</div><div class="line">const int i3 = 10;</div><div class="line">constexpr int x1 = i1;    // error: the value of ‘i1’ is not usable in a constant expression</div><div class="line">constexpr int x2 = i2;    // error: the value of ‘i2’ is not usable in a constant expression</div><div class="line">constexpr int x3 = i3;    // ok</div><div class="line">constexpr int x4 = 10;    // ok</div><div class="line">constexpr int x5 = A();   // ok</div><div class="line">constexpr int x6 = fibonacci1(10);    // ok</div><div class="line">constexpr int x7 = cin.get(); // !error</div><div class="line">constexpr int x8 = fibonacci2(10);</div><div class="line"></div><div class="line">int a[i2];    // ok</div><div class="line">int b[x4];    // ok</div></pre></td></tr></table></figure></p>
<p>　　从上面的代码中我们可以大概了解到constexpr的作用与用法。这里以上代码进行一些说明：</p>
<ol>
<li>c++11中对constexpr修饰的函数只能直接返回常量表达式。c++14中进行了增强，它可以支持局部变量和条件语句等。</li>
<li><p>const int i2为运行时赋值，所以x2 = i2 报错； const int i3为常量表达式，所以x3=i3没问题</p>
<p> 对于constexpr可以在这里<a href="http://cpptruths.blogspot.jp/2011/07/want-speed-use-constexpr-meta.html" target="_blank" rel="external">了解更多</a>。</p>
</li>
</ol>
<h3 id="2-2-4-range-based-for-loop"><a href="#2-2-4-range-based-for-loop" class="headerlink" title="2.2.4 range-based for loop"></a>2.2.4 range-based for loop</h3><p>　　在cppreference中，这个特性被描述为：</p>
<blockquote>
<p>Executes a for loop over a range.Used as a more readable equivalent to the traditional for loop operating over a range of values, such as all elements in a container.　</p>
</blockquote>
<p>　<br>　　这个描述有些官方和笼统。其实，range-based for loop在c++11中加入，它使得c++开始支持类似于’foreach’的范式格式。这种新格式使得我们获取或者操作数组时变得更容易，前提是我们不去关心索引，迭代器和数量的前提下。range-based　for loop可以支持迭代所有的c类型数组，初始化列表和重载了begin()和end()函数的容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">    v.push_back(<span class="number">1</span>);</div><div class="line">    v.push_back(<span class="number">2</span>);</div><div class="line">    v.push_back(<span class="number">3</span>);</div><div class="line">    m[<span class="string">"my_vector"</span>] = v;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; tempM : m)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; tempM.first &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; tempV : tempM.second)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; tempV &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>&amp; e : arr)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        e = e*e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>&amp; e : arr)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-5-快速初始化列表"><a href="#2-2-5-快速初始化列表" class="headerlink" title="2.2.5 快速初始化列表"></a>2.2.5 快速初始化列表</h3><p>　　在c++11中，它提供了更便捷，或者说是更人性化的初始化方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//c++ 98 error: in C++98 ‘m’ must be initialized by constructor, not by ‘&#123;...&#125;’</span></div><div class="line"><span class="comment">//c++ 11</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; v[<span class="number">3</span>] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="comment">//c++98 error: could not convert ‘&#123;&#123;1, 2&#125;&#125;’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘std::map&lt;int, int&gt;’</span></div><div class="line"><span class="comment">//c++11 ok</span></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; m[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>  对于对象的内部属性初始化，我们可以通过调用参数为initializer_list的方法快速初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> myclass &#123;</div><div class="line">  myclass (<span class="keyword">int</span>,<span class="keyword">int</span>);</div><div class="line">  myclass (<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;);</div><div class="line">  <span class="comment">/* definitions ... */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myclass foo &#123;<span class="number">10</span>,<span class="number">20</span>&#125;;  <span class="comment">// calls initializer_list ctor</span></div><div class="line"><span class="function">myclass <span class="title">bar</span> <span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;  <span class="comment">// calls first constructor</span></div></pre></td></tr></table></figure></p>
<h3 id="2-2-6-类型别名"><a href="#2-2-6-类型别名" class="headerlink" title="2.2.6 类型别名"></a>2.2.6 类型别名</h3><p>　　传统c++同常使用typedef为类型定义一个新的名称。给函数声明去做个别名是比较常见的使用方式。</p>
<blockquote>
<p>typedef void (*SigHandler)(int);</p>
</blockquote>
<p>　　这个是unix中信号处理的圆形函数。它讲一个参数为int并返回值为void的函数原型重命名为SigHandler.这个原型相对还比较容易理解。但在我们平时的编程过程中，遇到的情况往往比这要复杂得多。c++11为我们提供了一个更符合人类思维和更直观的表述方式(这话是我自己说的，不要追究责任２３３３３３)。</p>
<blockquote>
<p>using SigHandler = void(*)(int);</p>
</blockquote>
<p>　　这里就提高了using关键字。在传统c++中，对于using 我们可能唯一的用法就是using namespace。而在c++11中，它获得了更多的功能。下面我们继续说一些其他的别名使用情况。提到类型别名，我们有的时候会想到，能不能讲某些又臭又长的模板类型给做个别名。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> X, <span class="keyword">typename</span> Y, <span class="keyword">typename</span> Z&gt;</div><div class="line"><span class="keyword">class</span> MyTest</div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MyTest();</div><div class="line">    <span class="keyword">virtual</span> ~MyTest();</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    X x;</div><div class="line">    Y y;</div><div class="line">    Z z;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</div><div class="line"><span class="keyword">typedef</span> MyTest&lt;<span class="keyword">int</span>,U,<span class="keyword">int</span>&gt; mm; <span class="comment">//error: template declaration of ‘typedef’</span></div></pre></td></tr></table></figure></p>
<p>  在传统c++中，它并不支持对上述初始化部分类型的模板类进行再次重命名。而c++11中可以通过using关键字得到实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</div><div class="line"><span class="keyword">using</span> mm = MyTest&lt;<span class="keyword">int</span>,U,<span class="keyword">int</span>&gt;;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3 参考文献"></a>3 参考文献</h1><ul>
<li>[1]: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf" target="_blank" rel="external">c++标准</a></li>
<li>[2]: <a href="http://en.cppreference.com/w/cpp/types/NULL" target="_blank" rel="external">cppreference</a></li>
<li>[3]: <a href="http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer" target="_blank" rel="external">Ten C++11 Features Every C++ Developer Should Use</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;　　起草本文的目的主要有两点：第一点，在c++11学习的过程中做一些摘要总结，尽量取其精华，为自己梳理出来一个比较清晰的记忆脉络；第二点，不得不说的就是随着年纪的增长，记忆力也开始变得并不那么可靠，做些记录，定期回头看看总是好的。&lt;br&gt;　　文章会对c++11（其实是c++1x更准确些）的背景进行简要的概述，并尽量详细且准确的阐述c++11的新的特性。共同学习，不断进步。&lt;/p&gt;
&lt;h2 id=&quot;1-1-c-11概述&quot;&gt;&lt;a href=&quot;#1-1-c-11概述&quot; class=&quot;headerlink&quot; title=&quot;1.1 c++11概述&quot;&gt;&lt;/a&gt;1.1 c++11概述&lt;/h2&gt;&lt;p&gt;　　我们生活中常常谈论的c++更多的是指传统c++，又或是可以称为c++98的版本。c++11也并不是什么神秘的新语言，而是基于传统c++发布13年后的第一次重大修订。它主要基于现在软件行业发展的新需求与新诉求进行的一种调整——增加新特性并弃用部分特性。&lt;/p&gt;
    
    </summary>
    
      <category term="程序设计" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="c++11" scheme="http://lennybai.cn/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/c-11/"/>
    
    
      <category term="编程" scheme="http://lennybai.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c++11" scheme="http://lennybai.cn/tags/c-11/"/>
    
  </entry>
  
</feed>
