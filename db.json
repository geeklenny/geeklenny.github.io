{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/diagrams/test-diagram-0.png","path":"diagrams/test-diagram-0.png","modified":1,"renderable":0},{"_id":"source/diagrams/test-diagram-1.png","path":"diagrams/test-diagram-1.png","modified":1,"renderable":0},{"_id":"source/images/201611/lennybaiwebsite.jpg","path":"images/201611/lennybaiwebsite.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/12avatar.gif","path":"images/12avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/lennybaiwebsite.png","path":"images/lennybaiwebsite.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"c4ffd2fe7ea8b86234bf7462990c333d59394761","modified":1478252360609},{"_id":"source/baidu_verify_wBa8vF3BPm.html","hash":"9f6fdd158bded29efea2976e1e66e7201c95232b","modified":1478487662340},{"_id":"source/favicon.ico","hash":"9ee20ffe17a8ad7435b432ff1031630bc01e3199","modified":1478487192832},{"_id":"source/robots.txt","hash":"da3860b889698f3cc5f10dc1bedde73ae433dc71","modified":1478431375114},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1478229513440},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1478229513440},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1478229513444},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1478229513444},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1478229513444},{"_id":"themes/hexo-theme-next/README.en.md","hash":"565ba52b3825b85a9f05b41183caca7f18b741d4","modified":1478229513444},{"_id":"themes/hexo-theme-next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1478229513444},{"_id":"themes/hexo-theme-next/_config.yml","hash":"a8f60227c4325637a7240426809e56b781a1da24","modified":1481529185905},{"_id":"themes/hexo-theme-next/bower.json","hash":"023b5b945bc45c205129a18e26d304fb9caa15c7","modified":1478229513444},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"d267332ec1461042fb16a9cb0737e1555fb4b79e","modified":1478229513444},{"_id":"themes/hexo-theme-next/package.json","hash":"0d43e71169c5e08917e73cd12aa79562c836712e","modified":1478229513448},{"_id":"source/_posts/ActiveMQ使用记录.md","hash":"56b5381eab833b7d2d1bb89c71b1f69e2f0d3839","modified":1482202258003},{"_id":"source/_posts/c-11条件变量.md","hash":"445d5f3650fc5aee5050650f6ad2f0ae7368c0f1","modified":1482221963309},{"_id":"source/_posts/effective-c-小记.md","hash":"d91a10aab84972cf76d88209bd9d869683c0f0f3","modified":1480991428958},{"_id":"source/_posts/elasticsearch上手练.md","hash":"2d62b2e84b6cabde18ed99a49ad89f9351015848","modified":1482202991121},{"_id":"source/_posts/g-template-class.md","hash":"9e24a57f05fa8bbcba2354611ada7fcbf67e004f","modified":1482204465923},{"_id":"source/_posts/leetcode-AddTwoNum.md","hash":"6bf28b66ceafae7a8d002fad2918c4d14bfc200e","modified":1481538701966},{"_id":"source/_posts/leetcode-LongestPalindromicSubstring.md","hash":"8696effa5c6fa38f9a31d19168561d2ad1d97e21","modified":1482215813265},{"_id":"source/_posts/leetcode-ReverseInteger.md","hash":"0382a9a4bcc949c6d01b4770364ad1f3248b6587","modified":1482305127377},{"_id":"source/_posts/leetcode-MedianOfTwoSortedArrays.md","hash":"58a3105878e67e82df2ab0a3ed88153255f8637a","modified":1482117159470},{"_id":"source/_posts/leetcode-twosum.md","hash":"64b15d6c67d3c9adf20d23067586cfca455eb551","modified":1481534370138},{"_id":"source/_posts/linux-小技巧.md","hash":"df70a7259a90011cb39392176676d7cac5b15e3a","modified":1479808282241},{"_id":"source/_posts/redis学习之参考文档.md","hash":"cc6e962418ff84fee16a5f47babe3736205564de","modified":1481617684673},{"_id":"source/_posts/leetcode-longestSubStringWithOutRepeatingCharacters.md","hash":"dab507bcc8224613ee33133ca14563e1cc7e5cc5","modified":1481676654760},{"_id":"source/_posts/数据库连接池(c++).md","hash":"bf9f7bfd24317813cf99fe9199138bb4f3a4dd54","modified":1482137737869},{"_id":"source/_posts/算法导论-分治策略.md","hash":"1f494d7771d8beba3aae0d312ba7ac0678beac07","modified":1481676713498},{"_id":"source/_posts/了解c-11.md","hash":"7b6b4f050f322afe454ff6311d804afe3fbe9328","modified":1479863239984},{"_id":"source/_posts/编程珠玑.md","hash":"9e310e4241cdff9916b61debb0f52d1298b6acd4","modified":1482472971835},{"_id":"source/_posts/网站浏览记录.md","hash":"dfdf769955743716d58248f51909bc71693610f5","modified":1482222221065},{"_id":"source/_posts/算法导论-动态规划.md","hash":"77a2ea9dc5a97219fffbec7e9c40486389763bac","modified":1481600477991},{"_id":"source/_posts/算法导论1.md","hash":"3d3502354f80730a30b8e0c05578c8ec8d7b1316","modified":1482112913945},{"_id":"source/diagrams/test-diagram-0.png","hash":"0341d9ec6b1a04884c9853021d135c4bef3b699e","modified":1478833467239},{"_id":"source/diagrams/test-diagram-1.png","hash":"1ba86b8ddefc6510ca51005fe6c3df59153c15b5","modified":1478833467139},{"_id":"source/tags/index.md","hash":"869cb232414ec4f1dae72088e121cb56310b3919","modified":1478264767147},{"_id":"source/categories/index.md","hash":"dfaa8a37ca516e92106bb05fa67d7c14e99a8c09","modified":1478264836566},{"_id":"source/guestbook/index.md","hash":"38ab6ac05b37d7462f98d6df70f1f22e73e81fb6","modified":1478254259026},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"e1b85f9cc22209de31fd13e3cc8dcbbe8ccd70b7","modified":1478366865520},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"8019d02232a6dd1a665b6a4d2daef8e5dd2f0049","modified":1478248930480},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1478229513448},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"786afba25cfc98845a20d9901823ebeebcd1cbbf","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"9db835c0543ade5a89bc80ec5a898203227cf3d8","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"63de36e9f5822084b61b03a507f6246f8f962b3f","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"1a084623c39de74301f3e92f9388a3a815a542ca","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"147c01e41b931085ad14250fa900c2249dcbbdd7","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"a2c7b6301b5474aab798946fb700289df237c3cf","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"ce8b047c89daae77c03482fc76f16ffec6bdbf2d","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"462aa865ca3d479bcf6b363cba61247b50f230ff","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"ca239b39bf65c9462e59d51b12f0fe566d453197","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"cc7b964a46587aea0e57b0a5269d8fd25570858e","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"6b3dc7bd7fba96e6a69b13b7b00bcd2a75c468df","modified":1478243295934},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1478229513448},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"519ab3d817ec3bc5bfc91159c494b6b3c170bea7","modified":1478229513444},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"6b1f345aaefc13e6723dc8a6741b59ac05c20dfd","modified":1478229513444},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1478229513472},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1478229513472},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1478229513472},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513456},{"_id":"source/images/201611/lennybaiwebsite.jpg","hash":"83470eeec7e3af004eb3e8e560ed2504f4018623","modified":1478577955948},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"58fd826ca75b0cbc48b61a58da4b841e2fa34403","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"053a1ef38d1eeb5ba92579d1353fbeec7d192044","modified":1478306321023},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"06b6604176367af52587312e2575b52ecf53c3d9","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"011b9d6c9f0a2f4654908ea20b9391f9b7981271","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"eb028685cb3c329537bbced06c063d23e6a33817","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"0b91cadecead8e0b5211cc42b085998d94af503a","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_macro/mobile-code.swig","hash":"6987e11ce13dfe32f42f6e250b46d17276fb8e82","modified":1478330631639},{"_id":"themes/hexo-theme-next/layout/_macro/passage-end-tag.swig","hash":"3f5a4fdcb23061f9258a429000aa71d5134d8bd9","modified":1478309788596},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"bc311e9f4333188da5c9c721ae467ba14410d5b2","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"8c6d320dfa371a45acb7699f1716dc4db6fbe6fc","modified":1478309851023},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"084867c289c95c5ebc18435a3b2092091bb8e2ba","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1478229513444},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1478229513448},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"3acce36db0feb11a982c6c799aa6b6b47df2827c","modified":1478229513448},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/12avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/alipay.jpg","hash":"fe821a90e261f657dd9f7df0f05c19d9622f6264","modified":1478404983375},{"_id":"themes/hexo-theme-next/source/images/avatar.jpg","hash":"2a77ea96b0a06aee4af83a1d66ae865283b505e7","modified":1478403305241},{"_id":"themes/hexo-theme-next/source/images/avatar.png","hash":"ef09de6175d3c5835456dd76e0f66b211d65f1f0","modified":1478221386374},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/images/wechatpay.jpg","hash":"e0dba993f47c42b19b60fc29aef61c756d6dae79","modified":1478404399414},{"_id":"themes/hexo-theme-next/source/images/lennybaiwebsite.png","hash":"43a4dcd12d28502fd4058b37c72ebf9da2a6d715","modified":1479186483460},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1478229513456},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"10683fe1241ed75ca0aae6c3096bf27acbea6f74","modified":1478305952979},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1478229513444},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics.swig","hash":"0a89c04055bade7baa5962f1d5aefe438d83a244","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments.swig","hash":"907b931d775d32405d02a25b3b0a3ac03bf804d0","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/lean-analytics.swig","hash":"a08d45cf6da12bff0db95c68e0cc66c81e006bb2","modified":1478239135686},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/localsearch.swig","hash":"dc8023c524594b6b85905c776899f5f53973577f","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/mathjax.swig","hash":"5bafc33f57508d1d04a9930165240f6e9efa8d6d","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"149d528e967651b4442672e0bbbc78efd2c92392","modified":1478498019058},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"3ead77befa064d6327dc7afd0a5af7be59a5f196","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"c5a4d367d706e7981ed9fb01ed0fe172ad5e3d27","modified":1478318599739},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"7da985a99674e54f514d4fd9fcd3bcea6e7e41d5","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1478229513472},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1478229513472},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1478229513472},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1478229513468},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"7c43d66da93cde65b473a7d6db2a86f9a42647d6","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/disqus.swig","hash":"3065c1bcb54da1e0018136595741341ac71ef9e7","modified":1478229513448},{"_id":"themes/hexo-theme-next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"696666141cdd204fd8818ac2ad18f05e320f8587","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"b3448da168dee8ababcdfd44b0d44ba4b5f32107","modified":1478367604272},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"4303776991ef28f5742ca51c7dffe6f12f0acf34","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"fb1fe1e86e9198ea470dbd8de2bb13ef21e30a45","modified":1478306234728},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"c2c6c4f6434b4f94aac2af5861cd769427f0ee10","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/__logo.styl","hash":"bdd5d6715d3739213ced1714e03e32df81cc1f9d","modified":1478268506618},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"be22ad34f546a07f6d56b424338cdd898683eea4","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_full-image.styl","hash":"938d39eedc6e3d33918c1145a5bf1e79991d3fcf","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"7b206cd8921bc042f8e37a74aea1abc8a5ec8ab4","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"d09280e5b79f3b573edb30f30c7a5f03ac640986","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"d4b7bd610ca03dbb2f5b66631c0e84a79fb4660b","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"1b10ba2d3ad0c063c418dc94a0b7e0db4b342c53","modified":1478268613711},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1478229513464},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1478229513472},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"314c7237be7e2e727710179be6021a76a5983d0b","modified":1478367436632},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1478229513448},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"90f8f9706cd7fe829cf06e9959a65fd3f8b994fa","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"d23db2f598b8eb274680023745ba6d6d466cd84a","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"d543d1377c1f61b70e3adb6da0eb12797552e5f2","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-more-link.styl","hash":"15063d79b5befc21820baf05d6f20cc1c1787477","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"cbca4842a54950e2934b3b8f3cd940f122111aef","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"14bc717d806d839930d72f62308ff73dd800ea4a","modified":1478309694966},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"618f73450cf541f88a4fddc3d22898aee49d105d","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"8e66c2635d48e11de616bb29c4b1323698eebc0a","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"3afc459442c132c480d1d832f1a872f1070bb048","modified":1478229513452},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1478229513456},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1478229513460},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1478229513468},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1478229513464},{"_id":"public/baidusitemap.xml","hash":"ebf5d1d5a5af7d7af1248ebcdc06ec64db69a334","modified":1482473005211},{"_id":"public/atom.xml","hash":"668566d36ccc86437b9aed9da8ca1c4726a698a5","modified":1482473005241},{"_id":"public/sitemap.xml","hash":"3d0a2465d3f239d4c5325ada36037ce4ae05ea4d","modified":1482473005241},{"_id":"public/search.xml","hash":"81701efaa3dc9da562e549da80ff2bd960fdee84","modified":1482473005242},{"_id":"public/baidu_verify_wBa8vF3BPm.html","hash":"6471f03f239d1361a1d530d8dc82889d408e8071","modified":1482473005266},{"_id":"public/tags/index.html","hash":"a812d27a4cefb19bed5ecbd7824ba9c03b5c1bc9","modified":1482473005266},{"_id":"public/categories/index.html","hash":"8dde3758a2e449834b6dddc1f584a2b22e574ec4","modified":1482473005266},{"_id":"public/guestbook/index.html","hash":"3de70e816abb8abd9dd15740b8bcb12270399b73","modified":1482473005267},{"_id":"public/2016/12/21/leetcode-ReverseInteger/index.html","hash":"92d7ef1785eba9d62ee7182590e95bd581c05fe6","modified":1482473005267},{"_id":"public/2016/12/20/c-11条件变量/index.html","hash":"405b42bb212ba9851a918d7c5f2b6b4bb99df6f9","modified":1482473005267},{"_id":"public/2016/12/20/leetcode-LongestPalindromicSubstring/index.html","hash":"dfa67e96869e53b3124a058a3632b846c474fbc1","modified":1482473005267},{"_id":"public/2016/12/19/leetcode-MedianOfTwoSortedArrays/index.html","hash":"6e38d46207b8d689fc8e13694244a3b16226299a","modified":1482473005267},{"_id":"public/2016/12/15/ActiveMQ使用记录/index.html","hash":"11e664f7c2c32c885cb1ae83df85ef367a8d714d","modified":1482473005267},{"_id":"public/2016/12/13/leetcode-longestSubStringWithOutRepeatingCharacters/index.html","hash":"5241d24c9c9384b2e82356dffbc3cbba1714d4a2","modified":1482473005267},{"_id":"public/2016/12/13/算法导论-动态规划/index.html","hash":"7ad101352e8525c46bc9f5dfb11ab930720611f5","modified":1482473005267},{"_id":"public/2016/12/12/leetcode-AddTwoNum/index.html","hash":"4a80e8f7d795d81145d92a97bfa131b98b9f0250","modified":1482473005267},{"_id":"public/2016/12/12/算法导论-分治策略/index.html","hash":"9399f64630c2e377d1c86f885e10dd38f14e6a32","modified":1482473005267},{"_id":"public/2016/12/09/leetcode-twosum/index.html","hash":"5736cd08d090b21253cac48b2b82ea3312b6e563","modified":1482473005267},{"_id":"public/2016/12/06/编程珠玑/index.html","hash":"68f065fb3b83692131c8e220c65b3c9c867c2f25","modified":1482473005268},{"_id":"public/2016/12/05/网站浏览记录/index.html","hash":"39a4ca46bee6fbb28f49353cc32bd134df68c17c","modified":1482473005268},{"_id":"public/2016/12/02/effective-c-小记/index.html","hash":"b75495c2bf6b35e772240522c24f5f061a2e255a","modified":1482473005268},{"_id":"public/2016/12/02/算法导论1/index.html","hash":"7b65ad6d68701a5b94557af6f19ee944b842bc86","modified":1482473005268},{"_id":"public/2016/12/02/elasticsearch上手练/index.html","hash":"6066d9614301272449796771ffc0959f685e4e56","modified":1482473005268},{"_id":"public/2016/12/02/数据库连接池(c++)/index.html","hash":"535e8da3ce567a637fe23ad78d2d789034373f30","modified":1482473005268},{"_id":"public/2016/12/02/redis学习之参考文档/index.html","hash":"b73b8675f0e52c8a6e80f0a430b59a41ee0bbfc6","modified":1482473005268},{"_id":"public/2016/11/25/g-template-class/index.html","hash":"0c091383c867fc8e1cd85c090f4ec1ee4fc1fc5d","modified":1482473005268},{"_id":"public/2016/11/22/linux-小技巧/index.html","hash":"f9f4859d132ab6999262e28b83104961d361e19e","modified":1482473005268},{"_id":"public/2016/11/14/了解c-11/index.html","hash":"e15acfe761355348833d659d0762a2e1c974ca37","modified":1482473005268},{"_id":"public/archives/index.html","hash":"9b4d43bdfae135325622b6679fecfb6e3cfdabb7","modified":1482473005269},{"_id":"public/archives/page/2/index.html","hash":"87342e5d6ab31d115e6b6ac8895e42ae65f858b9","modified":1482473005269},{"_id":"public/archives/2016/index.html","hash":"c8dc76e178d6aa7baad99f5d08399c842205eaa3","modified":1482473005269},{"_id":"public/archives/2016/page/2/index.html","hash":"1d7e18477652da86187feab83c6ca7fb5de64982","modified":1482473005269},{"_id":"public/archives/2016/11/index.html","hash":"ed9a9f2063c753ac954cb1321f51d9b000eda376","modified":1482473005269},{"_id":"public/archives/2016/12/index.html","hash":"06ea09ade2707a00fd438685b02aa1f4ec08d730","modified":1482473005269},{"_id":"public/archives/2016/12/page/2/index.html","hash":"8786668a42f8cf19f69db07ee5ebf6ea2e1608a6","modified":1482473005269},{"_id":"public/categories/读书笔记/index.html","hash":"c7b456f1f9e8efd588b7240e20633b5e3a35aea9","modified":1482473005269},{"_id":"public/categories/程序设计/index.html","hash":"4c591dc2dab02f250fa09de9c9767a0777a194ef","modified":1482473005269},{"_id":"public/categories/读书笔记/ActiveMQ/index.html","hash":"f86ca85ae947af35adb451d647ebe402fb7cf8c0","modified":1482473005269},{"_id":"public/categories/程序设计/leetcode/index.html","hash":"b2b599b8d8a63f30ac3225a339911752abbd38a2","modified":1482473005269},{"_id":"public/categories/程序设计/c-11/index.html","hash":"0a462af3720244323e8c6d7e8a10fdf03ca92db5","modified":1482473005270},{"_id":"public/categories/读书笔记/more-effective-c/index.html","hash":"ff4fd6256f0105a3c444daf4f47afe784dd71e15","modified":1482473005270},{"_id":"public/categories/程序设计/elasticsearch/index.html","hash":"a3afd24e36c271a3d5bf912d4d43b99cd1c0485a","modified":1482473005270},{"_id":"public/categories/操作系统/index.html","hash":"42e81fddf770bbca762c20510073e968077e8c38","modified":1482473005270},{"_id":"public/categories/读书笔记/redis官方文档/index.html","hash":"cdeee22141ff25fce4690624ef67b920ebd8f18d","modified":1482473005270},{"_id":"public/categories/程序设计/数据库连接池/index.html","hash":"ed5f94c6fb2c2436da43ab175018e8fb8f98a209","modified":1482473005270},{"_id":"public/categories/读书笔记/算法导论/index.html","hash":"a0e33428ae13237fbafcbbaffc716d528d131d97","modified":1482473005270},{"_id":"public/categories/读书笔记/编程珠玑/index.html","hash":"03f45cc72549e9e74af03df686469df08c5d4466","modified":1482473005270},{"_id":"public/categories/读书笔记/网站地址/index.html","hash":"8cee6a9dd47795b2e82ee71685911967090fec51","modified":1482473005270},{"_id":"public/categories/操作系统/使用技巧/index.html","hash":"9c4370607ebd38a60edf9c1ae310860b91e1dea7","modified":1482473005270},{"_id":"public/index.html","hash":"4c92bcba8e18df3c0e40ee3bffc23fb104b43780","modified":1482473005270},{"_id":"public/page/2/index.html","hash":"e27d6a89d7857910ac737bceda0b92db59948bb8","modified":1482473005271},{"_id":"public/tags/读书笔记/index.html","hash":"1f87d41c6004a5dac3a72aa01cc645dba4f23df8","modified":1482473005271},{"_id":"public/tags/ActiveMQ/index.html","hash":"31ff3b35c4426176bcd0d82f0bfd378c1ed936f7","modified":1482473005271},{"_id":"public/tags/程序设计/index.html","hash":"8e561ecae5fedcad155501f8379e931bbd40c3ba","modified":1482473005271},{"_id":"public/tags/c-11/index.html","hash":"45ea38273163203afcf918ee1f76533a8bb50530","modified":1482473005271},{"_id":"public/tags/条件变量/index.html","hash":"00f19766a009bc716478a070b251237e07b94115","modified":1482473005271},{"_id":"public/tags/more-effective-c/index.html","hash":"5a855d6fcba9d5a4a7f5063b6c819b5131afd515","modified":1482473005271},{"_id":"public/tags/elasticsearch/index.html","hash":"e7ddb254080c5b957a870aba3711ba1575e80533","modified":1482473005271},{"_id":"public/tags/leetcode/index.html","hash":"c5d18983291acee34fd0c772408ed9c749a55e8b","modified":1482473005271},{"_id":"public/tags/linux/index.html","hash":"438621119971ab927347a2046e6a6efb928926f3","modified":1482473005271},{"_id":"public/tags/系统相关/index.html","hash":"d1321ef47d81c71df87340b5df54c0d5ab9dc308","modified":1482473005272},{"_id":"public/tags/redis/index.html","hash":"0cd155700b4321622ae9cfb914e8710d013f3034","modified":1482473005272},{"_id":"public/tags/c/index.html","hash":"b9452fcd31d191d2d2cfd4d520d5c0c229aeda62","modified":1482473005272},{"_id":"public/tags/数据库连接池/index.html","hash":"1ce94ccda45ba3ef5d40f4315b9f4bc627ec6142","modified":1482473005272},{"_id":"public/tags/算法导论/index.html","hash":"3e07f259015c8e5c1df5cba6f43d688ce0781b4b","modified":1482473005272},{"_id":"public/tags/分治策略/index.html","hash":"83bdc7944b68889e3468bc0b3a2175243ab7f21c","modified":1482473005272},{"_id":"public/tags/快速排序/index.html","hash":"38cf4e90fd461e72b1eb864e5942c42b4d57e9f0","modified":1482473005272},{"_id":"public/tags/堆排序/index.html","hash":"50a0bbc02a8d22609752c919cc637cf0d094fdfb","modified":1482473005272},{"_id":"public/tags/编程/index.html","hash":"867ad37419c86869442d2e55c7310e04fee64b40","modified":1482473005272},{"_id":"public/tags/编程珠玑/index.html","hash":"120e9d73dfa19edaea79ca02ec3e74dcace32139","modified":1482473005272},{"_id":"public/tags/网址推荐/index.html","hash":"1f18217c2baaff640e5365e08af5220742695843","modified":1482473005273},{"_id":"public/tags/学习笔记/index.html","hash":"a7815f1e49565c2fd1939be20f96a28a9f1da8c1","modified":1482473005273},{"_id":"public/tags/动态规划/index.html","hash":"1d2f87a22aa343fb84024330f9211c2434480527","modified":1482473005273},{"_id":"public/CNAME","hash":"c4ffd2fe7ea8b86234bf7462990c333d59394761","modified":1482473005290},{"_id":"public/favicon.ico","hash":"9ee20ffe17a8ad7435b432ff1031630bc01e3199","modified":1482473005290},{"_id":"public/robots.txt","hash":"da3860b889698f3cc5f10dc1bedde73ae433dc71","modified":1482473005290},{"_id":"public/diagrams/test-diagram-0.png","hash":"0341d9ec6b1a04884c9853021d135c4bef3b699e","modified":1482473005290},{"_id":"public/diagrams/test-diagram-1.png","hash":"1ba86b8ddefc6510ca51005fe6c3df59153c15b5","modified":1482473005290},{"_id":"public/images/12avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1482473005290},{"_id":"public/images/201611/lennybaiwebsite.jpg","hash":"83470eeec7e3af004eb3e8e560ed2504f4018623","modified":1482473005291},{"_id":"public/images/alipay.jpg","hash":"fe821a90e261f657dd9f7df0f05c19d9622f6264","modified":1482473005291},{"_id":"public/images/avatar.jpg","hash":"2a77ea96b0a06aee4af83a1d66ae865283b505e7","modified":1482473005291},{"_id":"public/images/avatar.png","hash":"ef09de6175d3c5835456dd76e0f66b211d65f1f0","modified":1482473005291},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1482473005291},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1482473005291},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1482473005291},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1482473005291},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1482473005291},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1482473005291},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1482473005292},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482473005292},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1482473005292},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1482473005292},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1482473005292},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1482473005292},{"_id":"public/images/wechatpay.jpg","hash":"e0dba993f47c42b19b60fc29aef61c756d6dae79","modified":1482473005292},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1482473005292},{"_id":"public/images/lennybaiwebsite.png","hash":"43a4dcd12d28502fd4058b37c72ebf9da2a6d715","modified":1482473005292},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"69a4c537d167b68a0ccf1c6febd138aeffca60d6","modified":1482473005292},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1482473005292},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1482473005292},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1482473005293},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1482473005293},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1482473005293},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1482473005293},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1482473005293},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1482473005293},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1482473005293},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1482473006392},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1482473006399},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1482473006401},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1482473006412},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1482473006412},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1482473006412},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1482473006412},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1482473006412},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1482473006412},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1482473006412},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1482473006412},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1482473006412},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1482473006412},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1482473006412},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1482473006413},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1482473006413},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1482473006413},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1482473006413},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1482473006413},{"_id":"public/js/src/utils.js","hash":"e5cb720894c4bc28ca8f10b33df127fb394018d9","modified":1482473006413},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1482473006413},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1482473006413},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1482473006413},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1482473006413},{"_id":"public/js/src/schemes/pisces.js","hash":"7506e7490c69a200831393c38d25e91c156bd471","modified":1482473006413},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1482473006416},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1482473006416},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1482473006416},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1482473006416},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1482473006416},{"_id":"public/css/main.css","hash":"811cc5c092a14b0b7b215cc1101a3dccf2e1c1bf","modified":1482473006416},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1482473006416},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1482473006417},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1482473006417},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1482473006417},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1482473006417},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1482473006417},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1482473006417},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1482473006418},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1482473006418},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1482473006418},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"2b3c8ba7008cc014d8fb37abc6f9f49aeda83824","modified":1482473006453}],"Category":[{"name":"读书笔记","_id":"cix1e5cdp0005nvouyczw5r2v"},{"name":"程序设计","_id":"cix1e5cee000bnvou0eemddmd"},{"name":"ActiveMQ","parent":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cf8000pnvoumpgxlb3m"},{"name":"leetcode","parent":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cfd000tnvoulzyqrzz1"},{"name":"c++11","parent":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cfk000znvouiqqo6eqf"},{"name":"more effective c++","parent":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cg7001fnvou5pe0hmki"},{"name":"elasticsearch","parent":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgg001unvou0svurgaj"},{"name":"操作系统","_id":"cix1e5cgh001znvou2dpgdqky"},{"name":"redis官方文档","parent":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgk0025nvoufzfkjych"},{"name":"数据库连接池","parent":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgo002hnvoudzgxeiu8"},{"name":"算法导论","parent":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgq002nnvouub7xyrx5"},{"name":"编程珠玑","parent":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgt002tnvouu98xqtkm"},{"name":"网站地址","parent":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgv002xnvouhb26yybz"},{"name":"使用技巧","parent":"cix1e5cgh001znvou2dpgdqky","_id":"cix1e5ch4003envou2j0ocel2"}],"Data":[],"Page":[{"_content":"wBa8vF3BPm","source":"baidu_verify_wBa8vF3BPm.html","raw":"wBa8vF3BPm","date":"2016-11-18T04:28:54.537Z","updated":"2016-11-07T03:01:02.340Z","path":"baidu_verify_wBa8vF3BPm.html","title":"","comments":1,"layout":"page","_id":"cix1e5c5f0000nvouxt7pso1e","content":"wBa8vF3BPm","excerpt":"","more":"wBa8vF3BPm"},{"title":"tags","date":"2016-11-04T07:28:25.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-11-04 15:28:25\ntype: tags\ncomments: false\n---\n","updated":"2016-11-04T13:06:07.147Z","path":"tags/index.html","layout":"page","_id":"cix1e5cdc0002nvoumol7j72t","content":"","excerpt":"","more":""},{"title":"categories","date":"2016-11-04T07:28:15.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-11-04 15:28:15\ntype: categories\ncomments: false\n---\n","updated":"2016-11-04T13:07:16.566Z","path":"categories/index.html","layout":"page","_id":"cix1e5cdl0004nvou0rhiduk2","content":"","excerpt":"","more":""},{"title":"guestbook","date":"2016-11-04T07:05:44.000Z","_content":"\n<div class=\"ds-recent-visitors\" data-num-items=\"28\"\n     data-avatar-size=\"42\" id=\"ds-recent-visitors\"/>\n","source":"guestbook/index.md","raw":"---\ntitle: guestbook\ndate: 2016-11-04 15:05:44\n---\n\n<div class=\"ds-recent-visitors\" data-num-items=\"28\"\n     data-avatar-size=\"42\" id=\"ds-recent-visitors\"/>\n","updated":"2016-11-04T10:10:59.026Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"cix1e5ce60008nvou8a7vwgzb","content":"<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\">\n</div>","excerpt":"","more":"<div class=\"ds-recent-visitors\" data-num-items=\"28\"\n     data-avatar-size=\"42\" id=\"ds-recent-visitors\"/>\n"}],"Post":[{"title":"ActiveMQ使用记录","comments":0,"date":"2016-12-15T05:14:16.000Z","_content":"　　今天简单的浏览了一些招聘需求，其中对消息队列所需的技术要求一般都是\"熟悉ActiveMQ\"。虽然之前做项目，使用过celery+rabbitmq的异步消息机制。这里还是为了给自己的简历贴一些金，来上手练一下ActiveMQ的使用。\n# 安装\n### 开发运行环境\n```bash\n> lennybai@lennybai~$ lsb_release -a\n> No LSB modules are available.\n> Distributor ID:\tUbuntu\n> Description:\tUbuntu 16.04.1 LTS\n> Release:\t16.04\n> Codename:\txenial\n```\n<!--more-->\n　　对于工具的使用，用心去研读一下官方文档还是很有必要的。在参考文献中我列出了官网的链接，感兴趣的朋友可以阅读一下。ActiveMQ的环境要求，在官方文档中指出为：JRE和JDK。当然我是个懒汉，在这里不太希望用源码去安装ActiveMQ。我是这么干的:\n1. 安装java\n> sudo add-apt-repository ppa:webupd8team/java  \n> sudo apt-get update  \n> sudo apt-get install oracle-java8-installer\n\n2. 安装ActiveMQ\n> [官网下载](http://activemq.apache.org/download.html)并解压，在bin目录下运行自己系统相同的activemq程序，执行./activemq start\n\n　　在web控制台打开[http://127.0.0.1:8161/admin/](http://127.0.0.1:8161/admin/)。初始用户名:admin 密码:admin。[activemq_install_dir]/data/activemq.log\"中可以查看运行日志。netstat -an | grep 61616可以查看端口运行情况。\n　　activemq我认为比较好的有三点:开源，漂亮控制台和没有繁琐的配置。\n\n# 试用\n\n\n***\n# 3 参考文献\n- [1]: [ActiveMQ Document](http://activemq.apache.org/version-5-getting-started.html#Version5GettingStarted-DocumentOrganization)\n","source":"_posts/ActiveMQ使用记录.md","raw":"---\ntitle: ActiveMQ使用记录\ncomments: false\ndate: 2016-12-15 13:14:16\ntags:\n  - 读书笔记\n  - ActiveMQ\ncategories:\n  - 读书笔记\n  - ActiveMQ\n---\n　　今天简单的浏览了一些招聘需求，其中对消息队列所需的技术要求一般都是\"熟悉ActiveMQ\"。虽然之前做项目，使用过celery+rabbitmq的异步消息机制。这里还是为了给自己的简历贴一些金，来上手练一下ActiveMQ的使用。\n# 安装\n### 开发运行环境\n```bash\n> lennybai@lennybai~$ lsb_release -a\n> No LSB modules are available.\n> Distributor ID:\tUbuntu\n> Description:\tUbuntu 16.04.1 LTS\n> Release:\t16.04\n> Codename:\txenial\n```\n<!--more-->\n　　对于工具的使用，用心去研读一下官方文档还是很有必要的。在参考文献中我列出了官网的链接，感兴趣的朋友可以阅读一下。ActiveMQ的环境要求，在官方文档中指出为：JRE和JDK。当然我是个懒汉，在这里不太希望用源码去安装ActiveMQ。我是这么干的:\n1. 安装java\n> sudo add-apt-repository ppa:webupd8team/java  \n> sudo apt-get update  \n> sudo apt-get install oracle-java8-installer\n\n2. 安装ActiveMQ\n> [官网下载](http://activemq.apache.org/download.html)并解压，在bin目录下运行自己系统相同的activemq程序，执行./activemq start\n\n　　在web控制台打开[http://127.0.0.1:8161/admin/](http://127.0.0.1:8161/admin/)。初始用户名:admin 密码:admin。[activemq_install_dir]/data/activemq.log\"中可以查看运行日志。netstat -an | grep 61616可以查看端口运行情况。\n　　activemq我认为比较好的有三点:开源，漂亮控制台和没有繁琐的配置。\n\n# 试用\n\n\n***\n# 3 参考文献\n- [1]: [ActiveMQ Document](http://activemq.apache.org/version-5-getting-started.html#Version5GettingStarted-DocumentOrganization)\n","slug":"ActiveMQ使用记录","published":1,"updated":"2016-12-20T02:50:58.003Z","layout":"post","photos":[],"link":"","_id":"cix1e5cd30001nvou2ijam72b","content":"<p>　　今天简单的浏览了一些招聘需求，其中对消息队列所需的技术要求一般都是”熟悉ActiveMQ”。虽然之前做项目，使用过celery+rabbitmq的异步消息机制。这里还是为了给自己的简历贴一些金，来上手练一下ActiveMQ的使用。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h3 id=\"开发运行环境\"><a href=\"#开发运行环境\" class=\"headerlink\" title=\"开发运行环境\"></a>开发运行环境</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; lennybai@lennybai~$ lsb_release <span class=\"_\">-a</span></div><div class=\"line\">&gt; No LSB modules are available.</div><div class=\"line\">&gt; Distributor ID:\tUbuntu</div><div class=\"line\">&gt; Description:\tUbuntu 16.04.1 LTS</div><div class=\"line\">&gt; Release:\t16.04</div><div class=\"line\">&gt; Codename:\txenial</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>　　对于工具的使用，用心去研读一下官方文档还是很有必要的。在参考文献中我列出了官网的链接，感兴趣的朋友可以阅读一下。ActiveMQ的环境要求，在官方文档中指出为：JRE和JDK。当然我是个懒汉，在这里不太希望用源码去安装ActiveMQ。我是这么干的:</p>\n<ol>\n<li><p>安装java</p>\n<blockquote>\n<p>sudo add-apt-repository ppa:webupd8team/java<br>sudo apt-get update<br>sudo apt-get install oracle-java8-installer</p>\n</blockquote>\n</li>\n<li><p>安装ActiveMQ</p>\n<blockquote>\n<p><a href=\"http://activemq.apache.org/download.html\" target=\"_blank\" rel=\"external\">官网下载</a>并解压，在bin目录下运行自己系统相同的activemq程序，执行./activemq start</p>\n</blockquote>\n</li>\n</ol>\n<p>　　在web控制台打开<a href=\"http://127.0.0.1:8161/admin/\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8161/admin/</a>。初始用户名:admin 密码:admin。[activemq_install_dir]/data/activemq.log”中可以查看运行日志。netstat -an | grep 61616可以查看端口运行情况。<br>　　activemq我认为比较好的有三点:开源，漂亮控制台和没有繁琐的配置。</p>\n<h1 id=\"试用\"><a href=\"#试用\" class=\"headerlink\" title=\"试用\"></a>试用</h1><hr>\n<h1 id=\"3-参考文献\"><a href=\"#3-参考文献\" class=\"headerlink\" title=\"3 参考文献\"></a>3 参考文献</h1><ul>\n<li>[1]: <a href=\"http://activemq.apache.org/version-5-getting-started.html#Version5GettingStarted-DocumentOrganization\" target=\"_blank\" rel=\"external\">ActiveMQ Document</a></li>\n</ul>\n","excerpt":"<p>　　今天简单的浏览了一些招聘需求，其中对消息队列所需的技术要求一般都是”熟悉ActiveMQ”。虽然之前做项目，使用过celery+rabbitmq的异步消息机制。这里还是为了给自己的简历贴一些金，来上手练一下ActiveMQ的使用。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h3 id=\"开发运行环境\"><a href=\"#开发运行环境\" class=\"headerlink\" title=\"开发运行环境\"></a>开发运行环境</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; lennybai@lennybai~$ lsb_release <span class=\"_\">-a</span></div><div class=\"line\">&gt; No LSB modules are available.</div><div class=\"line\">&gt; Distributor ID:\tUbuntu</div><div class=\"line\">&gt; Description:\tUbuntu 16.04.1 LTS</div><div class=\"line\">&gt; Release:\t16.04</div><div class=\"line\">&gt; Codename:\txenial</div></pre></td></tr></table></figure>","more":"<p>　　对于工具的使用，用心去研读一下官方文档还是很有必要的。在参考文献中我列出了官网的链接，感兴趣的朋友可以阅读一下。ActiveMQ的环境要求，在官方文档中指出为：JRE和JDK。当然我是个懒汉，在这里不太希望用源码去安装ActiveMQ。我是这么干的:</p>\n<ol>\n<li><p>安装java</p>\n<blockquote>\n<p>sudo add-apt-repository ppa:webupd8team/java<br>sudo apt-get update<br>sudo apt-get install oracle-java8-installer</p>\n</blockquote>\n</li>\n<li><p>安装ActiveMQ</p>\n<blockquote>\n<p><a href=\"http://activemq.apache.org/download.html\">官网下载</a>并解压，在bin目录下运行自己系统相同的activemq程序，执行./activemq start</p>\n</blockquote>\n</li>\n</ol>\n<p>　　在web控制台打开<a href=\"http://127.0.0.1:8161/admin/\">http://127.0.0.1:8161/admin/</a>。初始用户名:admin 密码:admin。[activemq_install_dir]/data/activemq.log”中可以查看运行日志。netstat -an | grep 61616可以查看端口运行情况。<br>　　activemq我认为比较好的有三点:开源，漂亮控制台和没有繁琐的配置。</p>\n<h1 id=\"试用\"><a href=\"#试用\" class=\"headerlink\" title=\"试用\"></a>试用</h1><hr>\n<h1 id=\"3-参考文献\"><a href=\"#3-参考文献\" class=\"headerlink\" title=\"3 参考文献\"></a>3 参考文献</h1><ul>\n<li>[1]: <a href=\"http://activemq.apache.org/version-5-getting-started.html#Version5GettingStarted-DocumentOrganization\">ActiveMQ Document</a></li>\n</ul>"},{"title":"c++11条件变量","comments":0,"date":"2016-12-20T08:11:20.000Z","_content":"\n　　写了个条件变量的小程序。感觉还是挺方便的。\n<!--more-->\n```cpp\n#include <iostream>\n#include <map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n\nusing namespace std;\n\nmutex m_mtxCv;\n\ncondition_variable m_Cv;\nvoid print()\n{\n                while(true)\n                {\n                                unique_lock<mutex> lk(m_mtxCv);\n                                cout << \" 1 \" << endl;\n                                m_Cv.wait_for(lk,chrono::milliseconds(5000));\n                                cout << \" 2 \" << endl;\n\t\t            }\n}\n\nint main()\n{\n                thread t(print);\n\t              while(true)\n                {        \n\t\t                            cin.get();\n\t\t                            m_Cv.notify_one();\n\t              }\n\t\t            return 0;\n}\n```\n\n编译\n> c++ test.cc -std=c++11 -lpthread\n","source":"_posts/c-11条件变量.md","raw":"---\ntitle: c++11条件变量\ncomments: false\ndate: 2016-12-20 16:11:20\ntags:\n  - 程序设计\n  - c++11\n  - 条件变量\ncategories:\n  - 程序设计\n  - c++11\n---\n\n　　写了个条件变量的小程序。感觉还是挺方便的。\n<!--more-->\n```cpp\n#include <iostream>\n#include <map>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n\nusing namespace std;\n\nmutex m_mtxCv;\n\ncondition_variable m_Cv;\nvoid print()\n{\n                while(true)\n                {\n                                unique_lock<mutex> lk(m_mtxCv);\n                                cout << \" 1 \" << endl;\n                                m_Cv.wait_for(lk,chrono::milliseconds(5000));\n                                cout << \" 2 \" << endl;\n\t\t            }\n}\n\nint main()\n{\n                thread t(print);\n\t              while(true)\n                {        \n\t\t                            cin.get();\n\t\t                            m_Cv.notify_one();\n\t              }\n\t\t            return 0;\n}\n```\n\n编译\n> c++ test.cc -std=c++11 -lpthread\n","slug":"c-11条件变量","published":1,"updated":"2016-12-20T08:19:23.309Z","layout":"post","photos":[],"link":"","_id":"cix1e5cdi0003nvoudj7fwj5k","content":"<p>　　写了个条件变量的小程序。感觉还是挺方便的。<br><a id=\"more\"></a><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;condition_variable&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\">mutex m_mtxCv;</div><div class=\"line\"></div><div class=\"line\">condition_variable m_Cv;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</div><div class=\"line\">                &#123;</div><div class=\"line\">                                unique_lock&lt;mutex&gt; lk(m_mtxCv);</div><div class=\"line\">                                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" 1 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">                                m_Cv.wait_for(lk,chrono::milliseconds(<span class=\"number\">5000</span>));</div><div class=\"line\">                                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" 2 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t            &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">                <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(print)</span></span>;</div><div class=\"line\">\t              <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</div><div class=\"line\">                &#123;        </div><div class=\"line\">\t\t                            <span class=\"built_in\">cin</span>.get();</div><div class=\"line\">\t\t                            m_Cv.notify_one();</div><div class=\"line\">\t              &#125;</div><div class=\"line\">\t\t            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>编译</p>\n<blockquote>\n<p>c++ test.cc -std=c++11 -lpthread</p>\n</blockquote>\n","excerpt":"<p>　　写了个条件变量的小程序。感觉还是挺方便的。<br>","more":"<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;condition_variable&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\">mutex m_mtxCv;</div><div class=\"line\"></div><div class=\"line\">condition_variable m_Cv;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</div><div class=\"line\">                &#123;</div><div class=\"line\">                                unique_lock&lt;mutex&gt; lk(m_mtxCv);</div><div class=\"line\">                                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" 1 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">                                m_Cv.wait_for(lk,chrono::milliseconds(<span class=\"number\">5000</span>));</div><div class=\"line\">                                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" 2 \"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">\t\t            &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">                <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(print)</span></span>;</div><div class=\"line\">\t              <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)</div><div class=\"line\">                &#123;        </div><div class=\"line\">\t\t                            <span class=\"built_in\">cin</span>.get();</div><div class=\"line\">\t\t                            m_Cv.notify_one();</div><div class=\"line\">\t              &#125;</div><div class=\"line\">\t\t            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>编译</p>\n<blockquote>\n<p>c++ test.cc -std=c++11 -lpthread</p>\n</blockquote>"},{"title":"effective c++小记","comments":0,"date":"2016-12-02T08:51:35.000Z","_content":"\nmore effective c++\n","source":"_posts/effective-c-小记.md","raw":"---\ntitle: effective c++小记\ncomments: false\ndate: 2016-12-02 16:51:35\ntags:\n  - 读书笔记\n  - more effective c++\ncategories:\n  - 读书笔记\n  - more effective c++\n---\n\nmore effective c++\n","slug":"effective-c-小记","published":1,"updated":"2016-12-06T02:30:28.958Z","layout":"post","photos":[],"link":"","_id":"cix1e5cdu0007nvoujd9fk1ow","content":"<p>more effective c++</p>\n","excerpt":"","more":"<p>more effective c++</p>\n"},{"title":"elasticsearch上手练","comments":0,"date":"2016-12-02T08:50:07.000Z","_content":"\n# 概述\n　　elasticsearch现在在企业应用中很是火爆。快速日志检索，简单高校的分布式支持等等都是它的优势所在。ELK的组合使用也是经典的使用场景。\n<!--more-->\n\n# 参考\n　　elasticsearch的官方文档非常清晰，不论是对其原理的介绍，还有api的讲解。希望大家还是耐心阅读一番。除此之外，这里还有一个我看到的中文版本的连接，有作者的自己思考，也很不错。\n1. [elasticsearch官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\n2. [Mastering Elasticsearch(中文版)](http://udn.yyuap.com/doc/mastering-elasticsearch/index.html)\n\n# 我的实践\n　　[实践代码](https://github.com/geeklenny/elasticsearch-restful-javaee-spring-django-rabitmq)\n　　这里我提供了一个简单的elasticsearch的实现。主要是通过spring实现了一套restful的后台接口。后台使用elasticsearch进行持久化。同时，使用django提供了一套前端系统。实现比较粗糙，跪在理解和使用练习。\n","source":"_posts/elasticsearch上手练.md","raw":"---\ntitle: elasticsearch上手练\ncomments: false\ndate: 2016-12-02 16:50:07\ntags:\n  - 程序设计\n  - elasticsearch\ncategories:\n  - 程序设计\n  - elasticsearch\n---\n\n# 概述\n　　elasticsearch现在在企业应用中很是火爆。快速日志检索，简单高校的分布式支持等等都是它的优势所在。ELK的组合使用也是经典的使用场景。\n<!--more-->\n\n# 参考\n　　elasticsearch的官方文档非常清晰，不论是对其原理的介绍，还有api的讲解。希望大家还是耐心阅读一番。除此之外，这里还有一个我看到的中文版本的连接，有作者的自己思考，也很不错。\n1. [elasticsearch官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\n2. [Mastering Elasticsearch(中文版)](http://udn.yyuap.com/doc/mastering-elasticsearch/index.html)\n\n# 我的实践\n　　[实践代码](https://github.com/geeklenny/elasticsearch-restful-javaee-spring-django-rabitmq)\n　　这里我提供了一个简单的elasticsearch的实现。主要是通过spring实现了一套restful的后台接口。后台使用elasticsearch进行持久化。同时，使用django提供了一套前端系统。实现比较粗糙，跪在理解和使用练习。\n","slug":"elasticsearch上手练","published":1,"updated":"2016-12-20T03:03:11.121Z","layout":"post","photos":[],"link":"","_id":"cix1e5cea0009nvoupuynlv6h","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>　　elasticsearch现在在企业应用中很是火爆。快速日志检索，简单高校的分布式支持等等都是它的优势所在。ELK的组合使用也是经典的使用场景。<br><a id=\"more\"></a></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>　　elasticsearch的官方文档非常清晰，不论是对其原理的介绍，还有api的讲解。希望大家还是耐心阅读一番。除此之外，这里还有一个我看到的中文版本的连接，有作者的自己思考，也很不错。</p>\n<ol>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html\" target=\"_blank\" rel=\"external\">elasticsearch官方文档</a></li>\n<li><a href=\"http://udn.yyuap.com/doc/mastering-elasticsearch/index.html\" target=\"_blank\" rel=\"external\">Mastering Elasticsearch(中文版)</a></li>\n</ol>\n<h1 id=\"我的实践\"><a href=\"#我的实践\" class=\"headerlink\" title=\"我的实践\"></a>我的实践</h1><p>　　<a href=\"https://github.com/geeklenny/elasticsearch-restful-javaee-spring-django-rabitmq\" target=\"_blank\" rel=\"external\">实践代码</a><br>　　这里我提供了一个简单的elasticsearch的实现。主要是通过spring实现了一套restful的后台接口。后台使用elasticsearch进行持久化。同时，使用django提供了一套前端系统。实现比较粗糙，跪在理解和使用练习。</p>\n","excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>　　elasticsearch现在在企业应用中很是火爆。快速日志检索，简单高校的分布式支持等等都是它的优势所在。ELK的组合使用也是经典的使用场景。<br>","more":"</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p>　　elasticsearch的官方文档非常清晰，不论是对其原理的介绍，还有api的讲解。希望大家还是耐心阅读一番。除此之外，这里还有一个我看到的中文版本的连接，有作者的自己思考，也很不错。</p>\n<ol>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html\">elasticsearch官方文档</a></li>\n<li><a href=\"http://udn.yyuap.com/doc/mastering-elasticsearch/index.html\">Mastering Elasticsearch(中文版)</a></li>\n</ol>\n<h1 id=\"我的实践\"><a href=\"#我的实践\" class=\"headerlink\" title=\"我的实践\"></a>我的实践</h1><p>　　<a href=\"https://github.com/geeklenny/elasticsearch-restful-javaee-spring-django-rabitmq\">实践代码</a><br>　　这里我提供了一个简单的elasticsearch的实现。主要是通过spring实现了一套restful的后台接口。后台使用elasticsearch进行持久化。同时，使用django提供了一套前端系统。实现比较粗糙，跪在理解和使用练习。</p>"},{"title":"g++ template class","comments":0,"date":"2016-11-25T05:31:50.000Z","_content":"\ng++模板类，定义不能与声明分离。其原因是，模板类的实现不是在编译时，直接对cpp文件进行编译，而是在函数或者模板类在定义时，根据类型实现特定的源文件代码。其实，如果强行讲实现与声明分离也有方法，比如在头文件a.h中引用a.cpp，这样就可以做到定义与实现分离。但是这导致每次使用模板都会对源文件进行编译，造成编译时浪费。\n","source":"_posts/g-template-class.md","raw":"---\ntitle: g++ template class\ncomments: false\ndate: 2016-11-25 13:31:50\ntags:\ncategories:\n---\n\ng++模板类，定义不能与声明分离。其原因是，模板类的实现不是在编译时，直接对cpp文件进行编译，而是在函数或者模板类在定义时，根据类型实现特定的源文件代码。其实，如果强行讲实现与声明分离也有方法，比如在头文件a.h中引用a.cpp，这样就可以做到定义与实现分离。但是这导致每次使用模板都会对源文件进行编译，造成编译时浪费。\n","slug":"g-template-class","published":1,"updated":"2016-12-20T03:27:45.923Z","layout":"post","photos":[],"link":"","_id":"cix1e5ced000anvougp34beq4","content":"<p>g++模板类，定义不能与声明分离。其原因是，模板类的实现不是在编译时，直接对cpp文件进行编译，而是在函数或者模板类在定义时，根据类型实现特定的源文件代码。其实，如果强行讲实现与声明分离也有方法，比如在头文件a.h中引用a.cpp，这样就可以做到定义与实现分离。但是这导致每次使用模板都会对源文件进行编译，造成编译时浪费。</p>\n","excerpt":"","more":"<p>g++模板类，定义不能与声明分离。其原因是，模板类的实现不是在编译时，直接对cpp文件进行编译，而是在函数或者模板类在定义时，根据类型实现特定的源文件代码。其实，如果强行讲实现与声明分离也有方法，比如在头文件a.h中引用a.cpp，这样就可以做到定义与实现分离。但是这导致每次使用模板都会对源文件进行编译，造成编译时浪费。</p>\n"},{"title":"leetcode-AddTwoNum","comments":0,"date":"2016-12-12T09:18:20.000Z","_content":"\n\n### [AddTwoNum](https://leetcode.com/problems/add-two-numbers/)\nYou are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\n<!--more-->\n\n### example\n> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n> Output: 7 -> 0 -> 8\n\n### 思路\n　　思路不算复杂，就是按照我们正常的加法竖式计算的方式来完成此题就可以。需要注意的细节有两点:\n1. 进位值\n2. 判断list结尾\n\n　　关于进位值(程序中定义为extra变量)在本题中，如果是list最后两个数字相加的进位，往往会被忽略。第二点，两个list不一定是等长的，所以在遍历的过程中，需要对list结尾进行判断，防止运行时空指针错误。注意这两点，可能就可以正确完成本题了。\n\n### coding\n```cpp\n#include <iostream>\n\nusing namespace std;\n\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\n\nclass Solution {\n  public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode result(0);\n        ListNode* tempResult = &result;\n        int l1Value, l2Value, extra;\n        l1Value = l2Value = extra = 0;\n        while(l1 != NULL || l2 != NULL || extra != 0)\n        {\n            l1Value = (l1!=NULL)?l1->val : 0;\n            l2Value = (l2!=NULL)?l2->val : 0;\n            tempResult->next = new ListNode((l1Value+l2Value+extra)%10);\n            extra = (l1Value+l2Value+extra) / 10;\n\n            l1 != NULL ? l1 = l1->next : l1 = NULL;\n            l2 != NULL ? l2 = l2->next : l2 = NULL;\n            tempResult = tempResult->next;\n        }\n        return result.next;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    ListNode* l1 = new ListNode(2);\n    l1->next = new ListNode(4);\n    l1->next->next = new ListNode(3);\n\n    ListNode* l2 = new ListNode(5);\n    l2->next = new ListNode(6);\n    l2->next->next = new ListNode(4);\n    //l2->next->next = new ListNode(7);\n\n    Solution s;\n    ListNode* result = s.addTwoNumbers(l1,l2);\n\n    while(result)\n    {\n        cout << result->val << endl;\n        result = result->next;\n    }\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","source":"_posts/leetcode-AddTwoNum.md","raw":"---\ntitle: leetcode-AddTwoNum\ncomments: false\ndate: 2016-12-12 17:18:20\ntags:\n  - 程序设计\n  - leetcode\ncategories:\n  - 程序设计\n  - leetcode\n---\n\n\n### [AddTwoNum](https://leetcode.com/problems/add-two-numbers/)\nYou are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\n\n<!--more-->\n\n### example\n> Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)\n> Output: 7 -> 0 -> 8\n\n### 思路\n　　思路不算复杂，就是按照我们正常的加法竖式计算的方式来完成此题就可以。需要注意的细节有两点:\n1. 进位值\n2. 判断list结尾\n\n　　关于进位值(程序中定义为extra变量)在本题中，如果是list最后两个数字相加的进位，往往会被忽略。第二点，两个list不一定是等长的，所以在遍历的过程中，需要对list结尾进行判断，防止运行时空指针错误。注意这两点，可能就可以正确完成本题了。\n\n### coding\n```cpp\n#include <iostream>\n\nusing namespace std;\n\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\n\nclass Solution {\n  public:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode result(0);\n        ListNode* tempResult = &result;\n        int l1Value, l2Value, extra;\n        l1Value = l2Value = extra = 0;\n        while(l1 != NULL || l2 != NULL || extra != 0)\n        {\n            l1Value = (l1!=NULL)?l1->val : 0;\n            l2Value = (l2!=NULL)?l2->val : 0;\n            tempResult->next = new ListNode((l1Value+l2Value+extra)%10);\n            extra = (l1Value+l2Value+extra) / 10;\n\n            l1 != NULL ? l1 = l1->next : l1 = NULL;\n            l2 != NULL ? l2 = l2->next : l2 = NULL;\n            tempResult = tempResult->next;\n        }\n        return result.next;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    ListNode* l1 = new ListNode(2);\n    l1->next = new ListNode(4);\n    l1->next->next = new ListNode(3);\n\n    ListNode* l2 = new ListNode(5);\n    l2->next = new ListNode(6);\n    l2->next->next = new ListNode(4);\n    //l2->next->next = new ListNode(7);\n\n    Solution s;\n    ListNode* result = s.addTwoNumbers(l1,l2);\n\n    while(result)\n    {\n        cout << result->val << endl;\n        result = result->next;\n    }\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","slug":"leetcode-AddTwoNum","published":1,"updated":"2016-12-12T10:31:41.966Z","layout":"post","photos":[],"link":"","_id":"cix1e5cef000dnvoud7n1cmar","content":"<h3 id=\"AddTwoNum\"><a href=\"#AddTwoNum\" class=\"headerlink\" title=\"AddTwoNum\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\" target=\"_blank\" rel=\"external\">AddTwoNum</a></h3><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>\n<a id=\"more\"></a>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　思路不算复杂，就是按照我们正常的加法竖式计算的方式来完成此题就可以。需要注意的细节有两点:</p>\n<ol>\n<li>进位值</li>\n<li>判断list结尾</li>\n</ol>\n<p>　　关于进位值(程序中定义为extra变量)在本题中，如果是list最后两个数字相加的进位，往往会被忽略。第二点，两个list不一定是等长的，所以在遍历的过程中，需要对list结尾进行判断，防止运行时空指针错误。注意这两点，可能就可以正确完成本题了。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> ListNode &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    ListNode *next;</div><div class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\">ListNode <span class=\"title\">result</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</div><div class=\"line\">        ListNode* tempResult = &amp;result;</div><div class=\"line\">        <span class=\"keyword\">int</span> l1Value, l2Value, extra;</div><div class=\"line\">        l1Value = l2Value = extra = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">NULL</span> || l2 != <span class=\"literal\">NULL</span> || extra != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            l1Value = (l1!=<span class=\"literal\">NULL</span>)?l1-&gt;val : <span class=\"number\">0</span>;</div><div class=\"line\">            l2Value = (l2!=<span class=\"literal\">NULL</span>)?l2-&gt;val : <span class=\"number\">0</span>;</div><div class=\"line\">            tempResult-&gt;next = <span class=\"keyword\">new</span> ListNode((l1Value+l2Value+extra)%<span class=\"number\">10</span>);</div><div class=\"line\">            extra = (l1Value+l2Value+extra) / <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\">            l1 != <span class=\"literal\">NULL</span> ? l1 = l1-&gt;next : l1 = <span class=\"literal\">NULL</span>;</div><div class=\"line\">            l2 != <span class=\"literal\">NULL</span> ? l2 = l2-&gt;next : l2 = <span class=\"literal\">NULL</span>;</div><div class=\"line\">            tempResult = tempResult-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    ListNode* l1 = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">2</span>);</div><div class=\"line\">    l1-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">4</span>);</div><div class=\"line\">    l1-&gt;next-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">    ListNode* l2 = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">5</span>);</div><div class=\"line\">    l2-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">6</span>);</div><div class=\"line\">    l2-&gt;next-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">4</span>);</div><div class=\"line\">    <span class=\"comment\">//l2-&gt;next-&gt;next = new ListNode(7);</span></div><div class=\"line\"></div><div class=\"line\">    Solution s;</div><div class=\"line\">    ListNode* result = s.addTwoNumbers(l1,l2);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(result)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; result-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        result = result-&gt;next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\" target=\"_blank\" rel=\"external\">github代码链接</a></p>\n","excerpt":"<h3 id=\"AddTwoNum\"><a href=\"#AddTwoNum\" class=\"headerlink\" title=\"AddTwoNum\"></a><a href=\"https://leetcode.com/problems/add-two-numbers/\">AddTwoNum</a></h3><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>","more":"<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　思路不算复杂，就是按照我们正常的加法竖式计算的方式来完成此题就可以。需要注意的细节有两点:</p>\n<ol>\n<li>进位值</li>\n<li>判断list结尾</li>\n</ol>\n<p>　　关于进位值(程序中定义为extra变量)在本题中，如果是list最后两个数字相加的进位，往往会被忽略。第二点，两个list不一定是等长的，所以在遍历的过程中，需要对list结尾进行判断，防止运行时空指针错误。注意这两点，可能就可以正确完成本题了。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> ListNode &#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> val;</div><div class=\"line\">    ListNode *next;</div><div class=\"line\">    ListNode(<span class=\"keyword\">int</span> x) : val(x), next(<span class=\"literal\">NULL</span>) &#123;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode* l1, ListNode* l2)</span> </span>&#123;</div><div class=\"line\">        <span class=\"function\">ListNode <span class=\"title\">result</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>;</div><div class=\"line\">        ListNode* tempResult = &amp;result;</div><div class=\"line\">        <span class=\"keyword\">int</span> l1Value, l2Value, extra;</div><div class=\"line\">        l1Value = l2Value = extra = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"literal\">NULL</span> || l2 != <span class=\"literal\">NULL</span> || extra != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            l1Value = (l1!=<span class=\"literal\">NULL</span>)?l1-&gt;val : <span class=\"number\">0</span>;</div><div class=\"line\">            l2Value = (l2!=<span class=\"literal\">NULL</span>)?l2-&gt;val : <span class=\"number\">0</span>;</div><div class=\"line\">            tempResult-&gt;next = <span class=\"keyword\">new</span> ListNode((l1Value+l2Value+extra)%<span class=\"number\">10</span>);</div><div class=\"line\">            extra = (l1Value+l2Value+extra) / <span class=\"number\">10</span>;</div><div class=\"line\"></div><div class=\"line\">            l1 != <span class=\"literal\">NULL</span> ? l1 = l1-&gt;next : l1 = <span class=\"literal\">NULL</span>;</div><div class=\"line\">            l2 != <span class=\"literal\">NULL</span> ? l2 = l2-&gt;next : l2 = <span class=\"literal\">NULL</span>;</div><div class=\"line\">            tempResult = tempResult-&gt;next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result.next;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    ListNode* l1 = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">2</span>);</div><div class=\"line\">    l1-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">4</span>);</div><div class=\"line\">    l1-&gt;next-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">    ListNode* l2 = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">5</span>);</div><div class=\"line\">    l2-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">6</span>);</div><div class=\"line\">    l2-&gt;next-&gt;next = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">4</span>);</div><div class=\"line\">    <span class=\"comment\">//l2-&gt;next-&gt;next = new ListNode(7);</span></div><div class=\"line\"></div><div class=\"line\">    Solution s;</div><div class=\"line\">    ListNode* result = s.addTwoNumbers(l1,l2);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(result)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; result-&gt;val &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        result = result-&gt;next;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\">github代码链接</a></p>"},{"title":"leetcode-LongestPalindromicSubstring","comments":0,"date":"2016-12-20T06:30:01.000Z","tegories":["程序设计","leetcode"],"_content":"\n\n### [LongestPalidrmicSubstring](https://leetcode.com/problems/longest-palindromic-substring/)\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n<!--more-->\n\n### example\n> Input: \"babad\"\n\n> Output: \"bab\"\n\n> Note: \"aba\" is also a valid answer.\n\n> Input: \"cbbd\"\n\n> Output: \"bb\"\n\n\n### 思路\n　　这个题我的答案并不巧妙，只能说是完成了任务。不过还是要说一下注意点:\n1. 对连续的相同字符的处理\n2. 如果a[p..q]是palidrmic串，如果a[p-1]=a[q+1]，那么a[p-1..q+1]也是palidrmic串\n\n　　在leetcode的discuss专栏里有很多出色的解答，希望大家移步讨论区去自行学习。\n\n### coding\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\n  public:\n\n    void GetInitSbutString(string s, int n, int &start, int& end)\n    {\n        while(start - 1 >= 0)\n        {\n            if( s.at(start - 1 ) == s.at(n) )\n                start = start -1;\n            else break;\n        }\n        while(end + 1 < s.length())\n        {\n            if( s.at(end+1) == s.at(n) )\n                end = end+1;\n            else break;\n        }\n    }\n\n    int getSubstring(string s, int& start)\n    {\n        int tempStart = start, tempEnd = start;\n\n        GetInitSbutString(s, start, tempStart, tempEnd);\n        while( (tempStart - 1 >= 0 ) && (tempEnd + 1 < s.length() ) )\n        {\n            if( s.at(tempStart-1) == s.at(tempEnd+1))\n            {\n                tempStart = tempStart - 1;\n                tempEnd = tempEnd + 1;\n            }\n            else break;\n        }\n\n        start = tempStart;\n        return tempEnd-tempStart +1;\n    }\n\n    string longestPalindrome(string s) {\n        int start = 0,length=0;\n        for(int i =0; i < s.length(); i++)\n        {\n            int tempStart = i;\n            int l = getSubstring(s,tempStart);\n            if (length <= l)\n            {\n                length = l;\n                start = tempStart;\n            }\n        }\n        return s.substr(start, length);\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    string temp = \"babad\";\n    cout << s.longestPalindrome(temp) << endl;\n    temp = \"cbbd\";\n    cout << s.longestPalindrome(temp) << endl;\n    temp = \"aba\";\n    cout << s.longestPalindrome(temp) << endl;\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","source":"_posts/leetcode-LongestPalindromicSubstring.md","raw":"---\ntitle: leetcode-LongestPalindromicSubstring\ncomments: false\ndate: 2016-12-20 14:30:01\ntags:\n  - 程序设计\n  - leetcode\ntegories:\n  - 程序设计\n  - leetcode\n---\n\n\n### [LongestPalidrmicSubstring](https://leetcode.com/problems/longest-palindromic-substring/)\nGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\n<!--more-->\n\n### example\n> Input: \"babad\"\n\n> Output: \"bab\"\n\n> Note: \"aba\" is also a valid answer.\n\n> Input: \"cbbd\"\n\n> Output: \"bb\"\n\n\n### 思路\n　　这个题我的答案并不巧妙，只能说是完成了任务。不过还是要说一下注意点:\n1. 对连续的相同字符的处理\n2. 如果a[p..q]是palidrmic串，如果a[p-1]=a[q+1]，那么a[p-1..q+1]也是palidrmic串\n\n　　在leetcode的discuss专栏里有很多出色的解答，希望大家移步讨论区去自行学习。\n\n### coding\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\n  public:\n\n    void GetInitSbutString(string s, int n, int &start, int& end)\n    {\n        while(start - 1 >= 0)\n        {\n            if( s.at(start - 1 ) == s.at(n) )\n                start = start -1;\n            else break;\n        }\n        while(end + 1 < s.length())\n        {\n            if( s.at(end+1) == s.at(n) )\n                end = end+1;\n            else break;\n        }\n    }\n\n    int getSubstring(string s, int& start)\n    {\n        int tempStart = start, tempEnd = start;\n\n        GetInitSbutString(s, start, tempStart, tempEnd);\n        while( (tempStart - 1 >= 0 ) && (tempEnd + 1 < s.length() ) )\n        {\n            if( s.at(tempStart-1) == s.at(tempEnd+1))\n            {\n                tempStart = tempStart - 1;\n                tempEnd = tempEnd + 1;\n            }\n            else break;\n        }\n\n        start = tempStart;\n        return tempEnd-tempStart +1;\n    }\n\n    string longestPalindrome(string s) {\n        int start = 0,length=0;\n        for(int i =0; i < s.length(); i++)\n        {\n            int tempStart = i;\n            int l = getSubstring(s,tempStart);\n            if (length <= l)\n            {\n                length = l;\n                start = tempStart;\n            }\n        }\n        return s.substr(start, length);\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    string temp = \"babad\";\n    cout << s.longestPalindrome(temp) << endl;\n    temp = \"cbbd\";\n    cout << s.longestPalindrome(temp) << endl;\n    temp = \"aba\";\n    cout << s.longestPalindrome(temp) << endl;\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","slug":"leetcode-LongestPalindromicSubstring","published":1,"updated":"2016-12-20T06:36:53.265Z","layout":"post","photos":[],"link":"","_id":"cix1e5cej000envou2c6s9jkx","content":"<h3 id=\"LongestPalidrmicSubstring\"><a href=\"#LongestPalidrmicSubstring\" class=\"headerlink\" title=\"LongestPalidrmicSubstring\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\" target=\"_blank\" rel=\"external\">LongestPalidrmicSubstring</a></h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br><a id=\"more\"></a></p>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Input: “babad”</p>\n<p>Output: “bab”</p>\n<p>Note: “aba” is also a valid answer.</p>\n<p>Input: “cbbd”</p>\n<p>Output: “bb”</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　这个题我的答案并不巧妙，只能说是完成了任务。不过还是要说一下注意点:</p>\n<ol>\n<li>对连续的相同字符的处理</li>\n<li>如果a[p..q]是palidrmic串，如果a[p-1]=a[q+1]，那么a[p-1..q+1]也是palidrmic串</li>\n</ol>\n<p>　　在leetcode的discuss专栏里有很多出色的解答，希望大家移步讨论区去自行学习。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetInitSbutString</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> &amp;start, <span class=\"keyword\">int</span>&amp; end)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">while</span>(start - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( s.at(start - <span class=\"number\">1</span> ) == s.at(n) )</div><div class=\"line\">                start = start <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(end + <span class=\"number\">1</span> &lt; s.length())</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( s.at(end+<span class=\"number\">1</span>) == s.at(n) )</div><div class=\"line\">                end = end+<span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span>&amp; start)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> tempStart = start, tempEnd = start;</div><div class=\"line\"></div><div class=\"line\">        GetInitSbutString(s, start, tempStart, tempEnd);</div><div class=\"line\">        <span class=\"keyword\">while</span>( (tempStart - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> ) &amp;&amp; (tempEnd + <span class=\"number\">1</span> &lt; s.length() ) )</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( s.at(tempStart<span class=\"number\">-1</span>) == s.at(tempEnd+<span class=\"number\">1</span>))</div><div class=\"line\">            &#123;</div><div class=\"line\">                tempStart = tempStart - <span class=\"number\">1</span>;</div><div class=\"line\">                tempEnd = tempEnd + <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        start = tempStart;</div><div class=\"line\">        <span class=\"keyword\">return</span> tempEnd-tempStart +<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>,length=<span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>; i &lt; s.length(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> tempStart = i;</div><div class=\"line\">            <span class=\"keyword\">int</span> l = getSubstring(s,tempStart);</div><div class=\"line\">            <span class=\"keyword\">if</span> (length &lt;= l)</div><div class=\"line\">            &#123;</div><div class=\"line\">                length = l;</div><div class=\"line\">                start = tempStart;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> s.substr(start, length);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">string</span> temp = <span class=\"string\">\"babad\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.longestPalindrome(temp) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    temp = <span class=\"string\">\"cbbd\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.longestPalindrome(temp) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    temp = <span class=\"string\">\"aba\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.longestPalindrome(temp) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\" target=\"_blank\" rel=\"external\">github代码链接</a></p>\n","excerpt":"<h3 id=\"LongestPalidrmicSubstring\"><a href=\"#LongestPalidrmicSubstring\" class=\"headerlink\" title=\"LongestPalidrmicSubstring\"></a><a href=\"https://leetcode.com/problems/longest-palindromic-substring/\">LongestPalidrmicSubstring</a></h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>","more":"</p>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Input: “babad”</p>\n<p>Output: “bab”</p>\n<p>Note: “aba” is also a valid answer.</p>\n<p>Input: “cbbd”</p>\n<p>Output: “bb”</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　这个题我的答案并不巧妙，只能说是完成了任务。不过还是要说一下注意点:</p>\n<ol>\n<li>对连续的相同字符的处理</li>\n<li>如果a[p..q]是palidrmic串，如果a[p-1]=a[q+1]，那么a[p-1..q+1]也是palidrmic串</li>\n</ol>\n<p>　　在leetcode的discuss专栏里有很多出色的解答，希望大家移步讨论区去自行学习。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GetInitSbutString</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> &amp;start, <span class=\"keyword\">int</span>&amp; end)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">while</span>(start - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( s.at(start - <span class=\"number\">1</span> ) == s.at(n) )</div><div class=\"line\">                start = start <span class=\"number\">-1</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span>(end + <span class=\"number\">1</span> &lt; s.length())</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( s.at(end+<span class=\"number\">1</span>) == s.at(n) )</div><div class=\"line\">                end = end+<span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s, <span class=\"keyword\">int</span>&amp; start)</span></div><div class=\"line\">    </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> tempStart = start, tempEnd = start;</div><div class=\"line\"></div><div class=\"line\">        GetInitSbutString(s, start, tempStart, tempEnd);</div><div class=\"line\">        <span class=\"keyword\">while</span>( (tempStart - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span> ) &amp;&amp; (tempEnd + <span class=\"number\">1</span> &lt; s.length() ) )</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( s.at(tempStart<span class=\"number\">-1</span>) == s.at(tempEnd+<span class=\"number\">1</span>))</div><div class=\"line\">            &#123;</div><div class=\"line\">                tempStart = tempStart - <span class=\"number\">1</span>;</div><div class=\"line\">                tempEnd = tempEnd + <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        start = tempStart;</div><div class=\"line\">        <span class=\"keyword\">return</span> tempEnd-tempStart +<span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> start = <span class=\"number\">0</span>,length=<span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>; i &lt; s.length(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> tempStart = i;</div><div class=\"line\">            <span class=\"keyword\">int</span> l = getSubstring(s,tempStart);</div><div class=\"line\">            <span class=\"keyword\">if</span> (length &lt;= l)</div><div class=\"line\">            &#123;</div><div class=\"line\">                length = l;</div><div class=\"line\">                start = tempStart;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> s.substr(start, length);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">string</span> temp = <span class=\"string\">\"babad\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.longestPalindrome(temp) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    temp = <span class=\"string\">\"cbbd\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.longestPalindrome(temp) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    temp = <span class=\"string\">\"aba\"</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.longestPalindrome(temp) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\">github代码链接</a></p>"},{"title":"leetcode-ReverseInteger","comments":0,"date":"2016-12-21T07:13:37.000Z","_content":"\n### [Reverse Integer](https://leetcode.com/problems/reverse-integer/)\nReverse digits of an integer.\n> Example1: x = 123, return 321\n>\n> Example2: x = -123, return -321\n\n<!--more-->\n\n### 思路\n　　本题其实思路很简单，我个人认为只是问题的考察点，应该是对人们对边界的认识。简单的翻转我们都能想到，通过按10取余来获取最后一位,通过除以10来进行移位。一定要记得考虑int的边界。\n\n### coding\n```cpp\n#include<iostream>\n#include \"limits.h\"\n\nusing namespace std;\n\nclass Solution {\n  public:\n    int reverse(int x) {\n        long long result = 0;\n        while(x != 0)\n        {\n            result = result * 10 + x % 10;\n            x = x/10;\n        }\n        return (result > INT_MAX || result < INT_MIN) ? 0 : result ;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    cout << s.reverse(123456) << endl;\n    cout << s.reverse(1000) << endl;\n    cout << s.reverse(1001) << endl;\n    cout << s.reverse(0) << endl;\n    cout << s.reverse(-123) << endl;\n    cout << s.reverse(-1234) << endl;\n    cout << s.reverse(1534236469) << endl;\n    cout << 9646324350+1 << endl;\n\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","source":"_posts/leetcode-ReverseInteger.md","raw":"---\ntitle: leetcode-ReverseInteger\ncomments: false\ndate: 2016-12-21 15:13:37\ntags:\n  - 程序设计\n  - leetcode\ncategories:\n  - 程序设计\n  - leetcode\n---\n\n### [Reverse Integer](https://leetcode.com/problems/reverse-integer/)\nReverse digits of an integer.\n> Example1: x = 123, return 321\n>\n> Example2: x = -123, return -321\n\n<!--more-->\n\n### 思路\n　　本题其实思路很简单，我个人认为只是问题的考察点，应该是对人们对边界的认识。简单的翻转我们都能想到，通过按10取余来获取最后一位,通过除以10来进行移位。一定要记得考虑int的边界。\n\n### coding\n```cpp\n#include<iostream>\n#include \"limits.h\"\n\nusing namespace std;\n\nclass Solution {\n  public:\n    int reverse(int x) {\n        long long result = 0;\n        while(x != 0)\n        {\n            result = result * 10 + x % 10;\n            x = x/10;\n        }\n        return (result > INT_MAX || result < INT_MIN) ? 0 : result ;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    cout << s.reverse(123456) << endl;\n    cout << s.reverse(1000) << endl;\n    cout << s.reverse(1001) << endl;\n    cout << s.reverse(0) << endl;\n    cout << s.reverse(-123) << endl;\n    cout << s.reverse(-1234) << endl;\n    cout << s.reverse(1534236469) << endl;\n    cout << 9646324350+1 << endl;\n\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","slug":"leetcode-ReverseInteger","published":1,"updated":"2016-12-21T07:25:27.377Z","layout":"post","photos":[],"link":"","_id":"cix1e5cep000hnvou2rad3s27","content":"<h3 id=\"Reverse-Integer\"><a href=\"#Reverse-Integer\" class=\"headerlink\" title=\"Reverse Integer\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\" target=\"_blank\" rel=\"external\">Reverse Integer</a></h3><p>Reverse digits of an integer.</p>\n<blockquote>\n<p>Example1: x = 123, return 321</p>\n<p>Example2: x = -123, return -321</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　本题其实思路很简单，我个人认为只是问题的考察点，应该是对人们对边界的认识。简单的翻转我们都能想到，通过按10取余来获取最后一位,通过除以10来进行移位。一定要记得考虑int的边界。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"limits.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(x != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            result = result * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</div><div class=\"line\">            x = x/<span class=\"number\">10</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> (result &gt; INT_MAX || result &lt; INT_MIN) ? <span class=\"number\">0</span> : result ;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">123456</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">1000</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">1001</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">0</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">-123</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">-1234</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">1534236469</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">9646324350</span>+<span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\" target=\"_blank\" rel=\"external\">github代码链接</a></p>\n","excerpt":"<h3 id=\"Reverse-Integer\"><a href=\"#Reverse-Integer\" class=\"headerlink\" title=\"Reverse Integer\"></a><a href=\"https://leetcode.com/problems/reverse-integer/\">Reverse Integer</a></h3><p>Reverse digits of an integer.</p>\n<blockquote>\n<p>Example1: x = 123, return 321</p>\n<p>Example2: x = -123, return -321</p>\n</blockquote>","more":"<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　本题其实思路很简单，我个人认为只是问题的考察点，应该是对人们对边界的认识。简单的翻转我们都能想到，通过按10取余来获取最后一位,通过除以10来进行移位。一定要记得考虑int的边界。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"limits.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">reverse</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">while</span>(x != <span class=\"number\">0</span>)</div><div class=\"line\">        &#123;</div><div class=\"line\">            result = result * <span class=\"number\">10</span> + x % <span class=\"number\">10</span>;</div><div class=\"line\">            x = x/<span class=\"number\">10</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> (result &gt; INT_MAX || result &lt; INT_MIN) ? <span class=\"number\">0</span> : result ;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">123456</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">1000</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">1001</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">0</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">-123</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">-1234</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.reverse(<span class=\"number\">1534236469</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">9646324350</span>+<span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\">github代码链接</a></p>"},{"title":"leetcode-MedianOfTwoSortedArrays","comments":0,"date":"2016-12-19T03:04:34.000Z","_content":"\n### [MedianOfTwoSortedArrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\n<!--more-->\n\n### example\n> nums1 = [1, 3]\n> nums2 = [2]\n>\n> The median is 2.0\n\n> nums1 = [1, 2]\nnums2 = [3, 4]\n\n> The median is (2 + 3)/2 = 2.5\n\n\n### 思路\n　　本体对时间复杂度有要求。当我看到这个题目的时候，有两点引起我的注意，第一个就是两个数组都是有序的，第二个就是时间复杂度为log(n)。这是我想到了归并排序。就这样我按照归并排序的思路完成了本题。\n\n部分细节：\n1. 中位数并不总是一个。\n2. 遍历数组不需要全部遍历。\n3. 注意归并排序的代码实现。\n\n### coding\n```cpp\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\nclass Solution {\n  public:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int size = nums1.size()+nums2.size();\n        int mid1 = size/2;\n        int mid2 = mid1 - (size%2==0?1:0);\n        int temp, mid1num=0,mid2num=0,i=0,j=0;\n        nums1.push_back(INT_MAX);\n        nums2.push_back(INT_MAX);\n\n        for (int k = 0 ; k < size; k++)\n        {\n            temp = 0;\n            if( nums1[i] < nums2[j] )\n            {\n                temp = nums1[i];\n                i++;\n            }\n            else\n            {\n                temp = nums2[j];\n                j++;\n            }\n            if( k == mid2 )\n            {\n                mid2num = temp;\n            }\n            if( k == mid1 )\n            {\n                mid1num = temp;\n                break;\n            }\n        }\n        return (mid1num + mid2num) / 2.0;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    vector<int> nums1 = {1,3};\n    vector<int> nums2 = {2};\n    vector<int> nums3 = {1,2};\n    vector<int> nums4 = {3,4};\n\n    cout << s.findMedianSortedArrays(nums1, nums2) << endl;\n    cout << s.findMedianSortedArrays(nums3, nums4) << endl;\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","source":"_posts/leetcode-MedianOfTwoSortedArrays.md","raw":"---\ntitle: leetcode-MedianOfTwoSortedArrays\ncomments: false\ndate: 2016-12-19 11:04:34\ntags:\n  - 程序设计\n  - leetcode\ncategories:\n  - 程序设计\n  - leetcode\n---\n\n### [MedianOfTwoSortedArrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)\nThere are two sorted arrays nums1 and nums2 of size m and n respectively.\n\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\n\n<!--more-->\n\n### example\n> nums1 = [1, 3]\n> nums2 = [2]\n>\n> The median is 2.0\n\n> nums1 = [1, 2]\nnums2 = [3, 4]\n\n> The median is (2 + 3)/2 = 2.5\n\n\n### 思路\n　　本体对时间复杂度有要求。当我看到这个题目的时候，有两点引起我的注意，第一个就是两个数组都是有序的，第二个就是时间复杂度为log(n)。这是我想到了归并排序。就这样我按照归并排序的思路完成了本题。\n\n部分细节：\n1. 中位数并不总是一个。\n2. 遍历数组不需要全部遍历。\n3. 注意归并排序的代码实现。\n\n### coding\n```cpp\n#include <iostream>\n#include <vector>\n#include <limits.h>\nusing namespace std;\n\nclass Solution {\n  public:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int size = nums1.size()+nums2.size();\n        int mid1 = size/2;\n        int mid2 = mid1 - (size%2==0?1:0);\n        int temp, mid1num=0,mid2num=0,i=0,j=0;\n        nums1.push_back(INT_MAX);\n        nums2.push_back(INT_MAX);\n\n        for (int k = 0 ; k < size; k++)\n        {\n            temp = 0;\n            if( nums1[i] < nums2[j] )\n            {\n                temp = nums1[i];\n                i++;\n            }\n            else\n            {\n                temp = nums2[j];\n                j++;\n            }\n            if( k == mid2 )\n            {\n                mid2num = temp;\n            }\n            if( k == mid1 )\n            {\n                mid1num = temp;\n                break;\n            }\n        }\n        return (mid1num + mid2num) / 2.0;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    vector<int> nums1 = {1,3};\n    vector<int> nums2 = {2};\n    vector<int> nums3 = {1,2};\n    vector<int> nums4 = {3,4};\n\n    cout << s.findMedianSortedArrays(nums1, nums2) << endl;\n    cout << s.findMedianSortedArrays(nums3, nums4) << endl;\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","slug":"leetcode-MedianOfTwoSortedArrays","published":1,"updated":"2016-12-19T03:12:39.470Z","layout":"post","photos":[],"link":"","_id":"cix1e5cet000jnvoui7ges4n1","content":"<h3 id=\"MedianOfTwoSortedArrays\"><a href=\"#MedianOfTwoSortedArrays\" class=\"headerlink\" title=\"MedianOfTwoSortedArrays\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\" target=\"_blank\" rel=\"external\">MedianOfTwoSortedArrays</a></h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>\n<a id=\"more\"></a>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>nums1 = [1, 3]<br>nums2 = [2]</p>\n<p>The median is 2.0</p>\n<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>\n<p>The median is (2 + 3)/2 = 2.5</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　本体对时间复杂度有要求。当我看到这个题目的时候，有两点引起我的注意，第一个就是两个数组都是有序的，第二个就是时间复杂度为log(n)。这是我想到了归并排序。就这样我按照归并排序的思路完成了本题。</p>\n<p>部分细节：</p>\n<ol>\n<li>中位数并不总是一个。</li>\n<li>遍历数组不需要全部遍历。</li>\n<li>注意归并排序的代码实现。</li>\n</ol>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> size = nums1.size()+nums2.size();</div><div class=\"line\">        <span class=\"keyword\">int</span> mid1 = size/<span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> mid2 = mid1 - (size%<span class=\"number\">2</span>==<span class=\"number\">0</span>?<span class=\"number\">1</span>:<span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> temp, mid1num=<span class=\"number\">0</span>,mid2num=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;</div><div class=\"line\">        nums1.push_back(INT_MAX);</div><div class=\"line\">        nums2.push_back(INT_MAX);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k &lt; size; k++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            temp = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>( nums1[i] &lt; nums2[j] )</div><div class=\"line\">            &#123;</div><div class=\"line\">                temp = nums1[i];</div><div class=\"line\">                i++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                temp = nums2[j];</div><div class=\"line\">                j++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>( k == mid2 )</div><div class=\"line\">            &#123;</div><div class=\"line\">                mid2num = temp;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>( k == mid1 )</div><div class=\"line\">            &#123;</div><div class=\"line\">                mid1num = temp;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> (mid1num + mid2num) / <span class=\"number\">2.0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums2 = &#123;<span class=\"number\">2</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums3 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums4 = &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.findMedianSortedArrays(nums1, nums2) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.findMedianSortedArrays(nums3, nums4) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\" target=\"_blank\" rel=\"external\">github代码链接</a></p>\n","excerpt":"<h3 id=\"MedianOfTwoSortedArrays\"><a href=\"#MedianOfTwoSortedArrays\" class=\"headerlink\" title=\"MedianOfTwoSortedArrays\"></a><a href=\"https://leetcode.com/problems/median-of-two-sorted-arrays/\">MedianOfTwoSortedArrays</a></h3><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>\n<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>","more":"<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>nums1 = [1, 3]<br>nums2 = [2]</p>\n<p>The median is 2.0</p>\n<p>nums1 = [1, 2]<br>nums2 = [3, 4]</p>\n<p>The median is (2 + 3)/2 = 2.5</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　本体对时间复杂度有要求。当我看到这个题目的时候，有两点引起我的注意，第一个就是两个数组都是有序的，第二个就是时间复杂度为log(n)。这是我想到了归并排序。就这样我按照归并排序的思路完成了本题。</p>\n<p>部分细节：</p>\n<ol>\n<li>中位数并不总是一个。</li>\n<li>遍历数组不需要全部遍历。</li>\n<li>注意归并排序的代码实现。</li>\n</ol>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;limits.h&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums1, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums2)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> size = nums1.size()+nums2.size();</div><div class=\"line\">        <span class=\"keyword\">int</span> mid1 = size/<span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"keyword\">int</span> mid2 = mid1 - (size%<span class=\"number\">2</span>==<span class=\"number\">0</span>?<span class=\"number\">1</span>:<span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> temp, mid1num=<span class=\"number\">0</span>,mid2num=<span class=\"number\">0</span>,i=<span class=\"number\">0</span>,j=<span class=\"number\">0</span>;</div><div class=\"line\">        nums1.push_back(INT_MAX);</div><div class=\"line\">        nums2.push_back(INT_MAX);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span> ; k &lt; size; k++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            temp = <span class=\"number\">0</span>;</div><div class=\"line\">            <span class=\"keyword\">if</span>( nums1[i] &lt; nums2[j] )</div><div class=\"line\">            &#123;</div><div class=\"line\">                temp = nums1[i];</div><div class=\"line\">                i++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                temp = nums2[j];</div><div class=\"line\">                j++;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>( k == mid2 )</div><div class=\"line\">            &#123;</div><div class=\"line\">                mid2num = temp;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">if</span>( k == mid1 )</div><div class=\"line\">            &#123;</div><div class=\"line\">                mid1num = temp;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> (mid1num + mid2num) / <span class=\"number\">2.0</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums2 = &#123;<span class=\"number\">2</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums3 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; nums4 = &#123;<span class=\"number\">3</span>,<span class=\"number\">4</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.findMedianSortedArrays(nums1, nums2) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; s.findMedianSortedArrays(nums3, nums4) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\">github代码链接</a></p>"},{"title":"leetcode-two sum","comments":0,"date":"2016-12-09T07:56:03.000Z","_content":"\n### [twoSum](https://leetcode.com/problems/two-sum/)\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution.\n\n<!--more-->\n\n### example\n> Given nums = [2, 7, 11, 15], target = 9,\n\n> Because nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\n### 思路\n　　本题思路并不难。可以从第一个数开始遍历，与后面的所有剩余的数字进行加法运算，如果符合预期则返回。否则继续遍历。这里有一个很明显的问题就是增加了很多不必要的运算。算法时间复杂度较高。\n　　一个很巧妙的算法是通过map存储已经遍历过的数字。key存储其值，value存储其索引。通过对数字从头到尾遍历。计算目标值(target-当前值)，并到map中查找，如果存在则返回，若不存在，将当前值存储到map中继续遍历。这样只需遍历一边数组就可完成整个算法。\n\n### coding\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\n  public:\n    vector<int> twoSum(vector<int>& nums, int target)\n    {\n        unordered_map<int,int> record;\n        vector<int> result;\n        for( int i = 0; i < nums.size(); i++)\n        {\n            int numberToFind = target - nums[i];\n            if(record.find(numberToFind) != record.end())\n            {\n                result.push_back(record[numberToFind]);\n                result.push_back(i);\n                return result;\n            }\n            record[nums[i]]=i;\n        }\n        return result;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    vector<int> test = {2,7,11,15};\n    int target = 9;\n\n    for(int i : s.twoSum(test, target))\n        cout << i << endl;\n\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","source":"_posts/leetcode-twosum.md","raw":"---\ntitle: leetcode-two sum\ncomments: false\ndate: 2016-12-09 15:56:03\ntags:\n  - 程序设计\n  - leetcode\ncategories:\n  - 程序设计\n  - leetcode\n---\n\n### [twoSum](https://leetcode.com/problems/two-sum/)\nGiven an array of integers, return indices of the two numbers such that they add up to a specific target.\n\nYou may assume that each input would have exactly one solution.\n\n<!--more-->\n\n### example\n> Given nums = [2, 7, 11, 15], target = 9,\n\n> Because nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n\n### 思路\n　　本题思路并不难。可以从第一个数开始遍历，与后面的所有剩余的数字进行加法运算，如果符合预期则返回。否则继续遍历。这里有一个很明显的问题就是增加了很多不必要的运算。算法时间复杂度较高。\n　　一个很巧妙的算法是通过map存储已经遍历过的数字。key存储其值，value存储其索引。通过对数字从头到尾遍历。计算目标值(target-当前值)，并到map中查找，如果存在则返回，若不存在，将当前值存储到map中继续遍历。这样只需遍历一边数组就可完成整个算法。\n\n### coding\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\n  public:\n    vector<int> twoSum(vector<int>& nums, int target)\n    {\n        unordered_map<int,int> record;\n        vector<int> result;\n        for( int i = 0; i < nums.size(); i++)\n        {\n            int numberToFind = target - nums[i];\n            if(record.find(numberToFind) != record.end())\n            {\n                result.push_back(record[numberToFind]);\n                result.push_back(i);\n                return result;\n            }\n            record[nums[i]]=i;\n        }\n        return result;\n    }\n};\n\nint main(int argc, char *argv[])\n{\n    Solution s;\n    vector<int> test = {2,7,11,15};\n    int target = 9;\n\n    for(int i : s.twoSum(test, target))\n        cout << i << endl;\n\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","slug":"leetcode-twosum","published":1,"updated":"2016-12-12T09:19:30.138Z","layout":"post","photos":[],"link":"","_id":"cix1e5cey000nnvou4teqgv5k","content":"<h3 id=\"twoSum\"><a href=\"#twoSum\" class=\"headerlink\" title=\"twoSum\"></a><a href=\"https://leetcode.com/problems/two-sum/\" target=\"_blank\" rel=\"external\">twoSum</a></h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have exactly one solution.</p>\n<a id=\"more\"></a>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Given nums = [2, 7, 11, 15], target = 9,</p>\n<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　本题思路并不难。可以从第一个数开始遍历，与后面的所有剩余的数字进行加法运算，如果符合预期则返回。否则继续遍历。这里有一个很明显的问题就是增加了很多不必要的运算。算法时间复杂度较高。<br>　　一个很巧妙的算法是通过map存储已经遍历过的数字。key存储其值，value存储其索引。通过对数字从头到尾遍历。计算目标值(target-当前值)，并到map中查找，如果存在则返回，若不存在，将当前值存储到map中继续遍历。这样只需遍历一边数组就可完成整个算法。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unordered_map&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; record;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</div><div class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> numberToFind = target - nums[i];</div><div class=\"line\">            <span class=\"keyword\">if</span>(record.find(numberToFind) != record.end())</div><div class=\"line\">            &#123;</div><div class=\"line\">                result.push_back(record[numberToFind]);</div><div class=\"line\">                result.push_back(i);</div><div class=\"line\">                <span class=\"keyword\">return</span> result;</div><div class=\"line\">            &#125;</div><div class=\"line\">            record[nums[i]]=i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; test = &#123;<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> target = <span class=\"number\">9</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : s.twoSum(test, target))</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\" target=\"_blank\" rel=\"external\">github代码链接</a></p>\n","excerpt":"<h3 id=\"twoSum\"><a href=\"#twoSum\" class=\"headerlink\" title=\"twoSum\"></a><a href=\"https://leetcode.com/problems/two-sum/\">twoSum</a></h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have exactly one solution.</p>","more":"<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Given nums = [2, 7, 11, 15], target = 9,</p>\n<p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　本题思路并不难。可以从第一个数开始遍历，与后面的所有剩余的数字进行加法运算，如果符合预期则返回。否则继续遍历。这里有一个很明显的问题就是增加了很多不必要的运算。算法时间复杂度较高。<br>　　一个很巧妙的算法是通过map存储已经遍历过的数字。key存储其值，value存储其索引。通过对数字从头到尾遍历。计算目标值(target-当前值)，并到map中查找，如果存在则返回，若不存在，将当前值存储到map中继续遍历。这样只需遍历一边数组就可完成整个算法。</p>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unordered_map&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; twoSum(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>&gt; record;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</div><div class=\"line\">        <span class=\"keyword\">for</span>( <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.size(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> numberToFind = target - nums[i];</div><div class=\"line\">            <span class=\"keyword\">if</span>(record.find(numberToFind) != record.end())</div><div class=\"line\">            &#123;</div><div class=\"line\">                result.push_back(record[numberToFind]);</div><div class=\"line\">                result.push_back(i);</div><div class=\"line\">                <span class=\"keyword\">return</span> result;</div><div class=\"line\">            &#125;</div><div class=\"line\">            record[nums[i]]=i;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> result;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    Solution s;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; test = &#123;<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> target = <span class=\"number\">9</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i : s.twoSum(test, target))</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\">github代码链接</a></p>"},{"title":"linux 小技巧","comments":0,"date":"2016-11-22T01:27:34.000Z","_content":"\n##　命令行对错误信息的处理\n　　在使用控制台的时候，往往在得到正确结果的同时，也会跟随者一些并不重要的错误信息，比如:\n\n![find mysql](http://ogelzbmrh.bkt.clouddn.com/findmysql.png)\n\n　　我们发现，当我们使用find命令去搜索mysql相关的内容的时候，除了我们想要的路径信息外，还有很多不必要的\"permission denied\"错误信息。这时候我们就可以通过将错误重定向到/dev/null来解决这个问题:\n```bash\nfind / -name mysql 2>/dev/null\n```\n","source":"_posts/linux-小技巧.md","raw":"---\ntitle: linux 小技巧\ncomments: false\ndate: 2016-11-22 09:27:34\ntags:\n  - linux\n  - 系统相关\ncategories:\n  - 操作系统\n  - 使用技巧\n---\n\n##　命令行对错误信息的处理\n　　在使用控制台的时候，往往在得到正确结果的同时，也会跟随者一些并不重要的错误信息，比如:\n\n![find mysql](http://ogelzbmrh.bkt.clouddn.com/findmysql.png)\n\n　　我们发现，当我们使用find命令去搜索mysql相关的内容的时候，除了我们想要的路径信息外，还有很多不必要的\"permission denied\"错误信息。这时候我们就可以通过将错误重定向到/dev/null来解决这个问题:\n```bash\nfind / -name mysql 2>/dev/null\n```\n","slug":"linux-小技巧","published":1,"updated":"2016-11-22T09:51:22.241Z","layout":"post","photos":[],"link":"","_id":"cix1e5cf4000onvounasrg49a","content":"<p>##　命令行对错误信息的处理<br>　　在使用控制台的时候，往往在得到正确结果的同时，也会跟随者一些并不重要的错误信息，比如:</p>\n<p><img src=\"http://ogelzbmrh.bkt.clouddn.com/findmysql.png\" alt=\"find mysql\"></p>\n<p>　　我们发现，当我们使用find命令去搜索mysql相关的内容的时候，除了我们想要的路径信息外，还有很多不必要的”permission denied”错误信息。这时候我们就可以通过将错误重定向到/dev/null来解决这个问题:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find / -name mysql 2&gt;/dev/null</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>##　命令行对错误信息的处理<br>　　在使用控制台的时候，往往在得到正确结果的同时，也会跟随者一些并不重要的错误信息，比如:</p>\n<p><img src=\"http://ogelzbmrh.bkt.clouddn.com/findmysql.png\" alt=\"find mysql\"></p>\n<p>　　我们发现，当我们使用find命令去搜索mysql相关的内容的时候，除了我们想要的路径信息外，还有很多不必要的”permission denied”错误信息。这时候我们就可以通过将错误重定向到/dev/null来解决这个问题:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">find / -name mysql 2&gt;/dev/null</div></pre></td></tr></table></figure></p>\n"},{"title":"redis学习之参考文档","comments":0,"date":"2016-12-02T02:21:38.000Z","_content":"\n# 1. 认识redis\n　　redis是一个key-value的存储系统。它支持网络、可基于内存亦可持久化的日志型、key-value数据库。value值可支持string,map,list,sets和sorted sets等类型。\n　　详细的说，redis相对其它key-value缓存产品(如memcached)有三个特点：\n* 支持持久化，可将内存中的数据保持到磁盘中，重启时可再次加载进行使用。\n* 不仅仅支持简单的key-value类型的数据，同事还提供list,set,zset,hash等数据结构的存储\n* 支持数据备份,master-slave模式\n\n<!--more-->\n\n  除此之外，redis还具备一下特点:\n* 极高的性能：　读110000次/s，　写的速度81000次/s\n* 丰富的数据类型\n* 原子性：所有操作都是原子性的。\n* 丰富的特性: 支持通知、key过期，publish/subscribe等\n\n# 2.使用redis\n　　对于一个工具，我们更关心的是如何使用。这里我从官方的文档中摘录出一些我自己比较感性去的部分罗列与此。和大家分享。\n## 2.1　配置Redis\n　　如何正确的使用配置文件，有利于我们更好的使用redis。这里我们认识一下常用命令。我安装了redis-cli，这里直接使用。\n```bash\nlennybai@lennybai:~$ redis-cli\n127.0.0.1:6379> CONFIG GET loglevel\n1) \"loglevel\"\n2) \"notice\"\n127.0.0.1:6379> config get *\n  1) \"dbfilename\"\n  2) \"dump.rdb\"\n  3) \"requirepass\"\n  4) \"\"\n  5) \"masterauth\"\n  6) \"\"\n  7) \"unixsocket\"\n  8) \"\"\n  9) \"logfile\"\n 10) \"/var/log/redis/redis-server.log\"\n 11) \"pidfile\"\n..........后面省略\n```\n　　我们可以通过config　get key获取配置文件中某项配置的值。并可以通过config set config_string_name new_config_value来更新其值。\n　　下面对一些常用的配置项进行说明：\n\n\n命令  |　说明  \n--|--\ndaemonize  |  是否设为守护进程\npidfile  | 设置守护进程pid存储文件的位置\nport | 指定redis端口(默认6379)\ndatabases | 设置redis内置数据库的数量。通过select切换\nsave | 指定同步到文件的规则\nmaxclient | 最大客户连接数，0为不设限制\nmaxmemory | 最大分配内存\n\n对于命令还有很多，大家可以在需要时自行查看。\n\n## 2.2　redis数据类型\n　　数据类型对于redis相对其他缓存产品而言，其丰富的数据格式是它的一大特色。这里做一下简单的介绍。\n\n### string字符串类型\n\n　　string类型是最基本的类型，它和memcached一样的类型.一个key对应一个value。redis中，string是二进制安全的，也就是说它可以存储任何数据(如图片或者序列化的对象)。一个键的最大存储为512MB.\n```bash\nredis 127.0.0.1:6379> SET name \"redis.net.cn\"\nOK\nredis 127.0.0.1:6379> GET name\n\"redis.net.cn\"\n```\n\n### hash（哈希)\nRedis hash是一个键值组合，它是一个string类型的field和value的映射表。特别适合存储对象。\n```bash\nredis 127.0.0.1:6379> HMSET user:1 username redis.net.cn password redis.net.cn points 200\nOK\nredis 127.0.0.1:6379> HGETALL user:1\n1) \"username\"\n2) \"redis.net.cn\"\n3) \"password\"\n4) \"redis.net.cn\"\n5) \"points\"\n6) \"200\"\n```\n每个 hash 可以存储 232 - 1 键值对（40多亿）。\n\n### list(列表)\n　　redis　list列表是简单的string类型列表。可以添加一个元素在列表的头部或者尾部。\n```bash\nredis 127.0.0.1:6379> lpush redis.net.cn redis\n(integer) 1\nredis 127.0.0.1:6379> lpush redis.net.cn mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush redis.net.cn rabitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange redis.net.cn 0 10\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\nredis 127.0.0.1:6379>\n```\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n\n### set(集合)\n　　Redis的set是string类型的无序集合。它是通过hash表实现的。增添和查找的复杂度为O(1).\n\n> sadd key member\n\n实例\n\n```bash\nredis 127.0.0.1:6379> sadd redis.net.cn redis\n(integer) 1\nredis 127.0.0.1:6379> sadd redis.net.cn mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd redis.net.cn rabitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd redis.net.cn rabitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers redis.net.cn\n\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\n```\n### zset（有序集合)\n　　zset是一个有序的string集合，且不允许成员重复。每个成员会关联一个double类型的分数。通过分数进行排序。成员唯一，但是分数可以重复。\n> zadd key score member\n\n实例\n\n```bash\nredis 127.0.0.1:6379> zadd redis.net.cn 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd redis.net.cn 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd redis.net.cn 0 rabitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd redis.net.cn 0 rabitmq\n(integer) 0\nredis 127.0.0.1:6379> ZRANGEBYSCORE redis.net.cn 0 1000\n\n1) \"redis\"\n2) \"mongodb\"\n3) \"rabitmq\"\n```\n\n## 2.3 Redis命令\n  通过介绍redis的命令，了解redis的使用\n### PING\n　　redis可以通过ping命令检测redis的运行情况。若正常运行，则返回pung\n```bash\nredis 127.0.0.1:6379> PING\n\nPONG\n```\n\n### key相关命令\n命令　|　说明\n-- | --\nSet key | 插入一个key-value\ndel key | 删除一个key-value.正确返回１，错误返回０\ndump key | 序列化key。正确返回序列化后字符串，错误返回nil\nexists key ｜　检测键值是否存在\nexpire key seconds | 设置键值过期时间，时间到了自动删除\nmove key db ｜　将当前数据库的key移动到其他数据库\npersist key | 移除过期时间，永久保存\nrename key new key | 重命名key\ntype key | 返回key的类型\n\n### publish\\subscribe命令\n　　pub\\sub是一个消息通信模式。通过subscribe订阅消息，然后通过publish发送消息。\n```bash\n#订阅者\nredis 127.0.0.1:6379> SUBSCRIBE redisChat\n\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"redisChat\"\n3) (integer) 1\n```\n\n```bash\n#发送者\nredis 127.0.0.1:6379> PUBLISH redisChat \"Redis is a great caching technique\"\n\n(integer) 1\n\nredis 127.0.0.1:6379> PUBLISH redisChat \"Learn redis by w3cschool.cc\"\n\n(integer) 1\n\n# 订阅者的客户端会显示如下消息\n1) \"message\"\n2) \"redisChat\"\n3) \"Redis is a great caching technique\"\n1) \"message\"\n2) \"redisChat\"\n3) \"Learn redis by w3cschool.cc\"\n```\n　　通过unsubscribe退订频道。\n\n### 事务\n　　Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n\n* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n\n\n一个事务从开始到执行会经历以下三个阶段：\n* 开始事务。\n* 命令入队。\n* 执行事务。\n\n```bash\nredis 127.0.0.1:6379> MULTI\nOK\n\nredis 127.0.0.1:6379> SET book-name \"Mastering C++ in 21 days\"\nQUEUED\n\nredis 127.0.0.1:6379> GET book-name\nQUEUED\n\nredis 127.0.0.1:6379> SADD tag \"C++\" \"Programming\" \"Mastering Series\"\nQUEUED\n\nredis 127.0.0.1:6379> SMEMBERS tag\nQUEUED\n\nredis 127.0.0.1:6379> EXEC\n1) OK\n2) \"Mastering C++ in 21 days\"\n3) (integer) 3\n4) 1) \"Mastering Series\"\n   2) \"C++\"\n   3) \"Programming\"\n```\n\n  discard取消事务执行。\n\n### INFO　\n查看当前redis所有信息\n\n### 脚本支持\n　 redis内置lua解析器\n\n## 2.4 Redis为什么不能取代关系型数据库\n1. 复杂的数据结构不好维护\n2. 存储于内存虽然访问速度较快，但是关系体现不出来。\n3. 存储成本高\n\n# 3 参考文献\n\n- [1]: [redis官方文档](http://www.redis.net.cn/tutorial/3501.html)\n- [2]: [redis为什么不能取代关系数据库](https://www.teakki.com/p/57dbd374d7d770e81877c75a)\n","source":"_posts/redis学习之参考文档.md","raw":"---\ntitle: redis学习之参考文档\ncomments: false\ndate: 2016-12-02 10:21:38\ntags:\n  - redis\ncategories:\n  - 读书笔记\n  - redis官方文档\n---\n\n# 1. 认识redis\n　　redis是一个key-value的存储系统。它支持网络、可基于内存亦可持久化的日志型、key-value数据库。value值可支持string,map,list,sets和sorted sets等类型。\n　　详细的说，redis相对其它key-value缓存产品(如memcached)有三个特点：\n* 支持持久化，可将内存中的数据保持到磁盘中，重启时可再次加载进行使用。\n* 不仅仅支持简单的key-value类型的数据，同事还提供list,set,zset,hash等数据结构的存储\n* 支持数据备份,master-slave模式\n\n<!--more-->\n\n  除此之外，redis还具备一下特点:\n* 极高的性能：　读110000次/s，　写的速度81000次/s\n* 丰富的数据类型\n* 原子性：所有操作都是原子性的。\n* 丰富的特性: 支持通知、key过期，publish/subscribe等\n\n# 2.使用redis\n　　对于一个工具，我们更关心的是如何使用。这里我从官方的文档中摘录出一些我自己比较感性去的部分罗列与此。和大家分享。\n## 2.1　配置Redis\n　　如何正确的使用配置文件，有利于我们更好的使用redis。这里我们认识一下常用命令。我安装了redis-cli，这里直接使用。\n```bash\nlennybai@lennybai:~$ redis-cli\n127.0.0.1:6379> CONFIG GET loglevel\n1) \"loglevel\"\n2) \"notice\"\n127.0.0.1:6379> config get *\n  1) \"dbfilename\"\n  2) \"dump.rdb\"\n  3) \"requirepass\"\n  4) \"\"\n  5) \"masterauth\"\n  6) \"\"\n  7) \"unixsocket\"\n  8) \"\"\n  9) \"logfile\"\n 10) \"/var/log/redis/redis-server.log\"\n 11) \"pidfile\"\n..........后面省略\n```\n　　我们可以通过config　get key获取配置文件中某项配置的值。并可以通过config set config_string_name new_config_value来更新其值。\n　　下面对一些常用的配置项进行说明：\n\n\n命令  |　说明  \n--|--\ndaemonize  |  是否设为守护进程\npidfile  | 设置守护进程pid存储文件的位置\nport | 指定redis端口(默认6379)\ndatabases | 设置redis内置数据库的数量。通过select切换\nsave | 指定同步到文件的规则\nmaxclient | 最大客户连接数，0为不设限制\nmaxmemory | 最大分配内存\n\n对于命令还有很多，大家可以在需要时自行查看。\n\n## 2.2　redis数据类型\n　　数据类型对于redis相对其他缓存产品而言，其丰富的数据格式是它的一大特色。这里做一下简单的介绍。\n\n### string字符串类型\n\n　　string类型是最基本的类型，它和memcached一样的类型.一个key对应一个value。redis中，string是二进制安全的，也就是说它可以存储任何数据(如图片或者序列化的对象)。一个键的最大存储为512MB.\n```bash\nredis 127.0.0.1:6379> SET name \"redis.net.cn\"\nOK\nredis 127.0.0.1:6379> GET name\n\"redis.net.cn\"\n```\n\n### hash（哈希)\nRedis hash是一个键值组合，它是一个string类型的field和value的映射表。特别适合存储对象。\n```bash\nredis 127.0.0.1:6379> HMSET user:1 username redis.net.cn password redis.net.cn points 200\nOK\nredis 127.0.0.1:6379> HGETALL user:1\n1) \"username\"\n2) \"redis.net.cn\"\n3) \"password\"\n4) \"redis.net.cn\"\n5) \"points\"\n6) \"200\"\n```\n每个 hash 可以存储 232 - 1 键值对（40多亿）。\n\n### list(列表)\n　　redis　list列表是简单的string类型列表。可以添加一个元素在列表的头部或者尾部。\n```bash\nredis 127.0.0.1:6379> lpush redis.net.cn redis\n(integer) 1\nredis 127.0.0.1:6379> lpush redis.net.cn mongodb\n(integer) 2\nredis 127.0.0.1:6379> lpush redis.net.cn rabitmq\n(integer) 3\nredis 127.0.0.1:6379> lrange redis.net.cn 0 10\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\nredis 127.0.0.1:6379>\n```\n列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。\n\n### set(集合)\n　　Redis的set是string类型的无序集合。它是通过hash表实现的。增添和查找的复杂度为O(1).\n\n> sadd key member\n\n实例\n\n```bash\nredis 127.0.0.1:6379> sadd redis.net.cn redis\n(integer) 1\nredis 127.0.0.1:6379> sadd redis.net.cn mongodb\n(integer) 1\nredis 127.0.0.1:6379> sadd redis.net.cn rabitmq\n(integer) 1\nredis 127.0.0.1:6379> sadd redis.net.cn rabitmq\n(integer) 0\nredis 127.0.0.1:6379> smembers redis.net.cn\n\n1) \"rabitmq\"\n2) \"mongodb\"\n3) \"redis\"\n```\n### zset（有序集合)\n　　zset是一个有序的string集合，且不允许成员重复。每个成员会关联一个double类型的分数。通过分数进行排序。成员唯一，但是分数可以重复。\n> zadd key score member\n\n实例\n\n```bash\nredis 127.0.0.1:6379> zadd redis.net.cn 0 redis\n(integer) 1\nredis 127.0.0.1:6379> zadd redis.net.cn 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379> zadd redis.net.cn 0 rabitmq\n(integer) 1\nredis 127.0.0.1:6379> zadd redis.net.cn 0 rabitmq\n(integer) 0\nredis 127.0.0.1:6379> ZRANGEBYSCORE redis.net.cn 0 1000\n\n1) \"redis\"\n2) \"mongodb\"\n3) \"rabitmq\"\n```\n\n## 2.3 Redis命令\n  通过介绍redis的命令，了解redis的使用\n### PING\n　　redis可以通过ping命令检测redis的运行情况。若正常运行，则返回pung\n```bash\nredis 127.0.0.1:6379> PING\n\nPONG\n```\n\n### key相关命令\n命令　|　说明\n-- | --\nSet key | 插入一个key-value\ndel key | 删除一个key-value.正确返回１，错误返回０\ndump key | 序列化key。正确返回序列化后字符串，错误返回nil\nexists key ｜　检测键值是否存在\nexpire key seconds | 设置键值过期时间，时间到了自动删除\nmove key db ｜　将当前数据库的key移动到其他数据库\npersist key | 移除过期时间，永久保存\nrename key new key | 重命名key\ntype key | 返回key的类型\n\n### publish\\subscribe命令\n　　pub\\sub是一个消息通信模式。通过subscribe订阅消息，然后通过publish发送消息。\n```bash\n#订阅者\nredis 127.0.0.1:6379> SUBSCRIBE redisChat\n\nReading messages... (press Ctrl-C to quit)\n1) \"subscribe\"\n2) \"redisChat\"\n3) (integer) 1\n```\n\n```bash\n#发送者\nredis 127.0.0.1:6379> PUBLISH redisChat \"Redis is a great caching technique\"\n\n(integer) 1\n\nredis 127.0.0.1:6379> PUBLISH redisChat \"Learn redis by w3cschool.cc\"\n\n(integer) 1\n\n# 订阅者的客户端会显示如下消息\n1) \"message\"\n2) \"redisChat\"\n3) \"Redis is a great caching technique\"\n1) \"message\"\n2) \"redisChat\"\n3) \"Learn redis by w3cschool.cc\"\n```\n　　通过unsubscribe退订频道。\n\n### 事务\n　　Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n\n* 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n* 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\n\n\n一个事务从开始到执行会经历以下三个阶段：\n* 开始事务。\n* 命令入队。\n* 执行事务。\n\n```bash\nredis 127.0.0.1:6379> MULTI\nOK\n\nredis 127.0.0.1:6379> SET book-name \"Mastering C++ in 21 days\"\nQUEUED\n\nredis 127.0.0.1:6379> GET book-name\nQUEUED\n\nredis 127.0.0.1:6379> SADD tag \"C++\" \"Programming\" \"Mastering Series\"\nQUEUED\n\nredis 127.0.0.1:6379> SMEMBERS tag\nQUEUED\n\nredis 127.0.0.1:6379> EXEC\n1) OK\n2) \"Mastering C++ in 21 days\"\n3) (integer) 3\n4) 1) \"Mastering Series\"\n   2) \"C++\"\n   3) \"Programming\"\n```\n\n  discard取消事务执行。\n\n### INFO　\n查看当前redis所有信息\n\n### 脚本支持\n　 redis内置lua解析器\n\n## 2.4 Redis为什么不能取代关系型数据库\n1. 复杂的数据结构不好维护\n2. 存储于内存虽然访问速度较快，但是关系体现不出来。\n3. 存储成本高\n\n# 3 参考文献\n\n- [1]: [redis官方文档](http://www.redis.net.cn/tutorial/3501.html)\n- [2]: [redis为什么不能取代关系数据库](https://www.teakki.com/p/57dbd374d7d770e81877c75a)\n","slug":"redis学习之参考文档","published":1,"updated":"2016-12-13T08:28:04.673Z","layout":"post","photos":[],"link":"","_id":"cix1e5cfb000rnvoupbvp11h0","content":"<h1 id=\"1-认识redis\"><a href=\"#1-认识redis\" class=\"headerlink\" title=\"1. 认识redis\"></a>1. 认识redis</h1><p>　　redis是一个key-value的存储系统。它支持网络、可基于内存亦可持久化的日志型、key-value数据库。value值可支持string,map,list,sets和sorted sets等类型。<br>　　详细的说，redis相对其它key-value缓存产品(如memcached)有三个特点：</p>\n<ul>\n<li>支持持久化，可将内存中的数据保持到磁盘中，重启时可再次加载进行使用。</li>\n<li>不仅仅支持简单的key-value类型的数据，同事还提供list,set,zset,hash等数据结构的存储</li>\n<li>支持数据备份,master-slave模式</li>\n</ul>\n<a id=\"more\"></a>\n<p>  除此之外，redis还具备一下特点:</p>\n<ul>\n<li>极高的性能：　读110000次/s，　写的速度81000次/s</li>\n<li>丰富的数据类型</li>\n<li>原子性：所有操作都是原子性的。</li>\n<li>丰富的特性: 支持通知、key过期，publish/subscribe等</li>\n</ul>\n<h1 id=\"2-使用redis\"><a href=\"#2-使用redis\" class=\"headerlink\" title=\"2.使用redis\"></a>2.使用redis</h1><p>　　对于一个工具，我们更关心的是如何使用。这里我从官方的文档中摘录出一些我自己比较感性去的部分罗列与此。和大家分享。</p>\n<h2 id=\"2-1-配置Redis\"><a href=\"#2-1-配置Redis\" class=\"headerlink\" title=\"2.1　配置Redis\"></a>2.1　配置Redis</h2><p>　　如何正确的使用配置文件，有利于我们更好的使用redis。这里我们认识一下常用命令。我安装了redis-cli，这里直接使用。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">lennybai@lennybai:~$ redis-cli</div><div class=\"line\">127.0.0.1:6379&gt; CONFIG GET loglevel</div><div class=\"line\">1) <span class=\"string\">\"loglevel\"</span></div><div class=\"line\">2) <span class=\"string\">\"notice\"</span></div><div class=\"line\">127.0.0.1:6379&gt; config get *</div><div class=\"line\">  1) <span class=\"string\">\"dbfilename\"</span></div><div class=\"line\">  2) <span class=\"string\">\"dump.rdb\"</span></div><div class=\"line\">  3) <span class=\"string\">\"requirepass\"</span></div><div class=\"line\">  4) <span class=\"string\">\"\"</span></div><div class=\"line\">  5) <span class=\"string\">\"masterauth\"</span></div><div class=\"line\">  6) <span class=\"string\">\"\"</span></div><div class=\"line\">  7) <span class=\"string\">\"unixsocket\"</span></div><div class=\"line\">  8) <span class=\"string\">\"\"</span></div><div class=\"line\">  9) <span class=\"string\">\"logfile\"</span></div><div class=\"line\"> 10) <span class=\"string\">\"/var/log/redis/redis-server.log\"</span></div><div class=\"line\"> 11) <span class=\"string\">\"pidfile\"</span></div><div class=\"line\">..........后面省略</div></pre></td></tr></table></figure></p>\n<p>　　我们可以通过config　get key获取配置文件中某项配置的值。并可以通过config set config_string_name new_config_value来更新其值。<br>　　下面对一些常用的配置项进行说明：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>　说明  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>daemonize</td>\n<td>是否设为守护进程</td>\n</tr>\n<tr>\n<td>pidfile</td>\n<td>设置守护进程pid存储文件的位置</td>\n</tr>\n<tr>\n<td>port</td>\n<td>指定redis端口(默认6379)</td>\n</tr>\n<tr>\n<td>databases</td>\n<td>设置redis内置数据库的数量。通过select切换</td>\n</tr>\n<tr>\n<td>save</td>\n<td>指定同步到文件的规则</td>\n</tr>\n<tr>\n<td>maxclient</td>\n<td>最大客户连接数，0为不设限制</td>\n</tr>\n<tr>\n<td>maxmemory</td>\n<td>最大分配内存</td>\n</tr>\n</tbody>\n</table>\n<p>对于命令还有很多，大家可以在需要时自行查看。</p>\n<h2 id=\"2-2-redis数据类型\"><a href=\"#2-2-redis数据类型\" class=\"headerlink\" title=\"2.2　redis数据类型\"></a>2.2　redis数据类型</h2><p>　　数据类型对于redis相对其他缓存产品而言，其丰富的数据格式是它的一大特色。这里做一下简单的介绍。</p>\n<h3 id=\"string字符串类型\"><a href=\"#string字符串类型\" class=\"headerlink\" title=\"string字符串类型\"></a>string字符串类型</h3><p>　　string类型是最基本的类型，它和memcached一样的类型.一个key对应一个value。redis中，string是二进制安全的，也就是说它可以存储任何数据(如图片或者序列化的对象)。一个键的最大存储为512MB.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; SET name <span class=\"string\">\"redis.net.cn\"</span></div><div class=\"line\">OK</div><div class=\"line\">redis 127.0.0.1:6379&gt; GET name</div><div class=\"line\"><span class=\"string\">\"redis.net.cn\"</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"hash（哈希\"><a href=\"#hash（哈希\" class=\"headerlink\" title=\"hash（哈希)\"></a>hash（哈希)</h3><p>Redis hash是一个键值组合，它是一个string类型的field和value的映射表。特别适合存储对象。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; HMSET user:1 username redis.net.cn password redis.net.cn points 200</div><div class=\"line\">OK</div><div class=\"line\">redis 127.0.0.1:6379&gt; HGETALL user:1</div><div class=\"line\">1) <span class=\"string\">\"username\"</span></div><div class=\"line\">2) <span class=\"string\">\"redis.net.cn\"</span></div><div class=\"line\">3) <span class=\"string\">\"password\"</span></div><div class=\"line\">4) <span class=\"string\">\"redis.net.cn\"</span></div><div class=\"line\">5) <span class=\"string\">\"points\"</span></div><div class=\"line\">6) <span class=\"string\">\"200\"</span></div></pre></td></tr></table></figure></p>\n<p>每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>\n<h3 id=\"list-列表\"><a href=\"#list-列表\" class=\"headerlink\" title=\"list(列表)\"></a>list(列表)</h3><p>　　redis　list列表是简单的string类型列表。可以添加一个元素在列表的头部或者尾部。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; lpush redis.net.cn redis</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; lpush redis.net.cn mongodb</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 2</div><div class=\"line\">redis 127.0.0.1:6379&gt; lpush redis.net.cn rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 3</div><div class=\"line\">redis 127.0.0.1:6379&gt; lrange redis.net.cn 0 10</div><div class=\"line\">1) <span class=\"string\">\"rabitmq\"</span></div><div class=\"line\">2) <span class=\"string\">\"mongodb\"</span></div><div class=\"line\">3) <span class=\"string\">\"redis\"</span></div><div class=\"line\">redis 127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>\n<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>\n<h3 id=\"set-集合\"><a href=\"#set-集合\" class=\"headerlink\" title=\"set(集合)\"></a>set(集合)</h3><p>　　Redis的set是string类型的无序集合。它是通过hash表实现的。增添和查找的复杂度为O(1).</p>\n<blockquote>\n<p>sadd key member</p>\n</blockquote>\n<p>实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn redis</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn mongodb</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 0</div><div class=\"line\">redis 127.0.0.1:6379&gt; smembers redis.net.cn</div><div class=\"line\"></div><div class=\"line\">1) <span class=\"string\">\"rabitmq\"</span></div><div class=\"line\">2) <span class=\"string\">\"mongodb\"</span></div><div class=\"line\">3) <span class=\"string\">\"redis\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"zset（有序集合\"><a href=\"#zset（有序集合\" class=\"headerlink\" title=\"zset（有序集合)\"></a>zset（有序集合)</h3><p>　　zset是一个有序的string集合，且不允许成员重复。每个成员会关联一个double类型的分数。通过分数进行排序。成员唯一，但是分数可以重复。</p>\n<blockquote>\n<p>zadd key score member</p>\n</blockquote>\n<p>实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 redis</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 mongodb</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 0</div><div class=\"line\">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE redis.net.cn 0 1000</div><div class=\"line\"></div><div class=\"line\">1) <span class=\"string\">\"redis\"</span></div><div class=\"line\">2) <span class=\"string\">\"mongodb\"</span></div><div class=\"line\">3) <span class=\"string\">\"rabitmq\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"2-3-Redis命令\"><a href=\"#2-3-Redis命令\" class=\"headerlink\" title=\"2.3 Redis命令\"></a>2.3 Redis命令</h2><p>  通过介绍redis的命令，了解redis的使用</p>\n<h3 id=\"PING\"><a href=\"#PING\" class=\"headerlink\" title=\"PING\"></a>PING</h3><p>　　redis可以通过ping命令检测redis的运行情况。若正常运行，则返回pung<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; PING</div><div class=\"line\"></div><div class=\"line\">PONG</div></pre></td></tr></table></figure></p>\n<h3 id=\"key相关命令\"><a href=\"#key相关命令\" class=\"headerlink\" title=\"key相关命令\"></a>key相关命令</h3><table>\n<thead>\n<tr>\n<th>命令　</th>\n<th>　说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set key</td>\n<td>插入一个key-value</td>\n</tr>\n<tr>\n<td>del key</td>\n<td>删除一个key-value.正确返回１，错误返回０</td>\n</tr>\n<tr>\n<td>dump key</td>\n<td>序列化key。正确返回序列化后字符串，错误返回nil</td>\n</tr>\n</tbody>\n</table>\n<p>exists key ｜　检测键值是否存在<br>expire key seconds | 设置键值过期时间，时间到了自动删除<br>move key db ｜　将当前数据库的key移动到其他数据库<br>persist key | 移除过期时间，永久保存<br>rename key new key | 重命名key<br>type key | 返回key的类型</p>\n<h3 id=\"publish-subscribe命令\"><a href=\"#publish-subscribe命令\" class=\"headerlink\" title=\"publish\\subscribe命令\"></a>publish\\subscribe命令</h3><p>　　pub\\sub是一个消息通信模式。通过subscribe订阅消息，然后通过publish发送消息。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#订阅者</span></div><div class=\"line\">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</div><div class=\"line\"></div><div class=\"line\">Reading messages... (press Ctrl-C to quit)</div><div class=\"line\">1) <span class=\"string\">\"subscribe\"</span></div><div class=\"line\">2) <span class=\"string\">\"redisChat\"</span></div><div class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#发送者</span></div><div class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class=\"string\">\"Redis is a great caching technique\"</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class=\"string\">\"Learn redis by w3cschool.cc\"</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 订阅者的客户端会显示如下消息</span></div><div class=\"line\">1) <span class=\"string\">\"message\"</span></div><div class=\"line\">2) <span class=\"string\">\"redisChat\"</span></div><div class=\"line\">3) <span class=\"string\">\"Redis is a great caching technique\"</span></div><div class=\"line\">1) <span class=\"string\">\"message\"</span></div><div class=\"line\">2) <span class=\"string\">\"redisChat\"</span></div><div class=\"line\">3) <span class=\"string\">\"Learn redis by w3cschool.cc\"</span></div></pre></td></tr></table></figure>\n<p>　　通过unsubscribe退订频道。</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>　　Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>\n<ul>\n<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>\n<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>\n</ul>\n<p>一个事务从开始到执行会经历以下三个阶段：</p>\n<ul>\n<li>开始事务。</li>\n<li>命令入队。</li>\n<li>执行事务。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; MULTI</div><div class=\"line\">OK</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; SET book-name <span class=\"string\">\"Mastering C++ in 21 days\"</span></div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; GET book-name</div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; SADD tag <span class=\"string\">\"C++\"</span> <span class=\"string\">\"Programming\"</span> <span class=\"string\">\"Mastering Series\"</span></div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; SMEMBERS tag</div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; EXEC</div><div class=\"line\">1) OK</div><div class=\"line\">2) <span class=\"string\">\"Mastering C++ in 21 days\"</span></div><div class=\"line\">3) (<span class=\"built_in\">integer</span>) 3</div><div class=\"line\">4) 1) <span class=\"string\">\"Mastering Series\"</span></div><div class=\"line\">   2) <span class=\"string\">\"C++\"</span></div><div class=\"line\">   3) <span class=\"string\">\"Programming\"</span></div></pre></td></tr></table></figure>\n<p>  discard取消事务执行。</p>\n<h3 id=\"INFO\"><a href=\"#INFO\" class=\"headerlink\" title=\"INFO　\"></a>INFO　</h3><p>查看当前redis所有信息</p>\n<h3 id=\"脚本支持\"><a href=\"#脚本支持\" class=\"headerlink\" title=\"脚本支持\"></a>脚本支持</h3><p>　 redis内置lua解析器</p>\n<h2 id=\"2-4-Redis为什么不能取代关系型数据库\"><a href=\"#2-4-Redis为什么不能取代关系型数据库\" class=\"headerlink\" title=\"2.4 Redis为什么不能取代关系型数据库\"></a>2.4 Redis为什么不能取代关系型数据库</h2><ol>\n<li>复杂的数据结构不好维护</li>\n<li>存储于内存虽然访问速度较快，但是关系体现不出来。</li>\n<li>存储成本高</li>\n</ol>\n<h1 id=\"3-参考文献\"><a href=\"#3-参考文献\" class=\"headerlink\" title=\"3 参考文献\"></a>3 参考文献</h1><ul>\n<li>[1]: <a href=\"http://www.redis.net.cn/tutorial/3501.html\" target=\"_blank\" rel=\"external\">redis官方文档</a></li>\n<li>[2]: <a href=\"https://www.teakki.com/p/57dbd374d7d770e81877c75a\" target=\"_blank\" rel=\"external\">redis为什么不能取代关系数据库</a></li>\n</ul>\n","excerpt":"<h1 id=\"1-认识redis\"><a href=\"#1-认识redis\" class=\"headerlink\" title=\"1. 认识redis\"></a>1. 认识redis</h1><p>　　redis是一个key-value的存储系统。它支持网络、可基于内存亦可持久化的日志型、key-value数据库。value值可支持string,map,list,sets和sorted sets等类型。<br>　　详细的说，redis相对其它key-value缓存产品(如memcached)有三个特点：</p>\n<ul>\n<li>支持持久化，可将内存中的数据保持到磁盘中，重启时可再次加载进行使用。</li>\n<li>不仅仅支持简单的key-value类型的数据，同事还提供list,set,zset,hash等数据结构的存储</li>\n<li>支持数据备份,master-slave模式</li>\n</ul>","more":"<p>  除此之外，redis还具备一下特点:</p>\n<ul>\n<li>极高的性能：　读110000次/s，　写的速度81000次/s</li>\n<li>丰富的数据类型</li>\n<li>原子性：所有操作都是原子性的。</li>\n<li>丰富的特性: 支持通知、key过期，publish/subscribe等</li>\n</ul>\n<h1 id=\"2-使用redis\"><a href=\"#2-使用redis\" class=\"headerlink\" title=\"2.使用redis\"></a>2.使用redis</h1><p>　　对于一个工具，我们更关心的是如何使用。这里我从官方的文档中摘录出一些我自己比较感性去的部分罗列与此。和大家分享。</p>\n<h2 id=\"2-1-配置Redis\"><a href=\"#2-1-配置Redis\" class=\"headerlink\" title=\"2.1　配置Redis\"></a>2.1　配置Redis</h2><p>　　如何正确的使用配置文件，有利于我们更好的使用redis。这里我们认识一下常用命令。我安装了redis-cli，这里直接使用。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">lennybai@lennybai:~$ redis-cli</div><div class=\"line\">127.0.0.1:6379&gt; CONFIG GET loglevel</div><div class=\"line\">1) <span class=\"string\">\"loglevel\"</span></div><div class=\"line\">2) <span class=\"string\">\"notice\"</span></div><div class=\"line\">127.0.0.1:6379&gt; config get *</div><div class=\"line\">  1) <span class=\"string\">\"dbfilename\"</span></div><div class=\"line\">  2) <span class=\"string\">\"dump.rdb\"</span></div><div class=\"line\">  3) <span class=\"string\">\"requirepass\"</span></div><div class=\"line\">  4) <span class=\"string\">\"\"</span></div><div class=\"line\">  5) <span class=\"string\">\"masterauth\"</span></div><div class=\"line\">  6) <span class=\"string\">\"\"</span></div><div class=\"line\">  7) <span class=\"string\">\"unixsocket\"</span></div><div class=\"line\">  8) <span class=\"string\">\"\"</span></div><div class=\"line\">  9) <span class=\"string\">\"logfile\"</span></div><div class=\"line\"> 10) <span class=\"string\">\"/var/log/redis/redis-server.log\"</span></div><div class=\"line\"> 11) <span class=\"string\">\"pidfile\"</span></div><div class=\"line\">..........后面省略</div></pre></td></tr></table></figure></p>\n<p>　　我们可以通过config　get key获取配置文件中某项配置的值。并可以通过config set config_string_name new_config_value来更新其值。<br>　　下面对一些常用的配置项进行说明：</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>　说明  </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>daemonize</td>\n<td>是否设为守护进程</td>\n</tr>\n<tr>\n<td>pidfile</td>\n<td>设置守护进程pid存储文件的位置</td>\n</tr>\n<tr>\n<td>port</td>\n<td>指定redis端口(默认6379)</td>\n</tr>\n<tr>\n<td>databases</td>\n<td>设置redis内置数据库的数量。通过select切换</td>\n</tr>\n<tr>\n<td>save</td>\n<td>指定同步到文件的规则</td>\n</tr>\n<tr>\n<td>maxclient</td>\n<td>最大客户连接数，0为不设限制</td>\n</tr>\n<tr>\n<td>maxmemory</td>\n<td>最大分配内存</td>\n</tr>\n</tbody>\n</table>\n<p>对于命令还有很多，大家可以在需要时自行查看。</p>\n<h2 id=\"2-2-redis数据类型\"><a href=\"#2-2-redis数据类型\" class=\"headerlink\" title=\"2.2　redis数据类型\"></a>2.2　redis数据类型</h2><p>　　数据类型对于redis相对其他缓存产品而言，其丰富的数据格式是它的一大特色。这里做一下简单的介绍。</p>\n<h3 id=\"string字符串类型\"><a href=\"#string字符串类型\" class=\"headerlink\" title=\"string字符串类型\"></a>string字符串类型</h3><p>　　string类型是最基本的类型，它和memcached一样的类型.一个key对应一个value。redis中，string是二进制安全的，也就是说它可以存储任何数据(如图片或者序列化的对象)。一个键的最大存储为512MB.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; SET name <span class=\"string\">\"redis.net.cn\"</span></div><div class=\"line\">OK</div><div class=\"line\">redis 127.0.0.1:6379&gt; GET name</div><div class=\"line\"><span class=\"string\">\"redis.net.cn\"</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"hash（哈希\"><a href=\"#hash（哈希\" class=\"headerlink\" title=\"hash（哈希)\"></a>hash（哈希)</h3><p>Redis hash是一个键值组合，它是一个string类型的field和value的映射表。特别适合存储对象。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; HMSET user:1 username redis.net.cn password redis.net.cn points 200</div><div class=\"line\">OK</div><div class=\"line\">redis 127.0.0.1:6379&gt; HGETALL user:1</div><div class=\"line\">1) <span class=\"string\">\"username\"</span></div><div class=\"line\">2) <span class=\"string\">\"redis.net.cn\"</span></div><div class=\"line\">3) <span class=\"string\">\"password\"</span></div><div class=\"line\">4) <span class=\"string\">\"redis.net.cn\"</span></div><div class=\"line\">5) <span class=\"string\">\"points\"</span></div><div class=\"line\">6) <span class=\"string\">\"200\"</span></div></pre></td></tr></table></figure></p>\n<p>每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>\n<h3 id=\"list-列表\"><a href=\"#list-列表\" class=\"headerlink\" title=\"list(列表)\"></a>list(列表)</h3><p>　　redis　list列表是简单的string类型列表。可以添加一个元素在列表的头部或者尾部。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; lpush redis.net.cn redis</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; lpush redis.net.cn mongodb</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 2</div><div class=\"line\">redis 127.0.0.1:6379&gt; lpush redis.net.cn rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 3</div><div class=\"line\">redis 127.0.0.1:6379&gt; lrange redis.net.cn 0 10</div><div class=\"line\">1) <span class=\"string\">\"rabitmq\"</span></div><div class=\"line\">2) <span class=\"string\">\"mongodb\"</span></div><div class=\"line\">3) <span class=\"string\">\"redis\"</span></div><div class=\"line\">redis 127.0.0.1:6379&gt;</div></pre></td></tr></table></figure></p>\n<p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p>\n<h3 id=\"set-集合\"><a href=\"#set-集合\" class=\"headerlink\" title=\"set(集合)\"></a>set(集合)</h3><p>　　Redis的set是string类型的无序集合。它是通过hash表实现的。增添和查找的复杂度为O(1).</p>\n<blockquote>\n<p>sadd key member</p>\n</blockquote>\n<p>实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn redis</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn mongodb</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; sadd redis.net.cn rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 0</div><div class=\"line\">redis 127.0.0.1:6379&gt; smembers redis.net.cn</div><div class=\"line\"></div><div class=\"line\">1) <span class=\"string\">\"rabitmq\"</span></div><div class=\"line\">2) <span class=\"string\">\"mongodb\"</span></div><div class=\"line\">3) <span class=\"string\">\"redis\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"zset（有序集合\"><a href=\"#zset（有序集合\" class=\"headerlink\" title=\"zset（有序集合)\"></a>zset（有序集合)</h3><p>　　zset是一个有序的string集合，且不允许成员重复。每个成员会关联一个double类型的分数。通过分数进行排序。成员唯一，但是分数可以重复。</p>\n<blockquote>\n<p>zadd key score member</p>\n</blockquote>\n<p>实例</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 redis</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 mongodb</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\">redis 127.0.0.1:6379&gt; zadd redis.net.cn 0 rabitmq</div><div class=\"line\">(<span class=\"built_in\">integer</span>) 0</div><div class=\"line\">redis 127.0.0.1:6379&gt; ZRANGEBYSCORE redis.net.cn 0 1000</div><div class=\"line\"></div><div class=\"line\">1) <span class=\"string\">\"redis\"</span></div><div class=\"line\">2) <span class=\"string\">\"mongodb\"</span></div><div class=\"line\">3) <span class=\"string\">\"rabitmq\"</span></div></pre></td></tr></table></figure>\n<h2 id=\"2-3-Redis命令\"><a href=\"#2-3-Redis命令\" class=\"headerlink\" title=\"2.3 Redis命令\"></a>2.3 Redis命令</h2><p>  通过介绍redis的命令，了解redis的使用</p>\n<h3 id=\"PING\"><a href=\"#PING\" class=\"headerlink\" title=\"PING\"></a>PING</h3><p>　　redis可以通过ping命令检测redis的运行情况。若正常运行，则返回pung<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; PING</div><div class=\"line\"></div><div class=\"line\">PONG</div></pre></td></tr></table></figure></p>\n<h3 id=\"key相关命令\"><a href=\"#key相关命令\" class=\"headerlink\" title=\"key相关命令\"></a>key相关命令</h3><table>\n<thead>\n<tr>\n<th>命令　</th>\n<th>　说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Set key</td>\n<td>插入一个key-value</td>\n</tr>\n<tr>\n<td>del key</td>\n<td>删除一个key-value.正确返回１，错误返回０</td>\n</tr>\n<tr>\n<td>dump key</td>\n<td>序列化key。正确返回序列化后字符串，错误返回nil</td>\n</tr>\n</tbody>\n</table>\n<p>exists key ｜　检测键值是否存在<br>expire key seconds | 设置键值过期时间，时间到了自动删除<br>move key db ｜　将当前数据库的key移动到其他数据库<br>persist key | 移除过期时间，永久保存<br>rename key new key | 重命名key<br>type key | 返回key的类型</p>\n<h3 id=\"publish-subscribe命令\"><a href=\"#publish-subscribe命令\" class=\"headerlink\" title=\"publish\\subscribe命令\"></a>publish\\subscribe命令</h3><p>　　pub\\sub是一个消息通信模式。通过subscribe订阅消息，然后通过publish发送消息。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#订阅者</span></div><div class=\"line\">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</div><div class=\"line\"></div><div class=\"line\">Reading messages... (press Ctrl-C to quit)</div><div class=\"line\">1) <span class=\"string\">\"subscribe\"</span></div><div class=\"line\">2) <span class=\"string\">\"redisChat\"</span></div><div class=\"line\">3) (<span class=\"built_in\">integer</span>) 1</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#发送者</span></div><div class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class=\"string\">\"Redis is a great caching technique\"</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; PUBLISH redisChat <span class=\"string\">\"Learn redis by w3cschool.cc\"</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"built_in\">integer</span>) 1</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 订阅者的客户端会显示如下消息</span></div><div class=\"line\">1) <span class=\"string\">\"message\"</span></div><div class=\"line\">2) <span class=\"string\">\"redisChat\"</span></div><div class=\"line\">3) <span class=\"string\">\"Redis is a great caching technique\"</span></div><div class=\"line\">1) <span class=\"string\">\"message\"</span></div><div class=\"line\">2) <span class=\"string\">\"redisChat\"</span></div><div class=\"line\">3) <span class=\"string\">\"Learn redis by w3cschool.cc\"</span></div></pre></td></tr></table></figure>\n<p>　　通过unsubscribe退订频道。</p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>　　Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>\n<ul>\n<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>\n<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>\n</ul>\n<p>一个事务从开始到执行会经历以下三个阶段：</p>\n<ul>\n<li>开始事务。</li>\n<li>命令入队。</li>\n<li>执行事务。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">redis 127.0.0.1:6379&gt; MULTI</div><div class=\"line\">OK</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; SET book-name <span class=\"string\">\"Mastering C++ in 21 days\"</span></div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; GET book-name</div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; SADD tag <span class=\"string\">\"C++\"</span> <span class=\"string\">\"Programming\"</span> <span class=\"string\">\"Mastering Series\"</span></div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; SMEMBERS tag</div><div class=\"line\">QUEUED</div><div class=\"line\"></div><div class=\"line\">redis 127.0.0.1:6379&gt; EXEC</div><div class=\"line\">1) OK</div><div class=\"line\">2) <span class=\"string\">\"Mastering C++ in 21 days\"</span></div><div class=\"line\">3) (<span class=\"built_in\">integer</span>) 3</div><div class=\"line\">4) 1) <span class=\"string\">\"Mastering Series\"</span></div><div class=\"line\">   2) <span class=\"string\">\"C++\"</span></div><div class=\"line\">   3) <span class=\"string\">\"Programming\"</span></div></pre></td></tr></table></figure>\n<p>  discard取消事务执行。</p>\n<h3 id=\"INFO\"><a href=\"#INFO\" class=\"headerlink\" title=\"INFO　\"></a>INFO　</h3><p>查看当前redis所有信息</p>\n<h3 id=\"脚本支持\"><a href=\"#脚本支持\" class=\"headerlink\" title=\"脚本支持\"></a>脚本支持</h3><p>　 redis内置lua解析器</p>\n<h2 id=\"2-4-Redis为什么不能取代关系型数据库\"><a href=\"#2-4-Redis为什么不能取代关系型数据库\" class=\"headerlink\" title=\"2.4 Redis为什么不能取代关系型数据库\"></a>2.4 Redis为什么不能取代关系型数据库</h2><ol>\n<li>复杂的数据结构不好维护</li>\n<li>存储于内存虽然访问速度较快，但是关系体现不出来。</li>\n<li>存储成本高</li>\n</ol>\n<h1 id=\"3-参考文献\"><a href=\"#3-参考文献\" class=\"headerlink\" title=\"3 参考文献\"></a>3 参考文献</h1><ul>\n<li>[1]: <a href=\"http://www.redis.net.cn/tutorial/3501.html\">redis官方文档</a></li>\n<li>[2]: <a href=\"https://www.teakki.com/p/57dbd374d7d770e81877c75a\">redis为什么不能取代关系数据库</a></li>\n</ul>"},{"title":"leetcode-longestSubStringWithOutRepeatingCharacters","comments":0,"date":"2016-12-13T07:20:24.000Z","_content":"\n### [longest-substring-without-repeating-characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\nGiven a string, find the length of the longest substring without repeating characters.\n\n<!--more-->\n\n### example\n> Given \"abcabcbb\", the answer is \"abc\", which the length is 3.\n\n> Given \"bbbbb\", the answer is \"b\", with the length of 1.\n\n> Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n### 思路\n　　阅读本题后，都会有大致的概念应该怎么去处理。大题思路就是从头到位遍历字符串，记录所有的没有出现重复字符的子字符串，并记录其长度。最后选出最大长度输出。这个思路理论上应该可以解决我们的问题，但是如何写出漂亮解答，还是需要我们稍作思考的。\n　　让我们再重新审阅一下这个题目。如果我们假设子字符串s[i..j]为无重复子字符串，其长度为ｌ。如果s[j+1]也不存在在s[i..j]中，那么s[i..j+1]也是无重复子字符串，其长度更新为l+1。根据这种设计，我们完全可以套用动态规划来解决这个问题。（前面的文章有介绍)\n　　那么我们进而去丰富我们的动态规划设计：\n1. 标记子字符串起点substringstart。若s[j+1]与s[i..j]中无重复字符，那么s[i..j+1]的子字符串起点也为i；如果与r(i≤r≤j)重复，则其起点变为r+1;\n2. 记录最大长度longest。当前长度[i..j]为j-i+1，与longest做比较，则其较大的更新longest。\n3. 因为使用hashmap来优化记录存储。\n\n### coding\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\n  public:\n    int lengthOfLongestSubstring(string s) {\n        vector<int> hashMap(256, -1);\n        int longest = 0, subStringStart = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            subStringStart = subStringStart >= hashMap[s[i]] + 1 ? subStringStart : hashMap[s[i]] + 1;\n            hashMap[s[i]] = i;\n            longest = longest >= i-subStringStart +1 ? longest : i - subStringStart + 1;\n        }\n        return longest;\n    }\n\n};\n\nint main(int argc, char *argv[])\n{\n    string s1 = \"abcabcbb\";\n    string s2 = \"a\";\n    string s3 = \"abc\";\n    string s4 = \"aab\";\n    Solution solution;\n    cout << solution.lengthOfLongestSubstring(s1) << endl;\n    cout << solution.lengthOfLongestSubstring(s2) << endl;\n    cout << solution.lengthOfLongestSubstring(s3) << endl;\n    cout << solution.lengthOfLongestSubstring(s4) << endl;\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","source":"_posts/leetcode-longestSubStringWithOutRepeatingCharacters.md","raw":"---\ntitle: leetcode-longestSubStringWithOutRepeatingCharacters\ncomments: false\ndate: 2016-12-13 15:20:24\ntags:\n  - 程序设计\n  - leetcode\ncategories:\n  - 程序设计\n  - leetcode\n---\n\n### [longest-substring-without-repeating-characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\nGiven a string, find the length of the longest substring without repeating characters.\n\n<!--more-->\n\n### example\n> Given \"abcabcbb\", the answer is \"abc\", which the length is 3.\n\n> Given \"bbbbb\", the answer is \"b\", with the length of 1.\n\n> Given \"pwwkew\", the answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\n### 思路\n　　阅读本题后，都会有大致的概念应该怎么去处理。大题思路就是从头到位遍历字符串，记录所有的没有出现重复字符的子字符串，并记录其长度。最后选出最大长度输出。这个思路理论上应该可以解决我们的问题，但是如何写出漂亮解答，还是需要我们稍作思考的。\n　　让我们再重新审阅一下这个题目。如果我们假设子字符串s[i..j]为无重复子字符串，其长度为ｌ。如果s[j+1]也不存在在s[i..j]中，那么s[i..j+1]也是无重复子字符串，其长度更新为l+1。根据这种设计，我们完全可以套用动态规划来解决这个问题。（前面的文章有介绍)\n　　那么我们进而去丰富我们的动态规划设计：\n1. 标记子字符串起点substringstart。若s[j+1]与s[i..j]中无重复字符，那么s[i..j+1]的子字符串起点也为i；如果与r(i≤r≤j)重复，则其起点变为r+1;\n2. 记录最大长度longest。当前长度[i..j]为j-i+1，与longest做比较，则其较大的更新longest。\n3. 因为使用hashmap来优化记录存储。\n\n### coding\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\n  public:\n    int lengthOfLongestSubstring(string s) {\n        vector<int> hashMap(256, -1);\n        int longest = 0, subStringStart = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            subStringStart = subStringStart >= hashMap[s[i]] + 1 ? subStringStart : hashMap[s[i]] + 1;\n            hashMap[s[i]] = i;\n            longest = longest >= i-subStringStart +1 ? longest : i - subStringStart + 1;\n        }\n        return longest;\n    }\n\n};\n\nint main(int argc, char *argv[])\n{\n    string s1 = \"abcabcbb\";\n    string s2 = \"a\";\n    string s3 = \"abc\";\n    string s4 = \"aab\";\n    Solution solution;\n    cout << solution.lengthOfLongestSubstring(s1) << endl;\n    cout << solution.lengthOfLongestSubstring(s2) << endl;\n    cout << solution.lengthOfLongestSubstring(s3) << endl;\n    cout << solution.lengthOfLongestSubstring(s4) << endl;\n    return 0;\n}\n```\n\n### github\n\n[github代码链接](https://github.com/geeklenny/leetcode)\n","slug":"leetcode-longestSubStringWithOutRepeatingCharacters","published":1,"updated":"2016-12-14T00:50:54.760Z","layout":"post","photos":[],"link":"","_id":"cix1e5cfc000snvou9h4yrauv","content":"<h3 id=\"longest-substring-without-repeating-characters\"><a href=\"#longest-substring-without-repeating-characters\" class=\"headerlink\" title=\"longest-substring-without-repeating-characters\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\" target=\"_blank\" rel=\"external\">longest-substring-without-repeating-characters</a></h3><p>Given a string, find the length of the longest substring without repeating characters.</p>\n<a id=\"more\"></a>\n<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>\n<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>\n<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　阅读本题后，都会有大致的概念应该怎么去处理。大题思路就是从头到位遍历字符串，记录所有的没有出现重复字符的子字符串，并记录其长度。最后选出最大长度输出。这个思路理论上应该可以解决我们的问题，但是如何写出漂亮解答，还是需要我们稍作思考的。<br>　　让我们再重新审阅一下这个题目。如果我们假设子字符串s[i..j]为无重复子字符串，其长度为ｌ。如果s[j+1]也不存在在s[i..j]中，那么s[i..j+1]也是无重复子字符串，其长度更新为l+1。根据这种设计，我们完全可以套用动态规划来解决这个问题。（前面的文章有介绍)<br>　　那么我们进而去丰富我们的动态规划设计：</p>\n<ol>\n<li>标记子字符串起点substringstart。若s[j+1]与s[i..j]中无重复字符，那么s[i..j+1]的子字符串起点也为i；如果与r(i≤r≤j)重复，则其起点变为r+1;</li>\n<li>记录最大长度longest。当前长度[i..j]为j-i+1，与longest做比较，则其较大的更新longest。</li>\n<li>因为使用hashmap来优化记录存储。</li>\n</ol>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; hashMap(<span class=\"number\">256</span>, <span class=\"number\">-1</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> longest = <span class=\"number\">0</span>, subStringStart = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            subStringStart = subStringStart &gt;= hashMap[s[i]] + <span class=\"number\">1</span> ? subStringStart : hashMap[s[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">            hashMap[s[i]] = i;</div><div class=\"line\">            longest = longest &gt;= i-subStringStart +<span class=\"number\">1</span> ? longest : i - subStringStart + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> longest;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> s1 = <span class=\"string\">\"abcabcbb\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s2 = <span class=\"string\">\"a\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s3 = <span class=\"string\">\"abc\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s4 = <span class=\"string\">\"aab\"</span>;</div><div class=\"line\">    Solution solution;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s1) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s2) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s3) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s4) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\" target=\"_blank\" rel=\"external\">github代码链接</a></p>\n","excerpt":"<h3 id=\"longest-substring-without-repeating-characters\"><a href=\"#longest-substring-without-repeating-characters\" class=\"headerlink\" title=\"longest-substring-without-repeating-characters\"></a><a href=\"https://leetcode.com/problems/longest-substring-without-repeating-characters/\">longest-substring-without-repeating-characters</a></h3><p>Given a string, find the length of the longest substring without repeating characters.</p>","more":"<h3 id=\"example\"><a href=\"#example\" class=\"headerlink\" title=\"example\"></a>example</h3><blockquote>\n<p>Given “abcabcbb”, the answer is “abc”, which the length is 3.</p>\n<p>Given “bbbbb”, the answer is “b”, with the length of 1.</p>\n<p>Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>\n</blockquote>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>　　阅读本题后，都会有大致的概念应该怎么去处理。大题思路就是从头到位遍历字符串，记录所有的没有出现重复字符的子字符串，并记录其长度。最后选出最大长度输出。这个思路理论上应该可以解决我们的问题，但是如何写出漂亮解答，还是需要我们稍作思考的。<br>　　让我们再重新审阅一下这个题目。如果我们假设子字符串s[i..j]为无重复子字符串，其长度为ｌ。如果s[j+1]也不存在在s[i..j]中，那么s[i..j+1]也是无重复子字符串，其长度更新为l+1。根据这种设计，我们完全可以套用动态规划来解决这个问题。（前面的文章有介绍)<br>　　那么我们进而去丰富我们的动态规划设计：</p>\n<ol>\n<li>标记子字符串起点substringstart。若s[j+1]与s[i..j]中无重复字符，那么s[i..j+1]的子字符串起点也为i；如果与r(i≤r≤j)重复，则其起点变为r+1;</li>\n<li>记录最大长度longest。当前长度[i..j]为j-i+1，与longest做比较，则其较大的更新longest。</li>\n<li>因为使用hashmap来优化记录存储。</li>\n</ol>\n<h3 id=\"coding\"><a href=\"#coding\" class=\"headerlink\" title=\"coding\"></a>coding</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">class</span> Solution &#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span> </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; hashMap(<span class=\"number\">256</span>, <span class=\"number\">-1</span>);</div><div class=\"line\">        <span class=\"keyword\">int</span> longest = <span class=\"number\">0</span>, subStringStart = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.length(); i++)</div><div class=\"line\">        &#123;</div><div class=\"line\">            subStringStart = subStringStart &gt;= hashMap[s[i]] + <span class=\"number\">1</span> ? subStringStart : hashMap[s[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">            hashMap[s[i]] = i;</div><div class=\"line\">            longest = longest &gt;= i-subStringStart +<span class=\"number\">1</span> ? longest : i - subStringStart + <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> longest;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">string</span> s1 = <span class=\"string\">\"abcabcbb\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s2 = <span class=\"string\">\"a\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s3 = <span class=\"string\">\"abc\"</span>;</div><div class=\"line\">    <span class=\"built_in\">string</span> s4 = <span class=\"string\">\"aab\"</span>;</div><div class=\"line\">    Solution solution;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s1) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s2) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s3) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; solution.lengthOfLongestSubstring(s4) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"github\"><a href=\"#github\" class=\"headerlink\" title=\"github\"></a>github</h3><p><a href=\"https://github.com/geeklenny/leetcode\">github代码链接</a></p>"},{"title":"数据库线程池(c++)","comments":0,"date":"2016-12-02T08:48:44.000Z","_content":"\n# 一、概述\n\n　　对于每一次的数据库访问，都需要有一个承载该次访问操作的数据库连接。现在的应用系统往往伴随着大量的数据库访问。可想而知，如果频繁的建立和关闭链接，会极大的降低系统的性能。\n\n　　数据库连接池是针对数据库连接的性能优化而产生的。它的核心思想是连接复用，并通过连接池高效并安全的维护连接池内的连接，并按需分配到各个调用者，以减少重复创建和删除连接造成的系统资源浪费。\n\n<!--more-->\n## 1.1 源代码链接\n[数据库连接池](https://github.com/geeklenny/databaseConnPool)\n\n# 二、源代码讲解\n　　希望你已经下载了源代码，这里开始对源代码进行讲解。这一份源代码我并没有做过多的性能测试，只是按照数据库连接池的基本思想和原理提供的一份实现。我希望这篇文章可以覆盖到数据库连接池的核心内容。\n\n## 2.1 连接池只是连接池\n　　我们编写连接池的目的是用来维护连接，减少系统资源浪费。所以我们避免将连接池设计和实现成通用的带数据库连接优化的数据库访问类。\n\n```cpp\ntemplate<typename T>\nclass CommonDbConnPool{...}\n```\n　　我们使用模板类来弱化数据库的具体类型，而更关系如何去维护其链接。对于具体的数据库操作，还是沿用使用的数据库提供的接口去访问。记住，数据库连接池只提供可用的连接，或者无可用连接时的错误提示。\n\n## 2.2　连接的初始化\n　　提高数据库链接的初始化，核心的问题是启动多少连接合适。启动太少，不能满足应用的需求；启动太多，对系统资源也是一种浪费。实际上，在什么样配置的服务器上，启动多少个连接合适并没有一个明确的参考数据。它们都需要进行测试，调整到最优的连接数。\n　　这里提供一个普遍适用于连接池的方法。它可以尽可能的保证系统资源的合理使用。这个方法是通常提供一个最小连接数和最大连接数。最小连接数为启动时默认启动的链接数目。如果最小连接数在被完全使用的时候，又进入一个新连接，那么连接池将为它新建一个连接。新建连接的前提是，连接总数没有超过最大连接数。否则返回连接池已满类似的错误信息。超出最小连接数的这些连接，会被定期回收释放。\n　　初始化的同时，启动监控线程，用于定期检测连接是否正常连接。\n```cpp\ntemplate<typename T>\nint CommonDbConnPool<T>::InitPool( int minConn, int maxConn )\n{\n    ...\n    ...\n    for ( int i =0 ; i < minConn; i++ )\n    {\n        if( (t = createDBConn()) != nullptr )\n        {\n            if( (bConnectionAvilable(t)) )\n            {\n                m_poolMap[t] = DB_CONN_FREE;\n            }\n            else\n            {\n                releaseDBConn(t);\n            }\n        }\n    ...\n    ...\n    thread th(&CommonDbConnPool<T>::PoolConnMonitor, this);\n    swap(th, m_trdConnMonitor);\n｝\n```\n\n## 2.3 连接的管理\n　　存在与连接池中的连接有三种状态。空闲，占用和临时连接。\n```cpp\nenum DBCONNSTATS\n{\n    DB_CONN_FREE,\n    DB_CONN_USED,\n    DB_CONN_TEMP_USED\n\n};\n```\n\n　　最小连接数内的连接，初始化为free，占用时为used。而超过最小链接，并未超过最大连接数的这些连接为临时连接，定期会被回收。当然什么时候回收由你来定，我的是现实，当连接被用户释放回连接池时，直接回收。很多的数据库连接池对于临时连接处理会巧妙的多。比如超过最小链接后，扩容一倍等等。\n   **需要强调的一点是，为了保证多线程的安全访问，请记得加锁。**\n\n```cpp\ntemplate <typename T>\nT* CommonDbConnPool<T>::GetDBConnFromPool()\n{\n    ...\n    lock_guard<mutex> locker(m_mtxPool);\n    ...\n    for(auto &iter : m_poolMap)\n    {\n        if(iter.second == DB_CONN_FREE){\n            iter.second = DB_CONN_USED;\n            t = iter.first;\n            break;\n        }\n    }\n\n    if (t == nullptr){\n        if(m_poolMap.size() < m_maxConn)\n        {\n            if( (t = createDBConn()) != nullptr )\n            {\n                if( (bConnectionAvilable(t)) )\n                {\n                    m_poolMap[t] = DB_CONN_TEMP_USED;\n                }\n                else\n                {\n                    releaseDBConn(t);\n                }\n            }\n        }\n\n\n    }\n\n    return t;\n}\n\ntemplate <typename T>\nvoid CommonDbConnPool<T>::ReleaseDbConnToPool(T* t)\n{\n    lock_guard<mutex> locker(m_mtxPool);\n    for (auto &iter : m_poolMap)\n    {\n        if(iter.first == t)\n        {\n            if(iter.second == DB_CONN_USED)\n            {\n                iter.second = DB_CONN_FREE;\n            } else if (iter.second == DB_CONN_TEMP_USED)\n            {\n                releaseDBConn(iter.first);\n                m_poolMap.erase(iter.first);\n            }\n        }\n    }\n}\n```\n\n## 2.4 释放连接池\n　　释放连接也应该人性化，比如某个应用还在使用连接进行着访问，那我们不应该直接关闭该链接。\n　　我这里的处理是，关闭所有free的链接。并返回池内连接的大小。如果返回不为0，那么就相当于通知用户，连接并没有完全被释放，你还需要再次调用。\n   别忘了我们还有一个监控线程在运行着呢。别忘了结束线程。\n```cpp\ntemplate <typename T>\nvoid CommonDbConnPool<T>::PoolConnMonitor(){\n    ...\n    while(ptrPool->m_bPoolAvailable && ! ptrPool->m_bPoolToDestroy)\n    {\n        ...\n        [&](){\n            unique_lock<mutex> lk(ptrPool->m_mtxCv);\n            ptrPool->m_Cv.wait_for(lk, chrono::milliseconds(ptrPool->ulTimeForCheckTimeout()));\n        }();\n    ...\n    }\n}\n\n\ntemplate <typename T>\nint CommonDbConnPool<T>::DestroyPool(){\n    ...\n    for( auto &iter : m_poolMap)\n    {\n        if( iter.second == DB_CONN_FREE)\n        {\n            releaseDBConn(iter.first);\n            m_poolMap.erase(iter.first);\n        }\n    }\n    ...\n    ...\n    ptrPool->m_bPoolToDestroy = true;\n    m_Cv.notify_one();\n    m_trdConnMonitor.join();\n\n    ...\n    return m_poolMap.size();\n}\n\n```\n\n# 三、使用\n 　我这里使用了mysqlcppconn的库，如果需要请自行安装下载。\n ```cpp\n#include <iostream>\n#include \"./mysql/mysqlConn.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n\n    MysqlConn* mysqlpool;\n    try{\n\n        do{\n\n            //连接数据库\n            mysqlpool = new MysqlConn(\"localhost\", \"root\", \"Passw0rd\");\n\n            //创建数据库连接池，并返回大小\n            cout << \" mysqlpool size : \" << mysqlpool->InitPool(10,20) << endl;\n\n            sql::Connection *con;\n            sql::Statement* stmt;\n            sql::ResultSet* res;\n\n            //获取一个连接\n            if((con=mysqlpool->GetDBConnFromPool())==nullptr){\n                cout<<\"reach the max availd\" << endl;\n                break;\n            }\n\n            //执行语句\n            con->setSchema(\"mysql\");\n            stmt = con->createStatement();\n            res = stmt->executeQuery(\"select * from user\");\n\n            //打印数据库连接池信息\n            cout<<(*mysqlpool);\n\n            //释放连接到连接池\n            mysqlpool->ReleaseDbConnToPool(con);\n\n            //打印数据库连接池信息\n            cout<<(*mysqlpool);\n            cin.get();\n\n        } while(false);\n        //销毁数据库连接池\n        if(mysqlpool->DestroyPool()>0){\n            cout<<\"There are still some un-release connections in the pool\\n\";\n        }\n\n        delete mysqlpool;\n\n    }catch(sql::SQLException &e){\n        std::cout<<e.what();\n    }\n    return 0;\n}\n```\n","source":"_posts/数据库连接池(c++).md","raw":"---\ntitle: 数据库线程池(c++)\ncomments: false\ndate: 2016-12-02 16:48:44\ntags:\n  - 程序设计\n  - c++\n  - 数据库连接池\ncategories:\n  - 程序设计\n  - 数据库连接池\n---\n\n# 一、概述\n\n　　对于每一次的数据库访问，都需要有一个承载该次访问操作的数据库连接。现在的应用系统往往伴随着大量的数据库访问。可想而知，如果频繁的建立和关闭链接，会极大的降低系统的性能。\n\n　　数据库连接池是针对数据库连接的性能优化而产生的。它的核心思想是连接复用，并通过连接池高效并安全的维护连接池内的连接，并按需分配到各个调用者，以减少重复创建和删除连接造成的系统资源浪费。\n\n<!--more-->\n## 1.1 源代码链接\n[数据库连接池](https://github.com/geeklenny/databaseConnPool)\n\n# 二、源代码讲解\n　　希望你已经下载了源代码，这里开始对源代码进行讲解。这一份源代码我并没有做过多的性能测试，只是按照数据库连接池的基本思想和原理提供的一份实现。我希望这篇文章可以覆盖到数据库连接池的核心内容。\n\n## 2.1 连接池只是连接池\n　　我们编写连接池的目的是用来维护连接，减少系统资源浪费。所以我们避免将连接池设计和实现成通用的带数据库连接优化的数据库访问类。\n\n```cpp\ntemplate<typename T>\nclass CommonDbConnPool{...}\n```\n　　我们使用模板类来弱化数据库的具体类型，而更关系如何去维护其链接。对于具体的数据库操作，还是沿用使用的数据库提供的接口去访问。记住，数据库连接池只提供可用的连接，或者无可用连接时的错误提示。\n\n## 2.2　连接的初始化\n　　提高数据库链接的初始化，核心的问题是启动多少连接合适。启动太少，不能满足应用的需求；启动太多，对系统资源也是一种浪费。实际上，在什么样配置的服务器上，启动多少个连接合适并没有一个明确的参考数据。它们都需要进行测试，调整到最优的连接数。\n　　这里提供一个普遍适用于连接池的方法。它可以尽可能的保证系统资源的合理使用。这个方法是通常提供一个最小连接数和最大连接数。最小连接数为启动时默认启动的链接数目。如果最小连接数在被完全使用的时候，又进入一个新连接，那么连接池将为它新建一个连接。新建连接的前提是，连接总数没有超过最大连接数。否则返回连接池已满类似的错误信息。超出最小连接数的这些连接，会被定期回收释放。\n　　初始化的同时，启动监控线程，用于定期检测连接是否正常连接。\n```cpp\ntemplate<typename T>\nint CommonDbConnPool<T>::InitPool( int minConn, int maxConn )\n{\n    ...\n    ...\n    for ( int i =0 ; i < minConn; i++ )\n    {\n        if( (t = createDBConn()) != nullptr )\n        {\n            if( (bConnectionAvilable(t)) )\n            {\n                m_poolMap[t] = DB_CONN_FREE;\n            }\n            else\n            {\n                releaseDBConn(t);\n            }\n        }\n    ...\n    ...\n    thread th(&CommonDbConnPool<T>::PoolConnMonitor, this);\n    swap(th, m_trdConnMonitor);\n｝\n```\n\n## 2.3 连接的管理\n　　存在与连接池中的连接有三种状态。空闲，占用和临时连接。\n```cpp\nenum DBCONNSTATS\n{\n    DB_CONN_FREE,\n    DB_CONN_USED,\n    DB_CONN_TEMP_USED\n\n};\n```\n\n　　最小连接数内的连接，初始化为free，占用时为used。而超过最小链接，并未超过最大连接数的这些连接为临时连接，定期会被回收。当然什么时候回收由你来定，我的是现实，当连接被用户释放回连接池时，直接回收。很多的数据库连接池对于临时连接处理会巧妙的多。比如超过最小链接后，扩容一倍等等。\n   **需要强调的一点是，为了保证多线程的安全访问，请记得加锁。**\n\n```cpp\ntemplate <typename T>\nT* CommonDbConnPool<T>::GetDBConnFromPool()\n{\n    ...\n    lock_guard<mutex> locker(m_mtxPool);\n    ...\n    for(auto &iter : m_poolMap)\n    {\n        if(iter.second == DB_CONN_FREE){\n            iter.second = DB_CONN_USED;\n            t = iter.first;\n            break;\n        }\n    }\n\n    if (t == nullptr){\n        if(m_poolMap.size() < m_maxConn)\n        {\n            if( (t = createDBConn()) != nullptr )\n            {\n                if( (bConnectionAvilable(t)) )\n                {\n                    m_poolMap[t] = DB_CONN_TEMP_USED;\n                }\n                else\n                {\n                    releaseDBConn(t);\n                }\n            }\n        }\n\n\n    }\n\n    return t;\n}\n\ntemplate <typename T>\nvoid CommonDbConnPool<T>::ReleaseDbConnToPool(T* t)\n{\n    lock_guard<mutex> locker(m_mtxPool);\n    for (auto &iter : m_poolMap)\n    {\n        if(iter.first == t)\n        {\n            if(iter.second == DB_CONN_USED)\n            {\n                iter.second = DB_CONN_FREE;\n            } else if (iter.second == DB_CONN_TEMP_USED)\n            {\n                releaseDBConn(iter.first);\n                m_poolMap.erase(iter.first);\n            }\n        }\n    }\n}\n```\n\n## 2.4 释放连接池\n　　释放连接也应该人性化，比如某个应用还在使用连接进行着访问，那我们不应该直接关闭该链接。\n　　我这里的处理是，关闭所有free的链接。并返回池内连接的大小。如果返回不为0，那么就相当于通知用户，连接并没有完全被释放，你还需要再次调用。\n   别忘了我们还有一个监控线程在运行着呢。别忘了结束线程。\n```cpp\ntemplate <typename T>\nvoid CommonDbConnPool<T>::PoolConnMonitor(){\n    ...\n    while(ptrPool->m_bPoolAvailable && ! ptrPool->m_bPoolToDestroy)\n    {\n        ...\n        [&](){\n            unique_lock<mutex> lk(ptrPool->m_mtxCv);\n            ptrPool->m_Cv.wait_for(lk, chrono::milliseconds(ptrPool->ulTimeForCheckTimeout()));\n        }();\n    ...\n    }\n}\n\n\ntemplate <typename T>\nint CommonDbConnPool<T>::DestroyPool(){\n    ...\n    for( auto &iter : m_poolMap)\n    {\n        if( iter.second == DB_CONN_FREE)\n        {\n            releaseDBConn(iter.first);\n            m_poolMap.erase(iter.first);\n        }\n    }\n    ...\n    ...\n    ptrPool->m_bPoolToDestroy = true;\n    m_Cv.notify_one();\n    m_trdConnMonitor.join();\n\n    ...\n    return m_poolMap.size();\n}\n\n```\n\n# 三、使用\n 　我这里使用了mysqlcppconn的库，如果需要请自行安装下载。\n ```cpp\n#include <iostream>\n#include \"./mysql/mysqlConn.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n\n    MysqlConn* mysqlpool;\n    try{\n\n        do{\n\n            //连接数据库\n            mysqlpool = new MysqlConn(\"localhost\", \"root\", \"Passw0rd\");\n\n            //创建数据库连接池，并返回大小\n            cout << \" mysqlpool size : \" << mysqlpool->InitPool(10,20) << endl;\n\n            sql::Connection *con;\n            sql::Statement* stmt;\n            sql::ResultSet* res;\n\n            //获取一个连接\n            if((con=mysqlpool->GetDBConnFromPool())==nullptr){\n                cout<<\"reach the max availd\" << endl;\n                break;\n            }\n\n            //执行语句\n            con->setSchema(\"mysql\");\n            stmt = con->createStatement();\n            res = stmt->executeQuery(\"select * from user\");\n\n            //打印数据库连接池信息\n            cout<<(*mysqlpool);\n\n            //释放连接到连接池\n            mysqlpool->ReleaseDbConnToPool(con);\n\n            //打印数据库连接池信息\n            cout<<(*mysqlpool);\n            cin.get();\n\n        } while(false);\n        //销毁数据库连接池\n        if(mysqlpool->DestroyPool()>0){\n            cout<<\"There are still some un-release connections in the pool\\n\";\n        }\n\n        delete mysqlpool;\n\n    }catch(sql::SQLException &e){\n        std::cout<<e.what();\n    }\n    return 0;\n}\n```\n","slug":"数据库连接池(c++)","published":1,"updated":"2016-12-19T08:55:37.869Z","layout":"post","photos":[],"link":"","_id":"cix1e5cfe000unvou3qv389rh","content":"<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p>　　对于每一次的数据库访问，都需要有一个承载该次访问操作的数据库连接。现在的应用系统往往伴随着大量的数据库访问。可想而知，如果频繁的建立和关闭链接，会极大的降低系统的性能。</p>\n<p>　　数据库连接池是针对数据库连接的性能优化而产生的。它的核心思想是连接复用，并通过连接池高效并安全的维护连接池内的连接，并按需分配到各个调用者，以减少重复创建和删除连接造成的系统资源浪费。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-1-源代码链接\"><a href=\"#1-1-源代码链接\" class=\"headerlink\" title=\"1.1 源代码链接\"></a>1.1 源代码链接</h2><p><a href=\"https://github.com/geeklenny/databaseConnPool\" target=\"_blank\" rel=\"external\">数据库连接池</a></p>\n<h1 id=\"二、源代码讲解\"><a href=\"#二、源代码讲解\" class=\"headerlink\" title=\"二、源代码讲解\"></a>二、源代码讲解</h1><p>　　希望你已经下载了源代码，这里开始对源代码进行讲解。这一份源代码我并没有做过多的性能测试，只是按照数据库连接池的基本思想和原理提供的一份实现。我希望这篇文章可以覆盖到数据库连接池的核心内容。</p>\n<h2 id=\"2-1-连接池只是连接池\"><a href=\"#2-1-连接池只是连接池\" class=\"headerlink\" title=\"2.1 连接池只是连接池\"></a>2.1 连接池只是连接池</h2><p>　　我们编写连接池的目的是用来维护连接，减少系统资源浪费。所以我们避免将连接池设计和实现成通用的带数据库连接优化的数据库访问类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">class</span> CommonDbConnPool&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>　　我们使用模板类来弱化数据库的具体类型，而更关系如何去维护其链接。对于具体的数据库操作，还是沿用使用的数据库提供的接口去访问。记住，数据库连接池只提供可用的连接，或者无可用连接时的错误提示。</p>\n<h2 id=\"2-2-连接的初始化\"><a href=\"#2-2-连接的初始化\" class=\"headerlink\" title=\"2.2　连接的初始化\"></a>2.2　连接的初始化</h2><p>　　提高数据库链接的初始化，核心的问题是启动多少连接合适。启动太少，不能满足应用的需求；启动太多，对系统资源也是一种浪费。实际上，在什么样配置的服务器上，启动多少个连接合适并没有一个明确的参考数据。它们都需要进行测试，调整到最优的连接数。<br>　　这里提供一个普遍适用于连接池的方法。它可以尽可能的保证系统资源的合理使用。这个方法是通常提供一个最小连接数和最大连接数。最小连接数为启动时默认启动的链接数目。如果最小连接数在被完全使用的时候，又进入一个新连接，那么连接池将为它新建一个连接。新建连接的前提是，连接总数没有超过最大连接数。否则返回连接池已满类似的错误信息。超出最小连接数的这些连接，会被定期回收释放。<br>　　初始化的同时，启动监控线程，用于定期检测连接是否正常连接。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">int</span> CommonDbConnPool&lt;T&gt;::InitPool( <span class=\"keyword\">int</span> minConn, <span class=\"keyword\">int</span> maxConn )</div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i =<span class=\"number\">0</span> ; i &lt; minConn; i++ )</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( (t = createDBConn()) != <span class=\"literal\">nullptr</span> )</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( (bConnectionAvilable(t)) )</div><div class=\"line\">            &#123;</div><div class=\"line\">                m_poolMap[t] = DB_CONN_FREE;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                releaseDBConn(t);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"function\">thread <span class=\"title\">th</span><span class=\"params\">(&amp;CommonDbConnPool&lt;T&gt;::PoolConnMonitor, <span class=\"keyword\">this</span>)</span></span>;</div><div class=\"line\">    swap(th, m_trdConnMonitor);</div><div class=\"line\">｝</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-连接的管理\"><a href=\"#2-3-连接的管理\" class=\"headerlink\" title=\"2.3 连接的管理\"></a>2.3 连接的管理</h2><p>　　存在与连接池中的连接有三种状态。空闲，占用和临时连接。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">enum</span> DBCONNSTATS</div><div class=\"line\">&#123;</div><div class=\"line\">    DB_CONN_FREE,</div><div class=\"line\">    DB_CONN_USED,</div><div class=\"line\">    DB_CONN_TEMP_USED</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>　　最小连接数内的连接，初始化为free，占用时为used。而超过最小链接，并未超过最大连接数的这些连接为临时连接，定期会被回收。当然什么时候回收由你来定，我的是现实，当连接被用户释放回连接池时，直接回收。很多的数据库连接池对于临时连接处理会巧妙的多。比如超过最小链接后，扩容一倍等等。<br>   <strong>需要强调的一点是，为了保证多线程的安全访问，请记得加锁。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">T* CommonDbConnPool&lt;T&gt;::GetDBConnFromPool()</div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    lock_guard&lt;mutex&gt; locker(m_mtxPool);</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;iter : m_poolMap)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(iter.second == DB_CONN_FREE)&#123;</div><div class=\"line\">            iter.second = DB_CONN_USED;</div><div class=\"line\">            t = iter.first;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"literal\">nullptr</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(m_poolMap.size() &lt; m_maxConn)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( (t = createDBConn()) != <span class=\"literal\">nullptr</span> )</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>( (bConnectionAvilable(t)) )</div><div class=\"line\">                &#123;</div><div class=\"line\">                    m_poolMap[t] = DB_CONN_TEMP_USED;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                &#123;</div><div class=\"line\">                    releaseDBConn(t);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> CommonDbConnPool&lt;T&gt;::ReleaseDbConnToPool(T* t)</div><div class=\"line\">&#123;</div><div class=\"line\">    lock_guard&lt;mutex&gt; locker(m_mtxPool);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;iter : m_poolMap)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(iter.first == t)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(iter.second == DB_CONN_USED)</div><div class=\"line\">            &#123;</div><div class=\"line\">                iter.second = DB_CONN_FREE;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (iter.second == DB_CONN_TEMP_USED)</div><div class=\"line\">            &#123;</div><div class=\"line\">                releaseDBConn(iter.first);</div><div class=\"line\">                m_poolMap.erase(iter.first);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-4-释放连接池\"><a href=\"#2-4-释放连接池\" class=\"headerlink\" title=\"2.4 释放连接池\"></a>2.4 释放连接池</h2><p>　　释放连接也应该人性化，比如某个应用还在使用连接进行着访问，那我们不应该直接关闭该链接。<br>　　我这里的处理是，关闭所有free的链接。并返回池内连接的大小。如果返回不为0，那么就相当于通知用户，连接并没有完全被释放，你还需要再次调用。<br>   别忘了我们还有一个监控线程在运行着呢。别忘了结束线程。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> CommonDbConnPool&lt;T&gt;::PoolConnMonitor()&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">while</span>(ptrPool-&gt;m_bPoolAvailable &amp;&amp; ! ptrPool-&gt;m_bPoolToDestroy)</div><div class=\"line\">    &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        [&amp;]()&#123;</div><div class=\"line\">            unique_lock&lt;mutex&gt; lk(ptrPool-&gt;m_mtxCv);</div><div class=\"line\">            ptrPool-&gt;m_Cv.wait_for(lk, chrono::milliseconds(ptrPool-&gt;ulTimeForCheckTimeout()));</div><div class=\"line\">        &#125;();</div><div class=\"line\">    ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">int</span> CommonDbConnPool&lt;T&gt;::DestroyPool()&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">auto</span> &amp;iter : m_poolMap)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( iter.second == DB_CONN_FREE)</div><div class=\"line\">        &#123;</div><div class=\"line\">            releaseDBConn(iter.first);</div><div class=\"line\">            m_poolMap.erase(iter.first);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    ptrPool-&gt;m_bPoolToDestroy = <span class=\"literal\">true</span>;</div><div class=\"line\">    m_Cv.notify_one();</div><div class=\"line\">    m_trdConnMonitor.join();</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> m_poolMap.size();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"三、使用\"><a href=\"#三、使用\" class=\"headerlink\" title=\"三、使用\"></a>三、使用</h1><p> 　我这里使用了mysqlcppconn的库，如果需要请自行安装下载。<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"./mysql/mysqlConn.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    MysqlConn* mysqlpool;</div><div class=\"line\">    <span class=\"keyword\">try</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">do</span>&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//连接数据库</span></div><div class=\"line\">            mysqlpool = <span class=\"keyword\">new</span> MysqlConn(<span class=\"string\">\"localhost\"</span>, <span class=\"string\">\"root\"</span>, <span class=\"string\">\"Passw0rd\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//创建数据库连接池，并返回大小</span></div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" mysqlpool size : \"</span> &lt;&lt; mysqlpool-&gt;InitPool(<span class=\"number\">10</span>,<span class=\"number\">20</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">            sql::Connection *con;</div><div class=\"line\">            sql::Statement* stmt;</div><div class=\"line\">            sql::ResultSet* res;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//获取一个连接</span></div><div class=\"line\">            <span class=\"keyword\">if</span>((con=mysqlpool-&gt;GetDBConnFromPool())==<span class=\"literal\">nullptr</span>)&#123;</div><div class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"reach the max availd\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//执行语句</span></div><div class=\"line\">            con-&gt;setSchema(<span class=\"string\">\"mysql\"</span>);</div><div class=\"line\">            stmt = con-&gt;createStatement();</div><div class=\"line\">            res = stmt-&gt;executeQuery(<span class=\"string\">\"select * from user\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//打印数据库连接池信息</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;(*mysqlpool);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//释放连接到连接池</span></div><div class=\"line\">            mysqlpool-&gt;ReleaseDbConnToPool(con);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//打印数据库连接池信息</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;(*mysqlpool);</div><div class=\"line\">            <span class=\"built_in\">cin</span>.get();</div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">while</span>(<span class=\"literal\">false</span>);</div><div class=\"line\">        <span class=\"comment\">//销毁数据库连接池</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(mysqlpool-&gt;DestroyPool()&gt;<span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"There are still some un-release connections in the pool\\n\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">delete</span> mysqlpool;</div><div class=\"line\"></div><div class=\"line\">    &#125;<span class=\"keyword\">catch</span>(sql::SQLException &amp;e)&#123;</div><div class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;e.what();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h1><p>　　对于每一次的数据库访问，都需要有一个承载该次访问操作的数据库连接。现在的应用系统往往伴随着大量的数据库访问。可想而知，如果频繁的建立和关闭链接，会极大的降低系统的性能。</p>\n<p>　　数据库连接池是针对数据库连接的性能优化而产生的。它的核心思想是连接复用，并通过连接池高效并安全的维护连接池内的连接，并按需分配到各个调用者，以减少重复创建和删除连接造成的系统资源浪费。</p>","more":"<h2 id=\"1-1-源代码链接\"><a href=\"#1-1-源代码链接\" class=\"headerlink\" title=\"1.1 源代码链接\"></a>1.1 源代码链接</h2><p><a href=\"https://github.com/geeklenny/databaseConnPool\">数据库连接池</a></p>\n<h1 id=\"二、源代码讲解\"><a href=\"#二、源代码讲解\" class=\"headerlink\" title=\"二、源代码讲解\"></a>二、源代码讲解</h1><p>　　希望你已经下载了源代码，这里开始对源代码进行讲解。这一份源代码我并没有做过多的性能测试，只是按照数据库连接池的基本思想和原理提供的一份实现。我希望这篇文章可以覆盖到数据库连接池的核心内容。</p>\n<h2 id=\"2-1-连接池只是连接池\"><a href=\"#2-1-连接池只是连接池\" class=\"headerlink\" title=\"2.1 连接池只是连接池\"></a>2.1 连接池只是连接池</h2><p>　　我们编写连接池的目的是用来维护连接，减少系统资源浪费。所以我们避免将连接池设计和实现成通用的带数据库连接优化的数据库访问类。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">class</span> CommonDbConnPool&#123;...&#125;</div></pre></td></tr></table></figure>\n<p>　　我们使用模板类来弱化数据库的具体类型，而更关系如何去维护其链接。对于具体的数据库操作，还是沿用使用的数据库提供的接口去访问。记住，数据库连接池只提供可用的连接，或者无可用连接时的错误提示。</p>\n<h2 id=\"2-2-连接的初始化\"><a href=\"#2-2-连接的初始化\" class=\"headerlink\" title=\"2.2　连接的初始化\"></a>2.2　连接的初始化</h2><p>　　提高数据库链接的初始化，核心的问题是启动多少连接合适。启动太少，不能满足应用的需求；启动太多，对系统资源也是一种浪费。实际上，在什么样配置的服务器上，启动多少个连接合适并没有一个明确的参考数据。它们都需要进行测试，调整到最优的连接数。<br>　　这里提供一个普遍适用于连接池的方法。它可以尽可能的保证系统资源的合理使用。这个方法是通常提供一个最小连接数和最大连接数。最小连接数为启动时默认启动的链接数目。如果最小连接数在被完全使用的时候，又进入一个新连接，那么连接池将为它新建一个连接。新建连接的前提是，连接总数没有超过最大连接数。否则返回连接池已满类似的错误信息。超出最小连接数的这些连接，会被定期回收释放。<br>　　初始化的同时，启动监控线程，用于定期检测连接是否正常连接。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">int</span> CommonDbConnPool&lt;T&gt;::InitPool( <span class=\"keyword\">int</span> minConn, <span class=\"keyword\">int</span> maxConn )</div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span> ( <span class=\"keyword\">int</span> i =<span class=\"number\">0</span> ; i &lt; minConn; i++ )</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( (t = createDBConn()) != <span class=\"literal\">nullptr</span> )</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( (bConnectionAvilable(t)) )</div><div class=\"line\">            &#123;</div><div class=\"line\">                m_poolMap[t] = DB_CONN_FREE;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">else</span></div><div class=\"line\">            &#123;</div><div class=\"line\">                releaseDBConn(t);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"function\">thread <span class=\"title\">th</span><span class=\"params\">(&amp;CommonDbConnPool&lt;T&gt;::PoolConnMonitor, <span class=\"keyword\">this</span>)</span></span>;</div><div class=\"line\">    swap(th, m_trdConnMonitor);</div><div class=\"line\">｝</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-3-连接的管理\"><a href=\"#2-3-连接的管理\" class=\"headerlink\" title=\"2.3 连接的管理\"></a>2.3 连接的管理</h2><p>　　存在与连接池中的连接有三种状态。空闲，占用和临时连接。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">enum</span> DBCONNSTATS</div><div class=\"line\">&#123;</div><div class=\"line\">    DB_CONN_FREE,</div><div class=\"line\">    DB_CONN_USED,</div><div class=\"line\">    DB_CONN_TEMP_USED</div><div class=\"line\"></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>　　最小连接数内的连接，初始化为free，占用时为used。而超过最小链接，并未超过最大连接数的这些连接为临时连接，定期会被回收。当然什么时候回收由你来定，我的是现实，当连接被用户释放回连接池时，直接回收。很多的数据库连接池对于临时连接处理会巧妙的多。比如超过最小链接后，扩容一倍等等。<br>   <strong>需要强调的一点是，为了保证多线程的安全访问，请记得加锁。</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\">T* CommonDbConnPool&lt;T&gt;::GetDBConnFromPool()</div><div class=\"line\">&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    lock_guard&lt;mutex&gt; locker(m_mtxPool);</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;iter : m_poolMap)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(iter.second == DB_CONN_FREE)&#123;</div><div class=\"line\">            iter.second = DB_CONN_USED;</div><div class=\"line\">            t = iter.first;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"literal\">nullptr</span>)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(m_poolMap.size() &lt; m_maxConn)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>( (t = createDBConn()) != <span class=\"literal\">nullptr</span> )</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span>( (bConnectionAvilable(t)) )</div><div class=\"line\">                &#123;</div><div class=\"line\">                    m_poolMap[t] = DB_CONN_TEMP_USED;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                &#123;</div><div class=\"line\">                    releaseDBConn(t);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> t;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> CommonDbConnPool&lt;T&gt;::ReleaseDbConnToPool(T* t)</div><div class=\"line\">&#123;</div><div class=\"line\">    lock_guard&lt;mutex&gt; locker(m_mtxPool);</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;iter : m_poolMap)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(iter.first == t)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(iter.second == DB_CONN_USED)</div><div class=\"line\">            &#123;</div><div class=\"line\">                iter.second = DB_CONN_FREE;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (iter.second == DB_CONN_TEMP_USED)</div><div class=\"line\">            &#123;</div><div class=\"line\">                releaseDBConn(iter.first);</div><div class=\"line\">                m_poolMap.erase(iter.first);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"2-4-释放连接池\"><a href=\"#2-4-释放连接池\" class=\"headerlink\" title=\"2.4 释放连接池\"></a>2.4 释放连接池</h2><p>　　释放连接也应该人性化，比如某个应用还在使用连接进行着访问，那我们不应该直接关闭该链接。<br>　　我这里的处理是，关闭所有free的链接。并返回池内连接的大小。如果返回不为0，那么就相当于通知用户，连接并没有完全被释放，你还需要再次调用。<br>   别忘了我们还有一个监控线程在运行着呢。别忘了结束线程。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">void</span> CommonDbConnPool&lt;T&gt;::PoolConnMonitor()&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">while</span>(ptrPool-&gt;m_bPoolAvailable &amp;&amp; ! ptrPool-&gt;m_bPoolToDestroy)</div><div class=\"line\">    &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        [&amp;]()&#123;</div><div class=\"line\">            unique_lock&lt;mutex&gt; lk(ptrPool-&gt;m_mtxCv);</div><div class=\"line\">            ptrPool-&gt;m_Cv.wait_for(lk, chrono::milliseconds(ptrPool-&gt;ulTimeForCheckTimeout()));</div><div class=\"line\">        &#125;();</div><div class=\"line\">    ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</div><div class=\"line\"><span class=\"keyword\">int</span> CommonDbConnPool&lt;T&gt;::DestroyPool()&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">for</span>( <span class=\"keyword\">auto</span> &amp;iter : m_poolMap)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>( iter.second == DB_CONN_FREE)</div><div class=\"line\">        &#123;</div><div class=\"line\">            releaseDBConn(iter.first);</div><div class=\"line\">            m_poolMap.erase(iter.first);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">    ...</div><div class=\"line\">    ptrPool-&gt;m_bPoolToDestroy = <span class=\"literal\">true</span>;</div><div class=\"line\">    m_Cv.notify_one();</div><div class=\"line\">    m_trdConnMonitor.join();</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> m_poolMap.size();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"三、使用\"><a href=\"#三、使用\" class=\"headerlink\" title=\"三、使用\"></a>三、使用</h1><p> 　我这里使用了mysqlcppconn的库，如果需要请自行安装下载。<br> <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"./mysql/mysqlConn.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    MysqlConn* mysqlpool;</div><div class=\"line\">    <span class=\"keyword\">try</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">do</span>&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//连接数据库</span></div><div class=\"line\">            mysqlpool = <span class=\"keyword\">new</span> MysqlConn(<span class=\"string\">\"localhost\"</span>, <span class=\"string\">\"root\"</span>, <span class=\"string\">\"Passw0rd\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//创建数据库连接池，并返回大小</span></div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" mysqlpool size : \"</span> &lt;&lt; mysqlpool-&gt;InitPool(<span class=\"number\">10</span>,<span class=\"number\">20</span>) &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\">            sql::Connection *con;</div><div class=\"line\">            sql::Statement* stmt;</div><div class=\"line\">            sql::ResultSet* res;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//获取一个连接</span></div><div class=\"line\">            <span class=\"keyword\">if</span>((con=mysqlpool-&gt;GetDBConnFromPool())==<span class=\"literal\">nullptr</span>)&#123;</div><div class=\"line\">                <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"reach the max availd\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//执行语句</span></div><div class=\"line\">            con-&gt;setSchema(<span class=\"string\">\"mysql\"</span>);</div><div class=\"line\">            stmt = con-&gt;createStatement();</div><div class=\"line\">            res = stmt-&gt;executeQuery(<span class=\"string\">\"select * from user\"</span>);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//打印数据库连接池信息</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;(*mysqlpool);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//释放连接到连接池</span></div><div class=\"line\">            mysqlpool-&gt;ReleaseDbConnToPool(con);</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">//打印数据库连接池信息</span></div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;(*mysqlpool);</div><div class=\"line\">            <span class=\"built_in\">cin</span>.get();</div><div class=\"line\"></div><div class=\"line\">        &#125; <span class=\"keyword\">while</span>(<span class=\"literal\">false</span>);</div><div class=\"line\">        <span class=\"comment\">//销毁数据库连接池</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(mysqlpool-&gt;DestroyPool()&gt;<span class=\"number\">0</span>)&#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"There are still some un-release connections in the pool\\n\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">delete</span> mysqlpool;</div><div class=\"line\"></div><div class=\"line\">    &#125;<span class=\"keyword\">catch</span>(sql::SQLException &amp;e)&#123;</div><div class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>&lt;&lt;e.what();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"算法导论--分治策略","comments":0,"date":"2016-12-12T02:09:14.000Z","_content":"\n# 概述\n　　算法中有两个非常重要的思想分别是：分治策略和动态规划。它们通常可以将处理复杂的问题，转化为处理Ｎ个相关的子问题。通过这种方式，给予人们清晰的思路的同时，降低处理问题的难度。这一篇文章我们来介绍分治策略，并给出几个经典的算法来进行展示。\n\n# 简介\n　　分治策略中，往往是通过递归去求解问题，并在每层递归中应用如下三个步骤:\n1. 分解:将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。\n2. 解决:递归的求解子问题，如果子问题的规模足够小，则停止递归，直接求解。\n3. 合并:讲子问题的解组合成原问题的解。\n\n<!--more-->\n\n# 算法举例\n　　在上一篇文章里，我们看到的归并排序其实使用的就是分治思想。这里我们再列举两个常用的，并且使用分治思想的算法:堆排序和快速排序。\n## 堆排序\n　　堆排序的时间复杂度为O(nlogn)，并且所需的额外存储数量固定。堆通常使用数组进行存储，它可以被看成一个近似的完全二叉树，它的每一个节点对应着数组中的一个元素。接下来我们试着去实现堆排序。\n　　首先我们来理解一下最大堆。如果按照刚才我们所提到的，将堆看做成二叉树。那么如果是最大堆，其特点是A[PARENT(i)]>=A[i]。这个公示代表着，任何一个节点不大于其父节点。这里我们用伪代码表示一下父节点和左右子节点的关系。\n```\nPARENT(i)\n        return [i/2]\nLEFT(i)\n        return 2i\nRIGHT(i)\n        return 2i+1\n```\n　　接下来我们讨论一下堆排序算法。堆排序的一个重要环节是调节堆。详细的说，比如我们目标是构建最大堆，在Ｎ个节点的树中总会有不满足最大堆要求的父子节点关系，那么我们就要进行调整。\n　　堆排序的第一个环节就是构建最大堆。这里我们假设某个节点的两个子节点都已经是最大树的根节点，在这种情况下，再对该节点进行调整是最容易的。所以我们构建最大堆的思路是先讲子树构建成最大堆，然后开始父节点构建。这样我们将会完成最大堆的构造。然而，这里大家一定要注意，最大堆构建完成并不代表着数组已经排序完成。比如(16,14,10,8,7,9,3)就是最大堆，但是并不是有序的。它只保证了其父节点不小于该节点。\n　　最后我们来完成排序工作。具体的步骤就是，讲根节点与最后一个节点交换，并从树种去除，然后对树进行调整。不断的迭代这个过程，完成最终的排序工作。\n　　这里开始为自己的表达能力感到捉急。我们还是来看伪代码吧。\n```\n//第一步，调整堆\nMAX-HEAPIFY(A,i)\n        l = LEFT(i)\n        r = RIGHT(i)\n        largest = i\n        if l <= heapsize and A[l] > A[i]\n                largest = l\n        if r <= heapsize and A[r] > A[i]\n                largest = r\n        if largest != i\n                exchange(A[i],a[largest])\n                MAX-HEAPIFY(A,largest)\n```\n　　第一步，通过递归来调整以i为根节点的子树为最大堆。以此为基础，我们讲堆从子节点向上遍历，不断地调整子树为最大树来完成最大堆的构建。\n```\n//第二步，构建最大堆\nBUILD-MAX-HEAP(A)\n        A.heapsize = A.length\n        for i = [A.length/2] downto 1\n                MAX-HEAPIFY(A,i)\n```\n　　在完成最大堆的构建之后，我们已经完成了堆排序最核心的两个步骤，那么我们现在完成堆排序。\n```\n//堆排序\nHEAP-SORT(A)\n        BUILD-MAX-HEAP(A)\n        for i = A.length downto 2\n                exchange A[i] with a[i]\n                A.heapsize = A.heapsize-1\n                MAX-HEAPIFY(A,1)\n```\n  　锵锵锵锵，堆排序完成。\n\n## 快速排序\n　　另一个使用分治思想的常用算法就是快速排序。快速排序的期望时间复杂度是O(nlogn)。但是最坏情况的时间复杂度又O(n*n)。虽然看起来最坏情况的时间复杂度很差，但是实际排序应用中它往往是最好的选择，因为它的平均性很好，而且O(nlogn)的常数因子非常小。\n　　快速排序的三步分治过程:\n1. 分解:　将数组A[p..r]，以A[q]为界换分为两个子数组，子数组可以为空,q可以自由选择。使得A[p..q-1]中的元素都小于A[q],A[q+1..r]中的元素都大于A[q]。\n2. 解决:　通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序\n3. 合并: 因为子数组都是原址排序，所以不需要合并操作:数组A[p..r]已经有序\n\n　　来看具体的伪代码实现:\n```\nPARTITION(A,p,r)\n        x = A[r]\n        i = p - 1\n        for j = p to r - 1\n                if A[j] <= x\n                        i = i + 1\n                        exchange A[i] with A[j]\n        exchage A[i+1] with A[r]\n        return i + 1\n```\n　　在快速排序中，PARTITION是非常关键的部分，它的作用有两个，第一个是选定界限值q，第二个就是对输入数组进行原址重排。\n```\nQUICKSORT(A,p,r)\n        if p < r\n                q = PARTITION(A,p,r)\n                QUICKSORT(A,p,q-1)\n                QUICKSORT(A,q+1,r)\n```\n　　快速排序完成\n","source":"_posts/算法导论-分治策略.md","raw":"---\ntitle: 算法导论--分治策略\ncomments: false\ndate: 2016-12-12 10:09:14\ntags:\n  - 读书笔记\n  - 算法导论\n  - 分治策略\n  - 快速排序\n  - 堆排序\ncategories:\n  - 读书笔记\n  - 算法导论\n---\n\n# 概述\n　　算法中有两个非常重要的思想分别是：分治策略和动态规划。它们通常可以将处理复杂的问题，转化为处理Ｎ个相关的子问题。通过这种方式，给予人们清晰的思路的同时，降低处理问题的难度。这一篇文章我们来介绍分治策略，并给出几个经典的算法来进行展示。\n\n# 简介\n　　分治策略中，往往是通过递归去求解问题，并在每层递归中应用如下三个步骤:\n1. 分解:将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。\n2. 解决:递归的求解子问题，如果子问题的规模足够小，则停止递归，直接求解。\n3. 合并:讲子问题的解组合成原问题的解。\n\n<!--more-->\n\n# 算法举例\n　　在上一篇文章里，我们看到的归并排序其实使用的就是分治思想。这里我们再列举两个常用的，并且使用分治思想的算法:堆排序和快速排序。\n## 堆排序\n　　堆排序的时间复杂度为O(nlogn)，并且所需的额外存储数量固定。堆通常使用数组进行存储，它可以被看成一个近似的完全二叉树，它的每一个节点对应着数组中的一个元素。接下来我们试着去实现堆排序。\n　　首先我们来理解一下最大堆。如果按照刚才我们所提到的，将堆看做成二叉树。那么如果是最大堆，其特点是A[PARENT(i)]>=A[i]。这个公示代表着，任何一个节点不大于其父节点。这里我们用伪代码表示一下父节点和左右子节点的关系。\n```\nPARENT(i)\n        return [i/2]\nLEFT(i)\n        return 2i\nRIGHT(i)\n        return 2i+1\n```\n　　接下来我们讨论一下堆排序算法。堆排序的一个重要环节是调节堆。详细的说，比如我们目标是构建最大堆，在Ｎ个节点的树中总会有不满足最大堆要求的父子节点关系，那么我们就要进行调整。\n　　堆排序的第一个环节就是构建最大堆。这里我们假设某个节点的两个子节点都已经是最大树的根节点，在这种情况下，再对该节点进行调整是最容易的。所以我们构建最大堆的思路是先讲子树构建成最大堆，然后开始父节点构建。这样我们将会完成最大堆的构造。然而，这里大家一定要注意，最大堆构建完成并不代表着数组已经排序完成。比如(16,14,10,8,7,9,3)就是最大堆，但是并不是有序的。它只保证了其父节点不小于该节点。\n　　最后我们来完成排序工作。具体的步骤就是，讲根节点与最后一个节点交换，并从树种去除，然后对树进行调整。不断的迭代这个过程，完成最终的排序工作。\n　　这里开始为自己的表达能力感到捉急。我们还是来看伪代码吧。\n```\n//第一步，调整堆\nMAX-HEAPIFY(A,i)\n        l = LEFT(i)\n        r = RIGHT(i)\n        largest = i\n        if l <= heapsize and A[l] > A[i]\n                largest = l\n        if r <= heapsize and A[r] > A[i]\n                largest = r\n        if largest != i\n                exchange(A[i],a[largest])\n                MAX-HEAPIFY(A,largest)\n```\n　　第一步，通过递归来调整以i为根节点的子树为最大堆。以此为基础，我们讲堆从子节点向上遍历，不断地调整子树为最大树来完成最大堆的构建。\n```\n//第二步，构建最大堆\nBUILD-MAX-HEAP(A)\n        A.heapsize = A.length\n        for i = [A.length/2] downto 1\n                MAX-HEAPIFY(A,i)\n```\n　　在完成最大堆的构建之后，我们已经完成了堆排序最核心的两个步骤，那么我们现在完成堆排序。\n```\n//堆排序\nHEAP-SORT(A)\n        BUILD-MAX-HEAP(A)\n        for i = A.length downto 2\n                exchange A[i] with a[i]\n                A.heapsize = A.heapsize-1\n                MAX-HEAPIFY(A,1)\n```\n  　锵锵锵锵，堆排序完成。\n\n## 快速排序\n　　另一个使用分治思想的常用算法就是快速排序。快速排序的期望时间复杂度是O(nlogn)。但是最坏情况的时间复杂度又O(n*n)。虽然看起来最坏情况的时间复杂度很差，但是实际排序应用中它往往是最好的选择，因为它的平均性很好，而且O(nlogn)的常数因子非常小。\n　　快速排序的三步分治过程:\n1. 分解:　将数组A[p..r]，以A[q]为界换分为两个子数组，子数组可以为空,q可以自由选择。使得A[p..q-1]中的元素都小于A[q],A[q+1..r]中的元素都大于A[q]。\n2. 解决:　通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序\n3. 合并: 因为子数组都是原址排序，所以不需要合并操作:数组A[p..r]已经有序\n\n　　来看具体的伪代码实现:\n```\nPARTITION(A,p,r)\n        x = A[r]\n        i = p - 1\n        for j = p to r - 1\n                if A[j] <= x\n                        i = i + 1\n                        exchange A[i] with A[j]\n        exchage A[i+1] with A[r]\n        return i + 1\n```\n　　在快速排序中，PARTITION是非常关键的部分，它的作用有两个，第一个是选定界限值q，第二个就是对输入数组进行原址重排。\n```\nQUICKSORT(A,p,r)\n        if p < r\n                q = PARTITION(A,p,r)\n                QUICKSORT(A,p,q-1)\n                QUICKSORT(A,q+1,r)\n```\n　　快速排序完成\n","slug":"算法导论-分治策略","published":1,"updated":"2016-12-14T00:51:53.498Z","layout":"post","photos":[],"link":"","_id":"cix1e5cfh000xnvouo12nom3e","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>　　算法中有两个非常重要的思想分别是：分治策略和动态规划。它们通常可以将处理复杂的问题，转化为处理Ｎ个相关的子问题。通过这种方式，给予人们清晰的思路的同时，降低处理问题的难度。这一篇文章我们来介绍分治策略，并给出几个经典的算法来进行展示。</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>　　分治策略中，往往是通过递归去求解问题，并在每层递归中应用如下三个步骤:</p>\n<ol>\n<li>分解:将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>\n<li>解决:递归的求解子问题，如果子问题的规模足够小，则停止递归，直接求解。</li>\n<li>合并:讲子问题的解组合成原问题的解。</li>\n</ol>\n<a id=\"more\"></a>\n<h1 id=\"算法举例\"><a href=\"#算法举例\" class=\"headerlink\" title=\"算法举例\"></a>算法举例</h1><p>　　在上一篇文章里，我们看到的归并排序其实使用的就是分治思想。这里我们再列举两个常用的，并且使用分治思想的算法:堆排序和快速排序。</p>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>　　堆排序的时间复杂度为O(nlogn)，并且所需的额外存储数量固定。堆通常使用数组进行存储，它可以被看成一个近似的完全二叉树，它的每一个节点对应着数组中的一个元素。接下来我们试着去实现堆排序。<br>　　首先我们来理解一下最大堆。如果按照刚才我们所提到的，将堆看做成二叉树。那么如果是最大堆，其特点是A[PARENT(i)]&gt;=A[i]。这个公示代表着，任何一个节点不大于其父节点。这里我们用伪代码表示一下父节点和左右子节点的关系。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PARENT(i)</div><div class=\"line\">        return [i/2]</div><div class=\"line\">LEFT(i)</div><div class=\"line\">        return 2i</div><div class=\"line\">RIGHT(i)</div><div class=\"line\">        return 2i+1</div></pre></td></tr></table></figure></p>\n<p>　　接下来我们讨论一下堆排序算法。堆排序的一个重要环节是调节堆。详细的说，比如我们目标是构建最大堆，在Ｎ个节点的树中总会有不满足最大堆要求的父子节点关系，那么我们就要进行调整。<br>　　堆排序的第一个环节就是构建最大堆。这里我们假设某个节点的两个子节点都已经是最大树的根节点，在这种情况下，再对该节点进行调整是最容易的。所以我们构建最大堆的思路是先讲子树构建成最大堆，然后开始父节点构建。这样我们将会完成最大堆的构造。然而，这里大家一定要注意，最大堆构建完成并不代表着数组已经排序完成。比如(16,14,10,8,7,9,3)就是最大堆，但是并不是有序的。它只保证了其父节点不小于该节点。<br>　　最后我们来完成排序工作。具体的步骤就是，讲根节点与最后一个节点交换，并从树种去除，然后对树进行调整。不断的迭代这个过程，完成最终的排序工作。<br>　　这里开始为自己的表达能力感到捉急。我们还是来看伪代码吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一步，调整堆</div><div class=\"line\">MAX-HEAPIFY(A,i)</div><div class=\"line\">        l = LEFT(i)</div><div class=\"line\">        r = RIGHT(i)</div><div class=\"line\">        largest = i</div><div class=\"line\">        if l &lt;= heapsize and A[l] &gt; A[i]</div><div class=\"line\">                largest = l</div><div class=\"line\">        if r &lt;= heapsize and A[r] &gt; A[i]</div><div class=\"line\">                largest = r</div><div class=\"line\">        if largest != i</div><div class=\"line\">                exchange(A[i],a[largest])</div><div class=\"line\">                MAX-HEAPIFY(A,largest)</div></pre></td></tr></table></figure></p>\n<p>　　第一步，通过递归来调整以i为根节点的子树为最大堆。以此为基础，我们讲堆从子节点向上遍历，不断地调整子树为最大树来完成最大堆的构建。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第二步，构建最大堆</div><div class=\"line\">BUILD-MAX-HEAP(A)</div><div class=\"line\">        A.heapsize = A.length</div><div class=\"line\">        for i = [A.length/2] downto 1</div><div class=\"line\">                MAX-HEAPIFY(A,i)</div></pre></td></tr></table></figure></p>\n<p>　　在完成最大堆的构建之后，我们已经完成了堆排序最核心的两个步骤，那么我们现在完成堆排序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//堆排序</div><div class=\"line\">HEAP-SORT(A)</div><div class=\"line\">        BUILD-MAX-HEAP(A)</div><div class=\"line\">        for i = A.length downto 2</div><div class=\"line\">                exchange A[i] with a[i]</div><div class=\"line\">                A.heapsize = A.heapsize-1</div><div class=\"line\">                MAX-HEAPIFY(A,1)</div></pre></td></tr></table></figure></p>\n<p>  　锵锵锵锵，堆排序完成。</p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>　　另一个使用分治思想的常用算法就是快速排序。快速排序的期望时间复杂度是O(nlogn)。但是最坏情况的时间复杂度又O(n*n)。虽然看起来最坏情况的时间复杂度很差，但是实际排序应用中它往往是最好的选择，因为它的平均性很好，而且O(nlogn)的常数因子非常小。<br>　　快速排序的三步分治过程:</p>\n<ol>\n<li>分解:　将数组A[p..r]，以A[q]为界换分为两个子数组，子数组可以为空,q可以自由选择。使得A[p..q-1]中的元素都小于A[q],A[q+1..r]中的元素都大于A[q]。</li>\n<li>解决:　通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序</li>\n<li>合并: 因为子数组都是原址排序，所以不需要合并操作:数组A[p..r]已经有序</li>\n</ol>\n<p>　　来看具体的伪代码实现:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">PARTITION(A,p,r)</div><div class=\"line\">        x = A[r]</div><div class=\"line\">        i = p - 1</div><div class=\"line\">        for j = p to r - 1</div><div class=\"line\">                if A[j] &lt;= x</div><div class=\"line\">                        i = i + 1</div><div class=\"line\">                        exchange A[i] with A[j]</div><div class=\"line\">        exchage A[i+1] with A[r]</div><div class=\"line\">        return i + 1</div></pre></td></tr></table></figure></p>\n<p>　　在快速排序中，PARTITION是非常关键的部分，它的作用有两个，第一个是选定界限值q，第二个就是对输入数组进行原址重排。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">QUICKSORT(A,p,r)</div><div class=\"line\">        if p &lt; r</div><div class=\"line\">                q = PARTITION(A,p,r)</div><div class=\"line\">                QUICKSORT(A,p,q-1)</div><div class=\"line\">                QUICKSORT(A,q+1,r)</div></pre></td></tr></table></figure></p>\n<p>　　快速排序完成</p>\n","excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>　　算法中有两个非常重要的思想分别是：分治策略和动态规划。它们通常可以将处理复杂的问题，转化为处理Ｎ个相关的子问题。通过这种方式，给予人们清晰的思路的同时，降低处理问题的难度。这一篇文章我们来介绍分治策略，并给出几个经典的算法来进行展示。</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>　　分治策略中，往往是通过递归去求解问题，并在每层递归中应用如下三个步骤:</p>\n<ol>\n<li>分解:将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。</li>\n<li>解决:递归的求解子问题，如果子问题的规模足够小，则停止递归，直接求解。</li>\n<li>合并:讲子问题的解组合成原问题的解。</li>\n</ol>","more":"<h1 id=\"算法举例\"><a href=\"#算法举例\" class=\"headerlink\" title=\"算法举例\"></a>算法举例</h1><p>　　在上一篇文章里，我们看到的归并排序其实使用的就是分治思想。这里我们再列举两个常用的，并且使用分治思想的算法:堆排序和快速排序。</p>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>　　堆排序的时间复杂度为O(nlogn)，并且所需的额外存储数量固定。堆通常使用数组进行存储，它可以被看成一个近似的完全二叉树，它的每一个节点对应着数组中的一个元素。接下来我们试着去实现堆排序。<br>　　首先我们来理解一下最大堆。如果按照刚才我们所提到的，将堆看做成二叉树。那么如果是最大堆，其特点是A[PARENT(i)]&gt;=A[i]。这个公示代表着，任何一个节点不大于其父节点。这里我们用伪代码表示一下父节点和左右子节点的关系。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PARENT(i)</div><div class=\"line\">        return [i/2]</div><div class=\"line\">LEFT(i)</div><div class=\"line\">        return 2i</div><div class=\"line\">RIGHT(i)</div><div class=\"line\">        return 2i+1</div></pre></td></tr></table></figure></p>\n<p>　　接下来我们讨论一下堆排序算法。堆排序的一个重要环节是调节堆。详细的说，比如我们目标是构建最大堆，在Ｎ个节点的树中总会有不满足最大堆要求的父子节点关系，那么我们就要进行调整。<br>　　堆排序的第一个环节就是构建最大堆。这里我们假设某个节点的两个子节点都已经是最大树的根节点，在这种情况下，再对该节点进行调整是最容易的。所以我们构建最大堆的思路是先讲子树构建成最大堆，然后开始父节点构建。这样我们将会完成最大堆的构造。然而，这里大家一定要注意，最大堆构建完成并不代表着数组已经排序完成。比如(16,14,10,8,7,9,3)就是最大堆，但是并不是有序的。它只保证了其父节点不小于该节点。<br>　　最后我们来完成排序工作。具体的步骤就是，讲根节点与最后一个节点交换，并从树种去除，然后对树进行调整。不断的迭代这个过程，完成最终的排序工作。<br>　　这里开始为自己的表达能力感到捉急。我们还是来看伪代码吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第一步，调整堆</div><div class=\"line\">MAX-HEAPIFY(A,i)</div><div class=\"line\">        l = LEFT(i)</div><div class=\"line\">        r = RIGHT(i)</div><div class=\"line\">        largest = i</div><div class=\"line\">        if l &lt;= heapsize and A[l] &gt; A[i]</div><div class=\"line\">                largest = l</div><div class=\"line\">        if r &lt;= heapsize and A[r] &gt; A[i]</div><div class=\"line\">                largest = r</div><div class=\"line\">        if largest != i</div><div class=\"line\">                exchange(A[i],a[largest])</div><div class=\"line\">                MAX-HEAPIFY(A,largest)</div></pre></td></tr></table></figure></p>\n<p>　　第一步，通过递归来调整以i为根节点的子树为最大堆。以此为基础，我们讲堆从子节点向上遍历，不断地调整子树为最大树来完成最大堆的构建。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//第二步，构建最大堆</div><div class=\"line\">BUILD-MAX-HEAP(A)</div><div class=\"line\">        A.heapsize = A.length</div><div class=\"line\">        for i = [A.length/2] downto 1</div><div class=\"line\">                MAX-HEAPIFY(A,i)</div></pre></td></tr></table></figure></p>\n<p>　　在完成最大堆的构建之后，我们已经完成了堆排序最核心的两个步骤，那么我们现在完成堆排序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//堆排序</div><div class=\"line\">HEAP-SORT(A)</div><div class=\"line\">        BUILD-MAX-HEAP(A)</div><div class=\"line\">        for i = A.length downto 2</div><div class=\"line\">                exchange A[i] with a[i]</div><div class=\"line\">                A.heapsize = A.heapsize-1</div><div class=\"line\">                MAX-HEAPIFY(A,1)</div></pre></td></tr></table></figure></p>\n<p>  　锵锵锵锵，堆排序完成。</p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>　　另一个使用分治思想的常用算法就是快速排序。快速排序的期望时间复杂度是O(nlogn)。但是最坏情况的时间复杂度又O(n*n)。虽然看起来最坏情况的时间复杂度很差，但是实际排序应用中它往往是最好的选择，因为它的平均性很好，而且O(nlogn)的常数因子非常小。<br>　　快速排序的三步分治过程:</p>\n<ol>\n<li>分解:　将数组A[p..r]，以A[q]为界换分为两个子数组，子数组可以为空,q可以自由选择。使得A[p..q-1]中的元素都小于A[q],A[q+1..r]中的元素都大于A[q]。</li>\n<li>解决:　通过递归调用快速排序，对子数组A[p..q-1]和A[q+1..r]进行排序</li>\n<li>合并: 因为子数组都是原址排序，所以不需要合并操作:数组A[p..r]已经有序</li>\n</ol>\n<p>　　来看具体的伪代码实现:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">PARTITION(A,p,r)</div><div class=\"line\">        x = A[r]</div><div class=\"line\">        i = p - 1</div><div class=\"line\">        for j = p to r - 1</div><div class=\"line\">                if A[j] &lt;= x</div><div class=\"line\">                        i = i + 1</div><div class=\"line\">                        exchange A[i] with A[j]</div><div class=\"line\">        exchage A[i+1] with A[r]</div><div class=\"line\">        return i + 1</div></pre></td></tr></table></figure></p>\n<p>　　在快速排序中，PARTITION是非常关键的部分，它的作用有两个，第一个是选定界限值q，第二个就是对输入数组进行原址重排。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">QUICKSORT(A,p,r)</div><div class=\"line\">        if p &lt; r</div><div class=\"line\">                q = PARTITION(A,p,r)</div><div class=\"line\">                QUICKSORT(A,p,q-1)</div><div class=\"line\">                QUICKSORT(A,q+1,r)</div></pre></td></tr></table></figure></p>\n<p>　　快速排序完成</p>"},{"title":"了解c++11","comments":0,"date":"2016-11-14T06:48:10.000Z","_content":"\n# 一、简介\n\n　　起草本文的目的主要有两点：第一点，在c++11学习的过程中做一些摘要总结，尽量取其精华，为自己梳理出来一个比较清晰的记忆脉络；第二点，不得不说的就是随着年纪的增长，记忆力也开始变得并不那么可靠，做些记录，定期回头看看总是好的。\n　　文章会对c++11（其实是c++1x更准确些）的背景进行简要的概述，并尽量详细且准确的阐述c++11的新的特性。共同学习，不断进步。\n## 1.1 c++11概述\n　　我们生活中常常谈论的c++更多的是指传统c++，又或是可以称为c++98的版本。c++11也并不是什么神秘的新语言，而是基于传统c++发布13年后的第一次重大修订。它主要基于现在软件行业发展的新需求与新诉求进行的一种调整——增加新特性并弃用部分特性。\n\n<!--more-->\n\n## 1.2 文章小贴士\n### 1.2.1 笔者开发运行环境\n```bash\n> lennybai@lennybai~$ lsb_release -a\n> No LSB modules are available.\n> Distributor ID:\tUbuntu\n> Description:\tUbuntu 16.04.1 LTS\n> Release:\t16.04\n> Codename:\txenial\n\n> lennybai@lennybai:~$ g++ --version\n> g++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609\n> Copyright (C) 2015 Free Software Foundation, Inc.\n> This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n```\n### 1.2.2 小贴士\n> g++ main.cpp -std=c++11　　\n\n若使用c++11，请记得添加编译选项\n\n### 1.2.3 原创提醒\n　　本文主要目的在于个人学习与记录，如果能够有幸帮助到同样在修行的同僚那自然是件幸事，引用还望注明出处。笔者在写作过程中也会大量的阅读各种文章以增强理解，当然，会尽最大可能去注明文章引用，如果存在问题，希望指正。\n\n***\n\n# 二、正篇\n　　对于学习新东西，我的习惯一般都是先google或者baidu看大量的博客来给自己洗脑，让自己有一定的知识轮廓。接下来就会开始啃官方文档，或者阅读刚刚浏览过的博客中推荐的各种书籍。当然，如果有个不错的视频教程让自己快进着点一点最好不过了，很多效果一目了然。\n\n　　在stackoverflow上，有人给出了不错的[书籍大纲](http://stackoverflow.com/a/388282)，这些对于积累知识的初学者更有益。对于那些对于传统c++已经很熟悉，只是希望快速的了解c++11的新特性，并择机使用的选手来说，实验楼的[《C++ 11/14 高速上手教程》](https://www.shiyanlou.com/courses/605/labs/2022/document)免费在线课程可能会更有帮助。\n\n　　本文主要基于实验楼的课程大纲进行整理，并进行部分知识点的拓展完善。\n\n## 2.1 弃用(deprecated)特性\n　　c++11提及到部分弃用特性。这里弃用并不等于废除并从标准中移除，而是警醒程序员在使用c++的时候能够意识到某些特性应避免使用。其实可能为了保证兼容性，这些特性可能永远不会被剔除出去（通常情况下是在编译的时，会显示一个弃用的warning），依旧可以被使用。\n```bash\nlennybai@lennybai:~/Desktop/cpp11$ g++ main.cpp -std=c++11\nmain.cpp: In function ‘int main()’:\nmain.cpp:7:15: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]\n     char* a = \"hello world\";\n\n```\n　　但是我们应该尽量遵循语言的发展与变迁，适当的改变自己对语言的使用方式。一个不恰当的例子，就好比黑白彩电置于当今社会，依然可以被使用，但是有更好的选择时为什么不去尝试呢？\n\n### 2.1.1 被移除或者弃用的特性\n\n> * std::auto_ptr 被 std::unique_ptr 取代。\n> * exception specifications\n> * bool 类型的 ++ 操作被弃用。\n> * export: 用法已被去掉,但关键字还是被保留了,给将来可能的特性使用\n> * 函数对象的基类(std::unary_function, std::binary_function)、函数指针适配器、类型成员指针适配器以及绑定器 (binder)。\n> * [顺序点](http://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022330.html) (sequence point): 这个术语正被更为易懂的描述所取代。一个运算可以发生 (is sequenced before) 在另一个运算之前; 又或者两个运算彼此之间没有顺序关系 (are unsequenced)。\n\n　　就像前面提到的，被弃用的特性应该引起一定的重视。这里主要参考维基百科上面提到的内容列出了一些已经被弃用的特性。在以后的学习过程中也会不断完善这一部分。\n\n## 2.2 新特性\n　　对于c++11的新特性应该是阅读本文的客官们更关心的。c++11新特性包括但不完全是：lambda表达式，类型推断关键字auto、decltype和对模板的大量改进。在这一章节我们进行详细阐述。\n\n### 2.2.1 自动类型推断（auto/decltype）\n　　对于传统c++而言，变量的类型都必须明确定义。虽然已经习惯传统c++编程的朋友们在声明或者定义基本类型(如int、char等)的变量时，并没有太多不妥的感觉。然而，可能也会在使用复杂模板时，觉得代码有点又丑又长。比如常见的迭代器声明:\n```cpp\nfor ( map < int,UserDefClass<userDefTemptype> >::iterator itr= userMap.begin(); itr !=userMap.end(); ++itr)\n```\n　　这里我列出了一个比较夸张的例子，目的是希望指出自动类型推断存在的意义。它其实已经很普遍的存在于现代编程语言之中(如python, javascript等脚本语言)。而在c++11中，通过对传统c++中auto关键字的修改得到自动类型推断的支持。\n　　auto关键字在传统c++中用来指定存储期，一般用于指明具有自动生命周期的变量。最常见的就是函数内的局部变量。编译器在做编译时，对一般不是static修饰的变量，则默认赋予auto类型，所以auto关键字几乎很少被使用。在传统c++中，auto关键字的使用方法如下：\n```cpp\nauto int a;\n```\n　　而在c++11中，auto的功能变为了类型自动推断,编译器会根据初始代码推断所声明变量的真实类型。将类型判断的工作由程序员交给了编译器，这样，在一定程度提高了代码开发的效率。而且，大部分情况下会直观的发现，代码变的更简短(当然int类型还是要比auto少一个字符)。这里是使用auto对上面繁重代码的优化:\n```cpp\nfor ( auto itr= userMap.begin(); itr !=userMap.end(); ++itr)\n```\n　　有没有很酷！接下来我们来看一下auto的具体使用，来更详细的了解一下它的功能。同时，也要学习一下它的使用规则。auto在c++11中，最容易理解的使用方式莫过于变量定义时的类型推断:\n```cpp\nauto a = 10;\nauto b = 'A';\nauto c(\"hello\");\ncout << \"a:\" << typeid(a).name() << endl;    　// “a:i”\ncout << \"b:\" << typeid(b).name() << endl;    　// \"b:c\"\ncout << \"c:\" << typeid(c).name() << endl;    　// \"c:PKc\"\n```\n　　这里我们可以看到，对于变量可以不用明确的去定义其类型，而是用auto代替。其最终效果与传统c++的变量定义效果没有差别。这里可以通过typeid函数进行验证(#include< typeinfo >).\n　　在很多对于auto的讲解中，它常常被称作占位符。所谓占位符，我的理解是它不能像数据类型那样去声明一个变量。所以使用auto的变量必须进行初始化。理所当然的，也就不能使用c++类型转化将变量转换为auto类型。\n```cpp\nauto a;         //error: declaration of ‘auto a’ has no initializer\n\nint value1 = 10;\nauto value2 = (auto)value1;    // error: invalid use of ‘auto’\nauto value3 = static_cast<auto>(value１);    // error: invalid use of ‘auto’\n```\n　　c++11已经彻底废弃了原有auto的使用方式，如代码所示:\n```cpp\nauto int a = 10;  //error: two or more data types in declaration of ‘a’\n```\n　　auto可以接受c++的变量名表列的方式定义多个变量，但所有变量应具有相同的数据类型。\n```cpp\nauto a1=10, a2=20, a3=30;\nauto a4=10, a5=20.0, a6 = 'A';    // error: conflicting declaration\n```\n\n　　auto在初始化时，会自动去除引用、const、volatile的语意。这种说法可能很难理解。其实就是如果原始变量为引用、const、volatile类型，auto初始化时需要自行指明。\n```cpp\n\n    int refa = 10;\n    int &refb = refa;\n    auto refc = refb;\n    auto &refd = refb;\n    refa = 100;\n    cout << \"refa: \" << typeid(refa).name() << \" \" << refa << endl;    // 100\n    cout << \"refb: \" << typeid(refb).name() << \" \" << refb << endl;    // 100\n    cout << \"refc: \" << typeid(refc).name() << \" \" << refc << endl;    // 10\n    cout << \"refd: \" << typeid(refd).name() << \" \" << refd << endl;    // 100\n\n    int arrA[3] = { 1, 2, 3 };\n    auto arrB = arrA;\n    auto &refArrB = arrA;\n    cout << \"arrA: \" << typeid(arrA).name() << endl;    // A3_i\n    cout << \"arrB: \" << typeid(arrB).name() << endl;    //Pi\n    cout << \"refArrB: \" << typeid(refArrB).name() << endl;    // A3_i\n```\n\n　　auto关键字不仅可以配合变量使用，它在对传统c++函数的代码优化上也可以说是大放异彩。特别是针对那些具有模板类型的函数，更是让我们在编写时变的简单高效。我们来看第一个例子。这里我们在模板函数中使用auto定义了一个站位变量。这样就使得该变量在随着传入值的类型发生变化时，自动进行类型转换。是不是很方便。\n\n```cpp\ntemplate <typename _Tx,typename _Ty>\nvoid func(_Tx x, _Ty y)\n{\n    auto v = x*y;\n    cout << v << endl;\n}\n\n//call func\nfunc3(1,2);    // 2\nfunc3(1.1,2.2);    // 2.42\n```\n\n　　auto关键字可以在函数中使用，那我们自然会想到，它能不能作为函数的返回值占位符。c++11自然提供了这种机制。但是用法可能和我们预期有一定的差距。\n\n```cpp\nauto func(int x, int y)->int\n{\n    return x+y;\n}\n```\n\n　　在c++11中，这样的返回值看起来很奇葩。使用auto来标注函数返回值时，还需要在末尾指定返回类型。会不会觉得还不如不用auto类型。但我觉得制定标准的人肯定也会考虑到这个问题。自然就去搜索了一些相关内容:\n1. 在函数返回值特别长的时候放在末尾，会显得好看。\n2. c++14会把返回值去掉，让编译器直接支持自动推倒（c++14确实是做到了）\n3. 出现在函数后面的表达式在代码编译时也是出现在函数之后的，这就使得很多函数中的临时变量可以出现在这个表达式中。这个我们在后面的decltype使用中可以看到效果。(显然，这个才是我认为最重要的)\n\n```cpp\n//c++14　支持\nauto func(int x, int y)\n{\n    return x+y;\n}\n```\n\n　　这种auto作为函数返回值占位符的用法，会使编写复杂的模板函数时变得相当简单和灵活。\n\n```cpp\ntemplate <typename _Tx, typename _Ty>\nauto func(_Tx x, _Ty y) -> decltype(x*y)\n{\n    return x*y;\n}\n\n//call func\nauto funcA = func(1,2);\ncout << funcA << endl;    // 2\nfuncA = func(1.1,2.2);\ncout << funcA << endl;    // 2\nauto funcB = func(1.1,2.2);\ncout << funcB << endl;    // 2.42\n```\n\n  这里用到了decltype(declared type)，它可以用来通过传入的参数来声明类型。这样func这个模板函数的会很方便的随着模板传入类型来自动改变返回值类型。bravo！\n\n  decltype不存在太多的歧义，这里直接列出代码。\n\n```cpp\nint declint = 10;\ndecltype(declint) declintt;\n\nvector<int> vec;\ntypedef decltype(vec.begin()) vectype;\n\ndecltype(declint) temp1 = declint;\ndecltype((declint)) temp2 = declint; //decltype(())定义的是引用类型\ndecltype((declint)) temp3;    // error: ‘temp3’ declared as reference but not initialized\n```\n\n　　接下来我们说一下刚才我们提到的函数返回类型后置的问题。我们已经知道通过decltype可以根据传入参数获取最终的数据类型。那么我们将下面代码进行修改：\n\n```cpp\n// origin, ok~\ntemplate <typename _Tx, typename _Ty>\nauto func(_Tx x, _Ty y) -> decltype(x*y)\n{\n    return x*y;\n}\n```\n\n　　一般想法是认为，返回值不就是decltype(x*y)类型么？　那我们直接放前面不是更方便。好的，我们改写一下.\n\n```cpp\n// update\ntemplate <typename _Tx, typename _Ty>\ndecltype(x*y) func(_Tx x, _Ty y)\n{\n    return x*y;\n}\n```\n\n  然而：\n\n```bash\nlennybai@lennybai:~/project/cpp11$ g++ main.cpp -std=c++11\nmain.cpp:16:10: error: ‘x’ was not declared in this scope\n decltype(x*y) func4(_Tx x, _Ty y)\n          ^\nmain.cpp:16:10: error: ‘x’ was not declared in this scope\nmain.cpp:16:12: error: ‘y’ was not declared in this scope\n decltype(x*y) func4(_Tx x, _Ty y)\n            ^\n```\n\n　　是的，结果就是这么神奇。这也说明　’function->expr‘ 中的expr是出现在函数之后的。如果不使用auto占位符，而直接使用decltype(x*y)声明函数类型。由于x,y在函数运行前尚未明确类型，所以这里就会出现编译错误。\n\n　　在这一小节最后需要指出的是，auto是不能作为参数占位符出现的。\n\n```cpp\n// 客官不可以哦\nvoid func2(auto x)\n{\n     //do something\n}\n```\n### 2.2.2 指针空值nullptr\n　　在传统c++中，通常使用NULL来标识空指针。NULL通常是一个与0相关的宏定义。这里是/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h中对NULL的定义。\n```c++\n#if defined (_STDDEF_H) || defined (__need_NULL)\n#undef NULL\t\t/* in case <stdio.h> has defined it. */\n#ifdef __GNUG__\n#define NULL __null\n#else   /* G++ */\n#ifndef __cplusplus\n#define NULL ((void *)0)\n#else   /* C++ */\n#define NULL 0\n#endif  /* C++ */\n#endif  /* G++ */\n#endif\t/* NULL not defined and <stddef.h> or need NULL.  */\n#undef\t__need_NULL\n```\n　　我们发现在传统C++中，NULL被定义为0。由于没有类型限制，它可以被强制转换为各种其他数据类型。最常见的例子就是当出现函数重载时会发生混乱。\n```c++\nvoid func(int n) { cout << \"call func(int n) : \" << endl; };\nvoid func(int *p) { cout << \"call func(int *p) : \" << endl; };\n\nfunc(NULL); // error: call of overloaded ‘func(NULL)’ is ambiguous\n```\n　　为了区分不同类型的空指针，C++11引入了nullptr_t类型的指针空值nullptr。它可以自动隐性的转换为所需的成员指针或者函数指针的类型。从而使程序更加清晰明了。值得注意的是，nullptr只能用来标识指针类型。\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid func(int n) { cout << \"call func(int n) : \" << endl; };\nvoid func(int *p) { cout << \"call func(int *p) : \" << endl; };\n\nint main()\n{\n    int nIntNull = NULL;        // ok\n    int *pIntNull = NULL;        // ok\n    int *pIntNullptr = nullptr;    // ok\n    int nIntNullptr = nullptr;    // error: cannot convert ‘std::nullptr_t’ to ‘int’ in initialization\n\n    func(NULL); // error: call of overloaded ‘func(NULL)’ is ambiguous\n    func(nullptr); // call func(int *p)\n\n    return 0;\n}\n```\n### 2.2.3 常量区分符constexpr\n　　常量表达式在c++中还是很常见的，特别是在数组或者容器等初始化时传入的大小通常为常量表达式。在C++中，常量表达式通常被解释为在编译时可以明确其值的表达式。最常见的常量表达式就是被const标识的变量：\n```c++\nint n = 1;\nstd::array<int, n> a1; // error, n is not a constant expression\nconst int cn = 2;\nstd::array<int, cn> a2; // OK, cn is a constant expression\n```\n　　其实，在我们进行程序设计的时候，常常会发现很多情况是需要根据运行情况去获取一个值，然后再进行数据或者容器大小的分配。而这些值我们在给定条件值之后，很容易就会被推导出来。而对于计算机来说，却需要在每次运行时不断重复相同的推倒工作。那么我们可能会觉得，如果可以像常量表达式那样在编译时就确定其值，是不是在运行时就可以得到更高的运行效率呢。c++为我们提供了常量区分符constexpr来实现这一效果。\n　　constexpr用来标示一个变量或者函数为常量表达式，也是告诉编译器需要去验证它们是不是一个常量表达式。\n```c++\nint x;\nstruct A {\n    constexpr A(bool b) : m(b?42:x) { }\n    int m;\n};\nconstexpr int v = A(true).m; // OK\nconstexpr int w = A(false).m; // error: non-const x\nconstexpr int mf = 20;          // 20是常量表达式\nconstexpr int limit = mf + 1;   // mf + 1是常量表达式\nconstexpr int sz = size();      // 只有当size是一个constexpr函数时才是一条正确的声明语句\n\nconstexpr int A()\n{\n    return 10;\n}\n\nconstexpr int fibonacci1(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci1(n-1)+fibonacci1(n-2);\n}\n\n// c++11 error error: body of constexpr function ‘constexpr int fibonacci2(int)’ not a return-statement\n// c++14 OK\n constexpr int fibonacci2(const int n) {\n     if(n == 1) return 1;\n  　 if(n == 2) return 1;\n  　 return fibonacci2(n-1)+fibonacci2(n-2);\n}\n\nint i1 = 10;\nconst int i2 = i1;\nconst int i3 = 10;\nconstexpr int x1 = i1;    // error: the value of ‘i1’ is not usable in a constant expression\nconstexpr int x2 = i2;    // error: the value of ‘i2’ is not usable in a constant expression\nconstexpr int x3 = i3;    // ok\nconstexpr int x4 = 10;    // ok\nconstexpr int x5 = A();   // ok\nconstexpr int x6 = fibonacci1(10);    // ok\nconstexpr int x7 = cin.get(); // !error\nconstexpr int x8 = fibonacci2(10);\n\nint a[i2];    // ok\nint b[x4];    // ok\n```\n　　从上面的代码中我们可以大概了解到constexpr的作用与用法。这里以上代码进行一些说明：\n1. c++11中对constexpr修饰的函数只能直接返回常量表达式。c++14中进行了增强，它可以支持局部变量和条件语句等。\n2. const int i2为运行时赋值，所以x2 = i2 报错； const int i3为常量表达式，所以x3=i3没问题\n\n    对于constexpr可以在这里[了解更多](http://cpptruths.blogspot.jp/2011/07/want-speed-use-constexpr-meta.html)。\n\n### 2.2.4 range-based for loop\n　　在cppreference中，这个特性被描述为：\n>Executes a for loop over a range.Used as a more readable equivalent to the traditional for loop operating over a range of values, such as all elements in a container.　\n\n　\n　　这个描述有些官方和笼统。其实，range-based for loop在c++11中加入，它使得c++开始支持类似于'foreach'的范式格式。这种新格式使得我们获取或者操作数组时变得更容易，前提是我们不去关心索引，迭代器和数量的前提下。range-based　for loop可以支持迭代所有的c类型数组，初始化列表和重载了begin()和end()函数的容器。\n\n```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    map<string, vector<int>> m;\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    m[\"my_vector\"] = v;\n\n    for(auto& tempM : m)\n    {\n        cout << tempM.first << endl;\n        for(auto& tempV : tempM.second)\n        {\n            cout << tempV << endl;\n        }\n    }\n\n    int arr[] = {1,2,3,4,5};\n    for(int& e : arr)\n    {\n        cout << e << endl;\n        e = e*e;\n    }\n    for(int& e : arr)\n    {\n        cout << e << endl;\n    }\n\n    return 0;\n}\n```\n\n### 2.2.5 快速初始化列表\n　　在c++11中，它提供了更便捷，或者说是更人性化的初始化方式。\n```c++\n//c++ 98 error: in C++98 ‘m’ must be initialized by constructor, not by ‘{...}’\n//c++ 11\nvector<int> v = {1,2,3,4,5};\ncout << v[3] << endl;\n\n//c++98 error: could not convert ‘{{1, 2}}’ from ‘<brace-enclosed initializer list>’ to ‘std::map<int, int>’\n//c++11 ok\nmap<int, int> m = {{1,2}};\ncout << m[1] << endl;\n```\n  对于对象的内部属性初始化，我们可以通过调用参数为initializer_list的方法快速初始化。\n```c++\nstruct myclass {\n  myclass (int,int);\n  myclass (initializer_list<int>);\n  /* definitions ... */\n};\n\nmyclass foo {10,20};  // calls initializer_list ctor\nmyclass bar (10,20);  // calls first constructor\n```\n\n### 2.2.6 类型别名\n　　传统c++同常使用typedef为类型定义一个新的名称。给函数声明去做个别名是比较常见的使用方式。\n> typedef void (*SigHandler)(int);\n\n\n　　这个是unix中信号处理的圆形函数。它讲一个参数为int并返回值为void的函数原型重命名为SigHandler.这个原型相对还比较容易理解。但在我们平时的编程过程中，遇到的情况往往比这要复杂得多。c++11为我们提供了一个更符合人类思维和更直观的表述方式(这话是我自己说的，不要追究责任２３３３３３)。\n\n> using SigHandler = void(*)(int);\n\n　　这里就提高了using关键字。在传统c++中，对于using 我们可能唯一的用法就是using namespace。而在c++11中，它获得了更多的功能。下面我们继续说一些其他的别名使用情况。提到类型别名，我们有的时候会想到，能不能讲某些又臭又长的模板类型给做个别名。\n```cpp\ntemplate<typename X, typename Y, typename Z>\nclass MyTest\n{\n  public:\n    MyTest();\n    virtual ~MyTest();\n  private:\n    X x;\n    Y y;\n    Z z;\n};\n\ntemplate<typename U>\ntypedef MyTest<int,U,int> mm; //error: template declaration of ‘typedef’\n```\n  在传统c++中，它并不支持对上述初始化部分类型的模板类进行再次重命名。而c++11中可以通过using关键字得到实现。\n```cpp\ntemplate<typename U>\nusing mm = MyTest<int,U,int>;\n```\n\n***\n# 3 参考文献\n\n- [1]: [c++标准](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf)\n- [2]: [cppreference](http://en.cppreference.com/w/cpp/types/NULL)\n- [3]: [Ten C++11 Features Every C++ Developer Should Use](http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer)\n","source":"_posts/了解c-11.md","raw":"---\ntitle: 了解c++11\ncomments: false\ndate: 2016-11-14 14:48:10\ntags:\n  - 编程\n  - c++11\ncategories:\n  - 程序设计\n  - c++11\n---\n\n# 一、简介\n\n　　起草本文的目的主要有两点：第一点，在c++11学习的过程中做一些摘要总结，尽量取其精华，为自己梳理出来一个比较清晰的记忆脉络；第二点，不得不说的就是随着年纪的增长，记忆力也开始变得并不那么可靠，做些记录，定期回头看看总是好的。\n　　文章会对c++11（其实是c++1x更准确些）的背景进行简要的概述，并尽量详细且准确的阐述c++11的新的特性。共同学习，不断进步。\n## 1.1 c++11概述\n　　我们生活中常常谈论的c++更多的是指传统c++，又或是可以称为c++98的版本。c++11也并不是什么神秘的新语言，而是基于传统c++发布13年后的第一次重大修订。它主要基于现在软件行业发展的新需求与新诉求进行的一种调整——增加新特性并弃用部分特性。\n\n<!--more-->\n\n## 1.2 文章小贴士\n### 1.2.1 笔者开发运行环境\n```bash\n> lennybai@lennybai~$ lsb_release -a\n> No LSB modules are available.\n> Distributor ID:\tUbuntu\n> Description:\tUbuntu 16.04.1 LTS\n> Release:\t16.04\n> Codename:\txenial\n\n> lennybai@lennybai:~$ g++ --version\n> g++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609\n> Copyright (C) 2015 Free Software Foundation, Inc.\n> This is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n```\n### 1.2.2 小贴士\n> g++ main.cpp -std=c++11　　\n\n若使用c++11，请记得添加编译选项\n\n### 1.2.3 原创提醒\n　　本文主要目的在于个人学习与记录，如果能够有幸帮助到同样在修行的同僚那自然是件幸事，引用还望注明出处。笔者在写作过程中也会大量的阅读各种文章以增强理解，当然，会尽最大可能去注明文章引用，如果存在问题，希望指正。\n\n***\n\n# 二、正篇\n　　对于学习新东西，我的习惯一般都是先google或者baidu看大量的博客来给自己洗脑，让自己有一定的知识轮廓。接下来就会开始啃官方文档，或者阅读刚刚浏览过的博客中推荐的各种书籍。当然，如果有个不错的视频教程让自己快进着点一点最好不过了，很多效果一目了然。\n\n　　在stackoverflow上，有人给出了不错的[书籍大纲](http://stackoverflow.com/a/388282)，这些对于积累知识的初学者更有益。对于那些对于传统c++已经很熟悉，只是希望快速的了解c++11的新特性，并择机使用的选手来说，实验楼的[《C++ 11/14 高速上手教程》](https://www.shiyanlou.com/courses/605/labs/2022/document)免费在线课程可能会更有帮助。\n\n　　本文主要基于实验楼的课程大纲进行整理，并进行部分知识点的拓展完善。\n\n## 2.1 弃用(deprecated)特性\n　　c++11提及到部分弃用特性。这里弃用并不等于废除并从标准中移除，而是警醒程序员在使用c++的时候能够意识到某些特性应避免使用。其实可能为了保证兼容性，这些特性可能永远不会被剔除出去（通常情况下是在编译的时，会显示一个弃用的warning），依旧可以被使用。\n```bash\nlennybai@lennybai:~/Desktop/cpp11$ g++ main.cpp -std=c++11\nmain.cpp: In function ‘int main()’:\nmain.cpp:7:15: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]\n     char* a = \"hello world\";\n\n```\n　　但是我们应该尽量遵循语言的发展与变迁，适当的改变自己对语言的使用方式。一个不恰当的例子，就好比黑白彩电置于当今社会，依然可以被使用，但是有更好的选择时为什么不去尝试呢？\n\n### 2.1.1 被移除或者弃用的特性\n\n> * std::auto_ptr 被 std::unique_ptr 取代。\n> * exception specifications\n> * bool 类型的 ++ 操作被弃用。\n> * export: 用法已被去掉,但关键字还是被保留了,给将来可能的特性使用\n> * 函数对象的基类(std::unary_function, std::binary_function)、函数指针适配器、类型成员指针适配器以及绑定器 (binder)。\n> * [顺序点](http://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022330.html) (sequence point): 这个术语正被更为易懂的描述所取代。一个运算可以发生 (is sequenced before) 在另一个运算之前; 又或者两个运算彼此之间没有顺序关系 (are unsequenced)。\n\n　　就像前面提到的，被弃用的特性应该引起一定的重视。这里主要参考维基百科上面提到的内容列出了一些已经被弃用的特性。在以后的学习过程中也会不断完善这一部分。\n\n## 2.2 新特性\n　　对于c++11的新特性应该是阅读本文的客官们更关心的。c++11新特性包括但不完全是：lambda表达式，类型推断关键字auto、decltype和对模板的大量改进。在这一章节我们进行详细阐述。\n\n### 2.2.1 自动类型推断（auto/decltype）\n　　对于传统c++而言，变量的类型都必须明确定义。虽然已经习惯传统c++编程的朋友们在声明或者定义基本类型(如int、char等)的变量时，并没有太多不妥的感觉。然而，可能也会在使用复杂模板时，觉得代码有点又丑又长。比如常见的迭代器声明:\n```cpp\nfor ( map < int,UserDefClass<userDefTemptype> >::iterator itr= userMap.begin(); itr !=userMap.end(); ++itr)\n```\n　　这里我列出了一个比较夸张的例子，目的是希望指出自动类型推断存在的意义。它其实已经很普遍的存在于现代编程语言之中(如python, javascript等脚本语言)。而在c++11中，通过对传统c++中auto关键字的修改得到自动类型推断的支持。\n　　auto关键字在传统c++中用来指定存储期，一般用于指明具有自动生命周期的变量。最常见的就是函数内的局部变量。编译器在做编译时，对一般不是static修饰的变量，则默认赋予auto类型，所以auto关键字几乎很少被使用。在传统c++中，auto关键字的使用方法如下：\n```cpp\nauto int a;\n```\n　　而在c++11中，auto的功能变为了类型自动推断,编译器会根据初始代码推断所声明变量的真实类型。将类型判断的工作由程序员交给了编译器，这样，在一定程度提高了代码开发的效率。而且，大部分情况下会直观的发现，代码变的更简短(当然int类型还是要比auto少一个字符)。这里是使用auto对上面繁重代码的优化:\n```cpp\nfor ( auto itr= userMap.begin(); itr !=userMap.end(); ++itr)\n```\n　　有没有很酷！接下来我们来看一下auto的具体使用，来更详细的了解一下它的功能。同时，也要学习一下它的使用规则。auto在c++11中，最容易理解的使用方式莫过于变量定义时的类型推断:\n```cpp\nauto a = 10;\nauto b = 'A';\nauto c(\"hello\");\ncout << \"a:\" << typeid(a).name() << endl;    　// “a:i”\ncout << \"b:\" << typeid(b).name() << endl;    　// \"b:c\"\ncout << \"c:\" << typeid(c).name() << endl;    　// \"c:PKc\"\n```\n　　这里我们可以看到，对于变量可以不用明确的去定义其类型，而是用auto代替。其最终效果与传统c++的变量定义效果没有差别。这里可以通过typeid函数进行验证(#include< typeinfo >).\n　　在很多对于auto的讲解中，它常常被称作占位符。所谓占位符，我的理解是它不能像数据类型那样去声明一个变量。所以使用auto的变量必须进行初始化。理所当然的，也就不能使用c++类型转化将变量转换为auto类型。\n```cpp\nauto a;         //error: declaration of ‘auto a’ has no initializer\n\nint value1 = 10;\nauto value2 = (auto)value1;    // error: invalid use of ‘auto’\nauto value3 = static_cast<auto>(value１);    // error: invalid use of ‘auto’\n```\n　　c++11已经彻底废弃了原有auto的使用方式，如代码所示:\n```cpp\nauto int a = 10;  //error: two or more data types in declaration of ‘a’\n```\n　　auto可以接受c++的变量名表列的方式定义多个变量，但所有变量应具有相同的数据类型。\n```cpp\nauto a1=10, a2=20, a3=30;\nauto a4=10, a5=20.0, a6 = 'A';    // error: conflicting declaration\n```\n\n　　auto在初始化时，会自动去除引用、const、volatile的语意。这种说法可能很难理解。其实就是如果原始变量为引用、const、volatile类型，auto初始化时需要自行指明。\n```cpp\n\n    int refa = 10;\n    int &refb = refa;\n    auto refc = refb;\n    auto &refd = refb;\n    refa = 100;\n    cout << \"refa: \" << typeid(refa).name() << \" \" << refa << endl;    // 100\n    cout << \"refb: \" << typeid(refb).name() << \" \" << refb << endl;    // 100\n    cout << \"refc: \" << typeid(refc).name() << \" \" << refc << endl;    // 10\n    cout << \"refd: \" << typeid(refd).name() << \" \" << refd << endl;    // 100\n\n    int arrA[3] = { 1, 2, 3 };\n    auto arrB = arrA;\n    auto &refArrB = arrA;\n    cout << \"arrA: \" << typeid(arrA).name() << endl;    // A3_i\n    cout << \"arrB: \" << typeid(arrB).name() << endl;    //Pi\n    cout << \"refArrB: \" << typeid(refArrB).name() << endl;    // A3_i\n```\n\n　　auto关键字不仅可以配合变量使用，它在对传统c++函数的代码优化上也可以说是大放异彩。特别是针对那些具有模板类型的函数，更是让我们在编写时变的简单高效。我们来看第一个例子。这里我们在模板函数中使用auto定义了一个站位变量。这样就使得该变量在随着传入值的类型发生变化时，自动进行类型转换。是不是很方便。\n\n```cpp\ntemplate <typename _Tx,typename _Ty>\nvoid func(_Tx x, _Ty y)\n{\n    auto v = x*y;\n    cout << v << endl;\n}\n\n//call func\nfunc3(1,2);    // 2\nfunc3(1.1,2.2);    // 2.42\n```\n\n　　auto关键字可以在函数中使用，那我们自然会想到，它能不能作为函数的返回值占位符。c++11自然提供了这种机制。但是用法可能和我们预期有一定的差距。\n\n```cpp\nauto func(int x, int y)->int\n{\n    return x+y;\n}\n```\n\n　　在c++11中，这样的返回值看起来很奇葩。使用auto来标注函数返回值时，还需要在末尾指定返回类型。会不会觉得还不如不用auto类型。但我觉得制定标准的人肯定也会考虑到这个问题。自然就去搜索了一些相关内容:\n1. 在函数返回值特别长的时候放在末尾，会显得好看。\n2. c++14会把返回值去掉，让编译器直接支持自动推倒（c++14确实是做到了）\n3. 出现在函数后面的表达式在代码编译时也是出现在函数之后的，这就使得很多函数中的临时变量可以出现在这个表达式中。这个我们在后面的decltype使用中可以看到效果。(显然，这个才是我认为最重要的)\n\n```cpp\n//c++14　支持\nauto func(int x, int y)\n{\n    return x+y;\n}\n```\n\n　　这种auto作为函数返回值占位符的用法，会使编写复杂的模板函数时变得相当简单和灵活。\n\n```cpp\ntemplate <typename _Tx, typename _Ty>\nauto func(_Tx x, _Ty y) -> decltype(x*y)\n{\n    return x*y;\n}\n\n//call func\nauto funcA = func(1,2);\ncout << funcA << endl;    // 2\nfuncA = func(1.1,2.2);\ncout << funcA << endl;    // 2\nauto funcB = func(1.1,2.2);\ncout << funcB << endl;    // 2.42\n```\n\n  这里用到了decltype(declared type)，它可以用来通过传入的参数来声明类型。这样func这个模板函数的会很方便的随着模板传入类型来自动改变返回值类型。bravo！\n\n  decltype不存在太多的歧义，这里直接列出代码。\n\n```cpp\nint declint = 10;\ndecltype(declint) declintt;\n\nvector<int> vec;\ntypedef decltype(vec.begin()) vectype;\n\ndecltype(declint) temp1 = declint;\ndecltype((declint)) temp2 = declint; //decltype(())定义的是引用类型\ndecltype((declint)) temp3;    // error: ‘temp3’ declared as reference but not initialized\n```\n\n　　接下来我们说一下刚才我们提到的函数返回类型后置的问题。我们已经知道通过decltype可以根据传入参数获取最终的数据类型。那么我们将下面代码进行修改：\n\n```cpp\n// origin, ok~\ntemplate <typename _Tx, typename _Ty>\nauto func(_Tx x, _Ty y) -> decltype(x*y)\n{\n    return x*y;\n}\n```\n\n　　一般想法是认为，返回值不就是decltype(x*y)类型么？　那我们直接放前面不是更方便。好的，我们改写一下.\n\n```cpp\n// update\ntemplate <typename _Tx, typename _Ty>\ndecltype(x*y) func(_Tx x, _Ty y)\n{\n    return x*y;\n}\n```\n\n  然而：\n\n```bash\nlennybai@lennybai:~/project/cpp11$ g++ main.cpp -std=c++11\nmain.cpp:16:10: error: ‘x’ was not declared in this scope\n decltype(x*y) func4(_Tx x, _Ty y)\n          ^\nmain.cpp:16:10: error: ‘x’ was not declared in this scope\nmain.cpp:16:12: error: ‘y’ was not declared in this scope\n decltype(x*y) func4(_Tx x, _Ty y)\n            ^\n```\n\n　　是的，结果就是这么神奇。这也说明　’function->expr‘ 中的expr是出现在函数之后的。如果不使用auto占位符，而直接使用decltype(x*y)声明函数类型。由于x,y在函数运行前尚未明确类型，所以这里就会出现编译错误。\n\n　　在这一小节最后需要指出的是，auto是不能作为参数占位符出现的。\n\n```cpp\n// 客官不可以哦\nvoid func2(auto x)\n{\n     //do something\n}\n```\n### 2.2.2 指针空值nullptr\n　　在传统c++中，通常使用NULL来标识空指针。NULL通常是一个与0相关的宏定义。这里是/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h中对NULL的定义。\n```c++\n#if defined (_STDDEF_H) || defined (__need_NULL)\n#undef NULL\t\t/* in case <stdio.h> has defined it. */\n#ifdef __GNUG__\n#define NULL __null\n#else   /* G++ */\n#ifndef __cplusplus\n#define NULL ((void *)0)\n#else   /* C++ */\n#define NULL 0\n#endif  /* C++ */\n#endif  /* G++ */\n#endif\t/* NULL not defined and <stddef.h> or need NULL.  */\n#undef\t__need_NULL\n```\n　　我们发现在传统C++中，NULL被定义为0。由于没有类型限制，它可以被强制转换为各种其他数据类型。最常见的例子就是当出现函数重载时会发生混乱。\n```c++\nvoid func(int n) { cout << \"call func(int n) : \" << endl; };\nvoid func(int *p) { cout << \"call func(int *p) : \" << endl; };\n\nfunc(NULL); // error: call of overloaded ‘func(NULL)’ is ambiguous\n```\n　　为了区分不同类型的空指针，C++11引入了nullptr_t类型的指针空值nullptr。它可以自动隐性的转换为所需的成员指针或者函数指针的类型。从而使程序更加清晰明了。值得注意的是，nullptr只能用来标识指针类型。\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid func(int n) { cout << \"call func(int n) : \" << endl; };\nvoid func(int *p) { cout << \"call func(int *p) : \" << endl; };\n\nint main()\n{\n    int nIntNull = NULL;        // ok\n    int *pIntNull = NULL;        // ok\n    int *pIntNullptr = nullptr;    // ok\n    int nIntNullptr = nullptr;    // error: cannot convert ‘std::nullptr_t’ to ‘int’ in initialization\n\n    func(NULL); // error: call of overloaded ‘func(NULL)’ is ambiguous\n    func(nullptr); // call func(int *p)\n\n    return 0;\n}\n```\n### 2.2.3 常量区分符constexpr\n　　常量表达式在c++中还是很常见的，特别是在数组或者容器等初始化时传入的大小通常为常量表达式。在C++中，常量表达式通常被解释为在编译时可以明确其值的表达式。最常见的常量表达式就是被const标识的变量：\n```c++\nint n = 1;\nstd::array<int, n> a1; // error, n is not a constant expression\nconst int cn = 2;\nstd::array<int, cn> a2; // OK, cn is a constant expression\n```\n　　其实，在我们进行程序设计的时候，常常会发现很多情况是需要根据运行情况去获取一个值，然后再进行数据或者容器大小的分配。而这些值我们在给定条件值之后，很容易就会被推导出来。而对于计算机来说，却需要在每次运行时不断重复相同的推倒工作。那么我们可能会觉得，如果可以像常量表达式那样在编译时就确定其值，是不是在运行时就可以得到更高的运行效率呢。c++为我们提供了常量区分符constexpr来实现这一效果。\n　　constexpr用来标示一个变量或者函数为常量表达式，也是告诉编译器需要去验证它们是不是一个常量表达式。\n```c++\nint x;\nstruct A {\n    constexpr A(bool b) : m(b?42:x) { }\n    int m;\n};\nconstexpr int v = A(true).m; // OK\nconstexpr int w = A(false).m; // error: non-const x\nconstexpr int mf = 20;          // 20是常量表达式\nconstexpr int limit = mf + 1;   // mf + 1是常量表达式\nconstexpr int sz = size();      // 只有当size是一个constexpr函数时才是一条正确的声明语句\n\nconstexpr int A()\n{\n    return 10;\n}\n\nconstexpr int fibonacci1(const int n) {\n    return n == 1 || n == 2 ? 1 : fibonacci1(n-1)+fibonacci1(n-2);\n}\n\n// c++11 error error: body of constexpr function ‘constexpr int fibonacci2(int)’ not a return-statement\n// c++14 OK\n constexpr int fibonacci2(const int n) {\n     if(n == 1) return 1;\n  　 if(n == 2) return 1;\n  　 return fibonacci2(n-1)+fibonacci2(n-2);\n}\n\nint i1 = 10;\nconst int i2 = i1;\nconst int i3 = 10;\nconstexpr int x1 = i1;    // error: the value of ‘i1’ is not usable in a constant expression\nconstexpr int x2 = i2;    // error: the value of ‘i2’ is not usable in a constant expression\nconstexpr int x3 = i3;    // ok\nconstexpr int x4 = 10;    // ok\nconstexpr int x5 = A();   // ok\nconstexpr int x6 = fibonacci1(10);    // ok\nconstexpr int x7 = cin.get(); // !error\nconstexpr int x8 = fibonacci2(10);\n\nint a[i2];    // ok\nint b[x4];    // ok\n```\n　　从上面的代码中我们可以大概了解到constexpr的作用与用法。这里以上代码进行一些说明：\n1. c++11中对constexpr修饰的函数只能直接返回常量表达式。c++14中进行了增强，它可以支持局部变量和条件语句等。\n2. const int i2为运行时赋值，所以x2 = i2 报错； const int i3为常量表达式，所以x3=i3没问题\n\n    对于constexpr可以在这里[了解更多](http://cpptruths.blogspot.jp/2011/07/want-speed-use-constexpr-meta.html)。\n\n### 2.2.4 range-based for loop\n　　在cppreference中，这个特性被描述为：\n>Executes a for loop over a range.Used as a more readable equivalent to the traditional for loop operating over a range of values, such as all elements in a container.　\n\n　\n　　这个描述有些官方和笼统。其实，range-based for loop在c++11中加入，它使得c++开始支持类似于'foreach'的范式格式。这种新格式使得我们获取或者操作数组时变得更容易，前提是我们不去关心索引，迭代器和数量的前提下。range-based　for loop可以支持迭代所有的c类型数组，初始化列表和重载了begin()和end()函数的容器。\n\n```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    map<string, vector<int>> m;\n    vector<int> v;\n    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    m[\"my_vector\"] = v;\n\n    for(auto& tempM : m)\n    {\n        cout << tempM.first << endl;\n        for(auto& tempV : tempM.second)\n        {\n            cout << tempV << endl;\n        }\n    }\n\n    int arr[] = {1,2,3,4,5};\n    for(int& e : arr)\n    {\n        cout << e << endl;\n        e = e*e;\n    }\n    for(int& e : arr)\n    {\n        cout << e << endl;\n    }\n\n    return 0;\n}\n```\n\n### 2.2.5 快速初始化列表\n　　在c++11中，它提供了更便捷，或者说是更人性化的初始化方式。\n```c++\n//c++ 98 error: in C++98 ‘m’ must be initialized by constructor, not by ‘{...}’\n//c++ 11\nvector<int> v = {1,2,3,4,5};\ncout << v[3] << endl;\n\n//c++98 error: could not convert ‘{{1, 2}}’ from ‘<brace-enclosed initializer list>’ to ‘std::map<int, int>’\n//c++11 ok\nmap<int, int> m = {{1,2}};\ncout << m[1] << endl;\n```\n  对于对象的内部属性初始化，我们可以通过调用参数为initializer_list的方法快速初始化。\n```c++\nstruct myclass {\n  myclass (int,int);\n  myclass (initializer_list<int>);\n  /* definitions ... */\n};\n\nmyclass foo {10,20};  // calls initializer_list ctor\nmyclass bar (10,20);  // calls first constructor\n```\n\n### 2.2.6 类型别名\n　　传统c++同常使用typedef为类型定义一个新的名称。给函数声明去做个别名是比较常见的使用方式。\n> typedef void (*SigHandler)(int);\n\n\n　　这个是unix中信号处理的圆形函数。它讲一个参数为int并返回值为void的函数原型重命名为SigHandler.这个原型相对还比较容易理解。但在我们平时的编程过程中，遇到的情况往往比这要复杂得多。c++11为我们提供了一个更符合人类思维和更直观的表述方式(这话是我自己说的，不要追究责任２３３３３３)。\n\n> using SigHandler = void(*)(int);\n\n　　这里就提高了using关键字。在传统c++中，对于using 我们可能唯一的用法就是using namespace。而在c++11中，它获得了更多的功能。下面我们继续说一些其他的别名使用情况。提到类型别名，我们有的时候会想到，能不能讲某些又臭又长的模板类型给做个别名。\n```cpp\ntemplate<typename X, typename Y, typename Z>\nclass MyTest\n{\n  public:\n    MyTest();\n    virtual ~MyTest();\n  private:\n    X x;\n    Y y;\n    Z z;\n};\n\ntemplate<typename U>\ntypedef MyTest<int,U,int> mm; //error: template declaration of ‘typedef’\n```\n  在传统c++中，它并不支持对上述初始化部分类型的模板类进行再次重命名。而c++11中可以通过using关键字得到实现。\n```cpp\ntemplate<typename U>\nusing mm = MyTest<int,U,int>;\n```\n\n***\n# 3 参考文献\n\n- [1]: [c++标准](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf)\n- [2]: [cppreference](http://en.cppreference.com/w/cpp/types/NULL)\n- [3]: [Ten C++11 Features Every C++ Developer Should Use](http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer)\n","slug":"了解c-11","published":1,"updated":"2016-11-23T01:07:19.984Z","layout":"post","photos":[],"link":"","_id":"cix1e5cfl0011nvou4oq16phl","content":"<h1 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h1><p>　　起草本文的目的主要有两点：第一点，在c++11学习的过程中做一些摘要总结，尽量取其精华，为自己梳理出来一个比较清晰的记忆脉络；第二点，不得不说的就是随着年纪的增长，记忆力也开始变得并不那么可靠，做些记录，定期回头看看总是好的。<br>　　文章会对c++11（其实是c++1x更准确些）的背景进行简要的概述，并尽量详细且准确的阐述c++11的新的特性。共同学习，不断进步。</p>\n<h2 id=\"1-1-c-11概述\"><a href=\"#1-1-c-11概述\" class=\"headerlink\" title=\"1.1 c++11概述\"></a>1.1 c++11概述</h2><p>　　我们生活中常常谈论的c++更多的是指传统c++，又或是可以称为c++98的版本。c++11也并不是什么神秘的新语言，而是基于传统c++发布13年后的第一次重大修订。它主要基于现在软件行业发展的新需求与新诉求进行的一种调整——增加新特性并弃用部分特性。</p>\n<a id=\"more\"></a>\n<h2 id=\"1-2-文章小贴士\"><a href=\"#1-2-文章小贴士\" class=\"headerlink\" title=\"1.2 文章小贴士\"></a>1.2 文章小贴士</h2><h3 id=\"1-2-1-笔者开发运行环境\"><a href=\"#1-2-1-笔者开发运行环境\" class=\"headerlink\" title=\"1.2.1 笔者开发运行环境\"></a>1.2.1 笔者开发运行环境</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; lennybai@lennybai~$ lsb_release <span class=\"_\">-a</span></div><div class=\"line\">&gt; No LSB modules are available.</div><div class=\"line\">&gt; Distributor ID:\tUbuntu</div><div class=\"line\">&gt; Description:\tUbuntu 16.04.1 LTS</div><div class=\"line\">&gt; Release:\t16.04</div><div class=\"line\">&gt; Codename:\txenial</div><div class=\"line\"></div><div class=\"line\">&gt; lennybai@lennybai:~$ g++ --version</div><div class=\"line\">&gt; g++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609</div><div class=\"line\">&gt; Copyright (C) 2015 Free Software Foundation, Inc.</div><div class=\"line\">&gt; This is free software; see the <span class=\"built_in\">source</span> <span class=\"keyword\">for</span> copying conditions.  There is NO</div><div class=\"line\">warranty; not even <span class=\"keyword\">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</div></pre></td></tr></table></figure>\n<h3 id=\"1-2-2-小贴士\"><a href=\"#1-2-2-小贴士\" class=\"headerlink\" title=\"1.2.2 小贴士\"></a>1.2.2 小贴士</h3><blockquote>\n<p>g++ main.cpp -std=c++11　　</p>\n</blockquote>\n<p>若使用c++11，请记得添加编译选项</p>\n<h3 id=\"1-2-3-原创提醒\"><a href=\"#1-2-3-原创提醒\" class=\"headerlink\" title=\"1.2.3 原创提醒\"></a>1.2.3 原创提醒</h3><p>　　本文主要目的在于个人学习与记录，如果能够有幸帮助到同样在修行的同僚那自然是件幸事，引用还望注明出处。笔者在写作过程中也会大量的阅读各种文章以增强理解，当然，会尽最大可能去注明文章引用，如果存在问题，希望指正。</p>\n<hr>\n<h1 id=\"二、正篇\"><a href=\"#二、正篇\" class=\"headerlink\" title=\"二、正篇\"></a>二、正篇</h1><p>　　对于学习新东西，我的习惯一般都是先google或者baidu看大量的博客来给自己洗脑，让自己有一定的知识轮廓。接下来就会开始啃官方文档，或者阅读刚刚浏览过的博客中推荐的各种书籍。当然，如果有个不错的视频教程让自己快进着点一点最好不过了，很多效果一目了然。</p>\n<p>　　在stackoverflow上，有人给出了不错的<a href=\"http://stackoverflow.com/a/388282\" target=\"_blank\" rel=\"external\">书籍大纲</a>，这些对于积累知识的初学者更有益。对于那些对于传统c++已经很熟悉，只是希望快速的了解c++11的新特性，并择机使用的选手来说，实验楼的<a href=\"https://www.shiyanlou.com/courses/605/labs/2022/document\" target=\"_blank\" rel=\"external\">《C++ 11/14 高速上手教程》</a>免费在线课程可能会更有帮助。</p>\n<p>　　本文主要基于实验楼的课程大纲进行整理，并进行部分知识点的拓展完善。</p>\n<h2 id=\"2-1-弃用-deprecated-特性\"><a href=\"#2-1-弃用-deprecated-特性\" class=\"headerlink\" title=\"2.1 弃用(deprecated)特性\"></a>2.1 弃用(deprecated)特性</h2><p>　　c++11提及到部分弃用特性。这里弃用并不等于废除并从标准中移除，而是警醒程序员在使用c++的时候能够意识到某些特性应避免使用。其实可能为了保证兼容性，这些特性可能永远不会被剔除出去（通常情况下是在编译的时，会显示一个弃用的warning），依旧可以被使用。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">lennybai@lennybai:~/Desktop/cpp11$ g++ main.cpp -std=c++11</div><div class=\"line\">main.cpp: In <span class=\"keyword\">function</span> ‘int main()’:</div><div class=\"line\">main.cpp:7:15: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</div><div class=\"line\">     char* a = <span class=\"string\">\"hello world\"</span>;</div></pre></td></tr></table></figure></p>\n<p>　　但是我们应该尽量遵循语言的发展与变迁，适当的改变自己对语言的使用方式。一个不恰当的例子，就好比黑白彩电置于当今社会，依然可以被使用，但是有更好的选择时为什么不去尝试呢？</p>\n<h3 id=\"2-1-1-被移除或者弃用的特性\"><a href=\"#2-1-1-被移除或者弃用的特性\" class=\"headerlink\" title=\"2.1.1 被移除或者弃用的特性\"></a>2.1.1 被移除或者弃用的特性</h3><blockquote>\n<ul>\n<li>std::auto_ptr 被 std::unique_ptr 取代。</li>\n<li>exception specifications</li>\n<li>bool 类型的 ++ 操作被弃用。</li>\n<li>export: 用法已被去掉,但关键字还是被保留了,给将来可能的特性使用</li>\n<li>函数对象的基类(std::unary_function, std::binary_function)、函数指针适配器、类型成员指针适配器以及绑定器 (binder)。</li>\n<li><a href=\"http://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022330.html\" target=\"_blank\" rel=\"external\">顺序点</a> (sequence point): 这个术语正被更为易懂的描述所取代。一个运算可以发生 (is sequenced before) 在另一个运算之前; 又或者两个运算彼此之间没有顺序关系 (are unsequenced)。</li>\n</ul>\n</blockquote>\n<p>　　就像前面提到的，被弃用的特性应该引起一定的重视。这里主要参考维基百科上面提到的内容列出了一些已经被弃用的特性。在以后的学习过程中也会不断完善这一部分。</p>\n<h2 id=\"2-2-新特性\"><a href=\"#2-2-新特性\" class=\"headerlink\" title=\"2.2 新特性\"></a>2.2 新特性</h2><p>　　对于c++11的新特性应该是阅读本文的客官们更关心的。c++11新特性包括但不完全是：lambda表达式，类型推断关键字auto、decltype和对模板的大量改进。在这一章节我们进行详细阐述。</p>\n<h3 id=\"2-2-1-自动类型推断（auto-decltype）\"><a href=\"#2-2-1-自动类型推断（auto-decltype）\" class=\"headerlink\" title=\"2.2.1 自动类型推断（auto/decltype）\"></a>2.2.1 自动类型推断（auto/decltype）</h3><p>　　对于传统c++而言，变量的类型都必须明确定义。虽然已经习惯传统c++编程的朋友们在声明或者定义基本类型(如int、char等)的变量时，并没有太多不妥的感觉。然而，可能也会在使用复杂模板时，觉得代码有点又丑又长。比如常见的迭代器声明:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>,UserDefClass&lt;userDefTemptype&gt; &gt;::iterator itr= userMap.begin(); itr !=userMap.end(); ++itr)</div></pre></td></tr></table></figure></p>\n<p>　　这里我列出了一个比较夸张的例子，目的是希望指出自动类型推断存在的意义。它其实已经很普遍的存在于现代编程语言之中(如python, javascript等脚本语言)。而在c++11中，通过对传统c++中auto关键字的修改得到自动类型推断的支持。<br>　　auto关键字在传统c++中用来指定存储期，一般用于指明具有自动生命周期的变量。最常见的就是函数内的局部变量。编译器在做编译时，对一般不是static修饰的变量，则默认赋予auto类型，所以auto关键字几乎很少被使用。在传统c++中，auto关键字的使用方法如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">int</span> a;</div></pre></td></tr></table></figure></p>\n<p>　　而在c++11中，auto的功能变为了类型自动推断,编译器会根据初始代码推断所声明变量的真实类型。将类型判断的工作由程序员交给了编译器，这样，在一定程度提高了代码开发的效率。而且，大部分情况下会直观的发现，代码变的更简短(当然int类型还是要比auto少一个字符)。这里是使用auto对上面繁重代码的优化:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> itr= userMap.begin(); itr !=userMap.end(); ++itr)</div></pre></td></tr></table></figure></p>\n<p>　　有没有很酷！接下来我们来看一下auto的具体使用，来更详细的了解一下它的功能。同时，也要学习一下它的使用规则。auto在c++11中，最容易理解的使用方式莫过于变量定义时的类型推断:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> a = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> b = <span class=\"string\">'A'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"string\">\"hello\"</span>)</span></span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(a).name() &lt;&lt; <span class=\"built_in\">endl</span>;    　<span class=\"comment\">// “a:i”</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b:\"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(b).name() &lt;&lt; <span class=\"built_in\">endl</span>;    　<span class=\"comment\">// \"b:c\"</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"c:\"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(c).name() &lt;&lt; <span class=\"built_in\">endl</span>;    　<span class=\"comment\">// \"c:PKc\"</span></div></pre></td></tr></table></figure></p>\n<p>　　这里我们可以看到，对于变量可以不用明确的去定义其类型，而是用auto代替。其最终效果与传统c++的变量定义效果没有差别。这里可以通过typeid函数进行验证(#include&lt; typeinfo &gt;).<br>　　在很多对于auto的讲解中，它常常被称作占位符。所谓占位符，我的理解是它不能像数据类型那样去声明一个变量。所以使用auto的变量必须进行初始化。理所当然的，也就不能使用c++类型转化将变量转换为auto类型。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> a;         <span class=\"comment\">//error: declaration of ‘auto a’ has no initializer</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> value1 = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> value2 = (<span class=\"keyword\">auto</span>)value1;    <span class=\"comment\">// error: invalid use of ‘auto’</span></div><div class=\"line\"><span class=\"keyword\">auto</span> value3 = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">auto</span>&gt;(value１);    <span class=\"comment\">// error: invalid use of ‘auto’</span></div></pre></td></tr></table></figure></p>\n<p>　　c++11已经彻底废弃了原有auto的使用方式，如代码所示:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;  <span class=\"comment\">//error: two or more data types in declaration of ‘a’</span></div></pre></td></tr></table></figure></p>\n<p>　　auto可以接受c++的变量名表列的方式定义多个变量，但所有变量应具有相同的数据类型。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> a1=<span class=\"number\">10</span>, a2=<span class=\"number\">20</span>, a3=<span class=\"number\">30</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> a4=<span class=\"number\">10</span>, a5=<span class=\"number\">20.0</span>, a6 = <span class=\"string\">'A'</span>;    <span class=\"comment\">// error: conflicting declaration</span></div></pre></td></tr></table></figure></p>\n<p>　　auto在初始化时，会自动去除引用、const、volatile的语意。这种说法可能很难理解。其实就是如果原始变量为引用、const、volatile类型，auto初始化时需要自行指明。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> refa = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refb = refa;</div><div class=\"line\"><span class=\"keyword\">auto</span> refc = refb;</div><div class=\"line\"><span class=\"keyword\">auto</span> &amp;refd = refb;</div><div class=\"line\">refa = <span class=\"number\">100</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refa: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refa).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refa &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 100</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refb: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refb).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refb &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 100</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refc: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refc).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refc &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refd: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refd).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refd &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 100</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> arrA[<span class=\"number\">3</span>] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">auto</span> arrB = arrA;</div><div class=\"line\"><span class=\"keyword\">auto</span> &amp;refArrB = arrA;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"arrA: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(arrA).name() &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// A3_i</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"arrB: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(arrB).name() &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//Pi</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refArrB: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refArrB).name() &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// A3_i</span></div></pre></td></tr></table></figure></p>\n<p>　　auto关键字不仅可以配合变量使用，它在对传统c++函数的代码优化上也可以说是大放异彩。特别是针对那些具有模板类型的函数，更是让我们在编写时变的简单高效。我们来看第一个例子。这里我们在模板函数中使用auto定义了一个站位变量。这样就使得该变量在随着传入值的类型发生变化时，自动进行类型转换。是不是很方便。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _Tx,<span class=\"keyword\">typename</span> _Ty&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(_Tx x, _Ty y)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">auto</span> v = x*y;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; v &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//call func</span></div><div class=\"line\">func3(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">// 2</span></div><div class=\"line\">func3(<span class=\"number\">1.1</span>,<span class=\"number\">2.2</span>);    <span class=\"comment\">// 2.42</span></div></pre></td></tr></table></figure>\n<p>　　auto关键字可以在函数中使用，那我们自然会想到，它能不能作为函数的返回值占位符。c++11自然提供了这种机制。但是用法可能和我们预期有一定的差距。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto func(int x, int y)-&gt;int</div><div class=\"line\">&#123;</div><div class=\"line\">    return x+y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　在c++11中，这样的返回值看起来很奇葩。使用auto来标注函数返回值时，还需要在末尾指定返回类型。会不会觉得还不如不用auto类型。但我觉得制定标准的人肯定也会考虑到这个问题。自然就去搜索了一些相关内容:</p>\n<ol>\n<li>在函数返回值特别长的时候放在末尾，会显得好看。</li>\n<li>c++14会把返回值去掉，让编译器直接支持自动推倒（c++14确实是做到了）</li>\n<li>出现在函数后面的表达式在代码编译时也是出现在函数之后的，这就使得很多函数中的临时变量可以出现在这个表达式中。这个我们在后面的decltype使用中可以看到效果。(显然，这个才是我认为最重要的)</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//c++14　支持</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x+y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　这种auto作为函数返回值占位符的用法，会使编写复杂的模板函数时变得相当简单和灵活。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">template &lt;typename _Tx, typename _Ty&gt;</div><div class=\"line\">auto func(_Tx x, _Ty y) -&gt; decltype(x*y)</div><div class=\"line\">&#123;</div><div class=\"line\">    return x*y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//call func</div><div class=\"line\">auto funcA = func(1,2);</div><div class=\"line\">cout &lt;&lt; funcA &lt;&lt; endl;    // 2</div><div class=\"line\">funcA = func(1.1,2.2);</div><div class=\"line\">cout &lt;&lt; funcA &lt;&lt; endl;    // 2</div><div class=\"line\">auto funcB = func(1.1,2.2);</div><div class=\"line\">cout &lt;&lt; funcB &lt;&lt; endl;    // 2.42</div></pre></td></tr></table></figure>\n<p>  这里用到了decltype(declared type)，它可以用来通过传入的参数来声明类型。这样func这个模板函数的会很方便的随着模板传入类型来自动改变返回值类型。bravo！</p>\n<p>  decltype不存在太多的歧义，这里直接列出代码。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int declint = 10;</div><div class=\"line\">decltype(declint) declintt;</div><div class=\"line\"></div><div class=\"line\">vector&lt;int&gt; vec;</div><div class=\"line\">typedef decltype(vec.begin()) vectype;</div><div class=\"line\"></div><div class=\"line\">decltype(declint) temp1 = declint;</div><div class=\"line\">decltype((declint)) temp2 = declint; //decltype(())定义的是引用类型</div><div class=\"line\">decltype((declint)) temp3;    // error: ‘temp3’ declared as reference but not initialized</div></pre></td></tr></table></figure>\n<p>　　接下来我们说一下刚才我们提到的函数返回类型后置的问题。我们已经知道通过decltype可以根据传入参数获取最终的数据类型。那么我们将下面代码进行修改：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// origin, ok~</div><div class=\"line\">template &lt;typename _Tx, typename _Ty&gt;</div><div class=\"line\">auto func(_Tx x, _Ty y) -&gt; decltype(x*y)</div><div class=\"line\">&#123;</div><div class=\"line\">    return x*y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　一般想法是认为，返回值不就是decltype(x*y)类型么？　那我们直接放前面不是更方便。好的，我们改写一下.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// update</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _Tx, <span class=\"keyword\">typename</span> _Ty&gt;</div><div class=\"line\"><span class=\"keyword\">decltype</span>(x*y) func(_Tx x, _Ty y)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x*y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  然而：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">lennybai@lennybai:~/project/cpp11$ g++ main.cpp -std=c++11</div><div class=\"line\">main.cpp:16:10: error: ‘x’ was not declared <span class=\"keyword\">in</span> this scope</div><div class=\"line\"> decltype(x*y) func4(_Tx x, _Ty y)</div><div class=\"line\">          ^</div><div class=\"line\">main.cpp:16:10: error: ‘x’ was not declared <span class=\"keyword\">in</span> this scope</div><div class=\"line\">main.cpp:16:12: error: ‘y’ was not declared <span class=\"keyword\">in</span> this scope</div><div class=\"line\"> decltype(x*y) func4(_Tx x, _Ty y)</div><div class=\"line\">            ^</div></pre></td></tr></table></figure>\n<p>　　是的，结果就是这么神奇。这也说明　’function-&gt;expr‘ 中的expr是出现在函数之后的。如果不使用auto占位符，而直接使用decltype(x*y)声明函数类型。由于x,y在函数运行前尚未明确类型，所以这里就会出现编译错误。</p>\n<p>　　在这一小节最后需要指出的是，auto是不能作为参数占位符出现的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 客官不可以哦</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">auto</span> x)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">     <span class=\"comment\">//do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-2-指针空值nullptr\"><a href=\"#2-2-2-指针空值nullptr\" class=\"headerlink\" title=\"2.2.2 指针空值nullptr\"></a>2.2.2 指针空值nullptr</h3><p>　　在传统c++中，通常使用NULL来标识空指针。NULL通常是一个与0相关的宏定义。这里是/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h中对NULL的定义。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined (_STDDEF_H) || defined (__need_NULL)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> NULL\t\t<span class=\"comment\">/* in case &lt;stdio.h&gt; has defined it. */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __GNUG__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL __null</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>   <span class=\"comment\">/* G++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __cplusplus</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL ((void *)0)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>   <span class=\"comment\">/* C++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL 0</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  <span class=\"comment\">/* C++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  <span class=\"comment\">/* G++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>\t<span class=\"comment\">/* NULL not defined and &lt;stddef.h&gt; or need NULL.  */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span>\t__need_NULL</span></div></pre></td></tr></table></figure></p>\n<p>　　我们发现在传统C++中，NULL被定义为0。由于没有类型限制，它可以被强制转换为各种其他数据类型。最常见的例子就是当出现函数重载时会发生混乱。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int n) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> *p)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int *p) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"></div><div class=\"line\">func(<span class=\"literal\">NULL</span>); <span class=\"comment\">// error: call of overloaded ‘func(NULL)’ is ambiguous</span></div></pre></td></tr></table></figure></p>\n<p>　　为了区分不同类型的空指针，C++11引入了nullptr_t类型的指针空值nullptr。它可以自动隐性的转换为所需的成员指针或者函数指针的类型。从而使程序更加清晰明了。值得注意的是，nullptr只能用来标识指针类型。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int n) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> *p)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int *p) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nIntNull = <span class=\"literal\">NULL</span>;        <span class=\"comment\">// ok</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *pIntNull = <span class=\"literal\">NULL</span>;        <span class=\"comment\">// ok</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *pIntNullptr = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">// ok</span></div><div class=\"line\">    <span class=\"keyword\">int</span> nIntNullptr = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">// error: cannot convert ‘std::nullptr_t’ to ‘int’ in initialization</span></div><div class=\"line\"></div><div class=\"line\">    func(<span class=\"literal\">NULL</span>); <span class=\"comment\">// error: call of overloaded ‘func(NULL)’ is ambiguous</span></div><div class=\"line\">    func(<span class=\"literal\">nullptr</span>); <span class=\"comment\">// call func(int *p)</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-3-常量区分符constexpr\"><a href=\"#2-2-3-常量区分符constexpr\" class=\"headerlink\" title=\"2.2.3 常量区分符constexpr\"></a>2.2.3 常量区分符constexpr</h3><p>　　常量表达式在c++中还是很常见的，特别是在数组或者容器等初始化时传入的大小通常为常量表达式。在C++中，常量表达式通常被解释为在编译时可以明确其值的表达式。最常见的常量表达式就是被const标识的变量：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>, n&gt; a1; <span class=\"comment\">// error, n is not a constant expression</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cn = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>, cn&gt; a2; <span class=\"comment\">// OK, cn is a constant expression</span></div></pre></td></tr></table></figure></p>\n<p>　　其实，在我们进行程序设计的时候，常常会发现很多情况是需要根据运行情况去获取一个值，然后再进行数据或者容器大小的分配。而这些值我们在给定条件值之后，很容易就会被推导出来。而对于计算机来说，却需要在每次运行时不断重复相同的推倒工作。那么我们可能会觉得，如果可以像常量表达式那样在编译时就确定其值，是不是在运行时就可以得到更高的运行效率呢。c++为我们提供了常量区分符constexpr来实现这一效果。<br>　　constexpr用来标示一个变量或者函数为常量表达式，也是告诉编译器需要去验证它们是不是一个常量表达式。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">int x;</div><div class=\"line\">struct A &#123;</div><div class=\"line\">    constexpr A(bool b) : m(b?42:x) &#123; &#125;</div><div class=\"line\">    int m;</div><div class=\"line\">&#125;;</div><div class=\"line\">constexpr int v = A(true).m; // OK</div><div class=\"line\">constexpr int w = A(false).m; // error: non-const x</div><div class=\"line\">constexpr int mf = 20;          // 20是常量表达式</div><div class=\"line\">constexpr int limit = mf + 1;   // mf + 1是常量表达式</div><div class=\"line\">constexpr int sz = size();      // 只有当size是一个constexpr函数时才是一条正确的声明语句</div><div class=\"line\"></div><div class=\"line\">constexpr int A()</div><div class=\"line\">&#123;</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">constexpr int fibonacci1(const int n) &#123;</div><div class=\"line\">    return n == 1 || n == 2 ? 1 : fibonacci1(n-1)+fibonacci1(n-2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// c++11 error error: body of constexpr function ‘constexpr int fibonacci2(int)’ not a return-statement</div><div class=\"line\">// c++14 OK</div><div class=\"line\"> constexpr int fibonacci2(const int n) &#123;</div><div class=\"line\">     if(n == 1) return 1;</div><div class=\"line\">  　 if(n == 2) return 1;</div><div class=\"line\">  　 return fibonacci2(n-1)+fibonacci2(n-2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int i1 = 10;</div><div class=\"line\">const int i2 = i1;</div><div class=\"line\">const int i3 = 10;</div><div class=\"line\">constexpr int x1 = i1;    // error: the value of ‘i1’ is not usable in a constant expression</div><div class=\"line\">constexpr int x2 = i2;    // error: the value of ‘i2’ is not usable in a constant expression</div><div class=\"line\">constexpr int x3 = i3;    // ok</div><div class=\"line\">constexpr int x4 = 10;    // ok</div><div class=\"line\">constexpr int x5 = A();   // ok</div><div class=\"line\">constexpr int x6 = fibonacci1(10);    // ok</div><div class=\"line\">constexpr int x7 = cin.get(); // !error</div><div class=\"line\">constexpr int x8 = fibonacci2(10);</div><div class=\"line\"></div><div class=\"line\">int a[i2];    // ok</div><div class=\"line\">int b[x4];    // ok</div></pre></td></tr></table></figure></p>\n<p>　　从上面的代码中我们可以大概了解到constexpr的作用与用法。这里以上代码进行一些说明：</p>\n<ol>\n<li>c++11中对constexpr修饰的函数只能直接返回常量表达式。c++14中进行了增强，它可以支持局部变量和条件语句等。</li>\n<li><p>const int i2为运行时赋值，所以x2 = i2 报错； const int i3为常量表达式，所以x3=i3没问题</p>\n<p> 对于constexpr可以在这里<a href=\"http://cpptruths.blogspot.jp/2011/07/want-speed-use-constexpr-meta.html\" target=\"_blank\" rel=\"external\">了解更多</a>。</p>\n</li>\n</ol>\n<h3 id=\"2-2-4-range-based-for-loop\"><a href=\"#2-2-4-range-based-for-loop\" class=\"headerlink\" title=\"2.2.4 range-based for loop\"></a>2.2.4 range-based for loop</h3><p>　　在cppreference中，这个特性被描述为：</p>\n<blockquote>\n<p>Executes a for loop over a range.Used as a more readable equivalent to the traditional for loop operating over a range of values, such as all elements in a container.　</p>\n</blockquote>\n<p>　<br>　　这个描述有些官方和笼统。其实，range-based for loop在c++11中加入，它使得c++开始支持类似于’foreach’的范式格式。这种新格式使得我们获取或者操作数组时变得更容易，前提是我们不去关心索引，迭代器和数量的前提下。range-based　for loop可以支持迭代所有的c类型数组，初始化列表和重载了begin()和end()函数的容器。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; m;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</div><div class=\"line\">    v.push_back(<span class=\"number\">1</span>);</div><div class=\"line\">    v.push_back(<span class=\"number\">2</span>);</div><div class=\"line\">    v.push_back(<span class=\"number\">3</span>);</div><div class=\"line\">    m[<span class=\"string\">\"my_vector\"</span>] = v;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; tempM : m)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; tempM.first &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; tempV : tempM.second)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; tempV &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>&amp; e : arr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; e &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        e = e*e;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>&amp; e : arr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; e &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-5-快速初始化列表\"><a href=\"#2-2-5-快速初始化列表\" class=\"headerlink\" title=\"2.2.5 快速初始化列表\"></a>2.2.5 快速初始化列表</h3><p>　　在c++11中，它提供了更便捷，或者说是更人性化的初始化方式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//c++ 98 error: in C++98 ‘m’ must be initialized by constructor, not by ‘&#123;...&#125;’</span></div><div class=\"line\"><span class=\"comment\">//c++ 11</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; v[<span class=\"number\">3</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//c++98 error: could not convert ‘&#123;&#123;1, 2&#125;&#125;’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘std::map&lt;int, int&gt;’</span></div><div class=\"line\"><span class=\"comment\">//c++11 ok</span></div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;&#125;;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; m[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure></p>\n<p>  对于对象的内部属性初始化，我们可以通过调用参数为initializer_list的方法快速初始化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> myclass &#123;</div><div class=\"line\">  myclass (<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>);</div><div class=\"line\">  myclass (<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt;);</div><div class=\"line\">  <span class=\"comment\">/* definitions ... */</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">myclass foo &#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>&#125;;  <span class=\"comment\">// calls initializer_list ctor</span></div><div class=\"line\"><span class=\"function\">myclass <span class=\"title\">bar</span> <span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">20</span>)</span></span>;  <span class=\"comment\">// calls first constructor</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-6-类型别名\"><a href=\"#2-2-6-类型别名\" class=\"headerlink\" title=\"2.2.6 类型别名\"></a>2.2.6 类型别名</h3><p>　　传统c++同常使用typedef为类型定义一个新的名称。给函数声明去做个别名是比较常见的使用方式。</p>\n<blockquote>\n<p>typedef void (*SigHandler)(int);</p>\n</blockquote>\n<p>　　这个是unix中信号处理的圆形函数。它讲一个参数为int并返回值为void的函数原型重命名为SigHandler.这个原型相对还比较容易理解。但在我们平时的编程过程中，遇到的情况往往比这要复杂得多。c++11为我们提供了一个更符合人类思维和更直观的表述方式(这话是我自己说的，不要追究责任２３３３３３)。</p>\n<blockquote>\n<p>using SigHandler = void(*)(int);</p>\n</blockquote>\n<p>　　这里就提高了using关键字。在传统c++中，对于using 我们可能唯一的用法就是using namespace。而在c++11中，它获得了更多的功能。下面我们继续说一些其他的别名使用情况。提到类型别名，我们有的时候会想到，能不能讲某些又臭又长的模板类型给做个别名。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> X, <span class=\"keyword\">typename</span> Y, <span class=\"keyword\">typename</span> Z&gt;</div><div class=\"line\"><span class=\"keyword\">class</span> MyTest</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    MyTest();</div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~MyTest();</div><div class=\"line\">  <span class=\"keyword\">private</span>:</div><div class=\"line\">    X x;</div><div class=\"line\">    Y y;</div><div class=\"line\">    Z z;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> U&gt;</div><div class=\"line\"><span class=\"keyword\">typedef</span> MyTest&lt;<span class=\"keyword\">int</span>,U,<span class=\"keyword\">int</span>&gt; mm; <span class=\"comment\">//error: template declaration of ‘typedef’</span></div></pre></td></tr></table></figure></p>\n<p>  在传统c++中，它并不支持对上述初始化部分类型的模板类进行再次重命名。而c++11中可以通过using关键字得到实现。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> U&gt;</div><div class=\"line\"><span class=\"keyword\">using</span> mm = MyTest&lt;<span class=\"keyword\">int</span>,U,<span class=\"keyword\">int</span>&gt;;</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"3-参考文献\"><a href=\"#3-参考文献\" class=\"headerlink\" title=\"3 参考文献\"></a>3 参考文献</h1><ul>\n<li>[1]: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" target=\"_blank\" rel=\"external\">c++标准</a></li>\n<li>[2]: <a href=\"http://en.cppreference.com/w/cpp/types/NULL\" target=\"_blank\" rel=\"external\">cppreference</a></li>\n<li>[3]: <a href=\"http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\" target=\"_blank\" rel=\"external\">Ten C++11 Features Every C++ Developer Should Use</a></li>\n</ul>\n","excerpt":"<h1 id=\"一、简介\"><a href=\"#一、简介\" class=\"headerlink\" title=\"一、简介\"></a>一、简介</h1><p>　　起草本文的目的主要有两点：第一点，在c++11学习的过程中做一些摘要总结，尽量取其精华，为自己梳理出来一个比较清晰的记忆脉络；第二点，不得不说的就是随着年纪的增长，记忆力也开始变得并不那么可靠，做些记录，定期回头看看总是好的。<br>　　文章会对c++11（其实是c++1x更准确些）的背景进行简要的概述，并尽量详细且准确的阐述c++11的新的特性。共同学习，不断进步。</p>\n<h2 id=\"1-1-c-11概述\"><a href=\"#1-1-c-11概述\" class=\"headerlink\" title=\"1.1 c++11概述\"></a>1.1 c++11概述</h2><p>　　我们生活中常常谈论的c++更多的是指传统c++，又或是可以称为c++98的版本。c++11也并不是什么神秘的新语言，而是基于传统c++发布13年后的第一次重大修订。它主要基于现在软件行业发展的新需求与新诉求进行的一种调整——增加新特性并弃用部分特性。</p>","more":"<h2 id=\"1-2-文章小贴士\"><a href=\"#1-2-文章小贴士\" class=\"headerlink\" title=\"1.2 文章小贴士\"></a>1.2 文章小贴士</h2><h3 id=\"1-2-1-笔者开发运行环境\"><a href=\"#1-2-1-笔者开发运行环境\" class=\"headerlink\" title=\"1.2.1 笔者开发运行环境\"></a>1.2.1 笔者开发运行环境</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; lennybai@lennybai~$ lsb_release <span class=\"_\">-a</span></div><div class=\"line\">&gt; No LSB modules are available.</div><div class=\"line\">&gt; Distributor ID:\tUbuntu</div><div class=\"line\">&gt; Description:\tUbuntu 16.04.1 LTS</div><div class=\"line\">&gt; Release:\t16.04</div><div class=\"line\">&gt; Codename:\txenial</div><div class=\"line\"></div><div class=\"line\">&gt; lennybai@lennybai:~$ g++ --version</div><div class=\"line\">&gt; g++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609</div><div class=\"line\">&gt; Copyright (C) 2015 Free Software Foundation, Inc.</div><div class=\"line\">&gt; This is free software; see the <span class=\"built_in\">source</span> <span class=\"keyword\">for</span> copying conditions.  There is NO</div><div class=\"line\">warranty; not even <span class=\"keyword\">for</span> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</div></pre></td></tr></table></figure>\n<h3 id=\"1-2-2-小贴士\"><a href=\"#1-2-2-小贴士\" class=\"headerlink\" title=\"1.2.2 小贴士\"></a>1.2.2 小贴士</h3><blockquote>\n<p>g++ main.cpp -std=c++11　　</p>\n</blockquote>\n<p>若使用c++11，请记得添加编译选项</p>\n<h3 id=\"1-2-3-原创提醒\"><a href=\"#1-2-3-原创提醒\" class=\"headerlink\" title=\"1.2.3 原创提醒\"></a>1.2.3 原创提醒</h3><p>　　本文主要目的在于个人学习与记录，如果能够有幸帮助到同样在修行的同僚那自然是件幸事，引用还望注明出处。笔者在写作过程中也会大量的阅读各种文章以增强理解，当然，会尽最大可能去注明文章引用，如果存在问题，希望指正。</p>\n<hr>\n<h1 id=\"二、正篇\"><a href=\"#二、正篇\" class=\"headerlink\" title=\"二、正篇\"></a>二、正篇</h1><p>　　对于学习新东西，我的习惯一般都是先google或者baidu看大量的博客来给自己洗脑，让自己有一定的知识轮廓。接下来就会开始啃官方文档，或者阅读刚刚浏览过的博客中推荐的各种书籍。当然，如果有个不错的视频教程让自己快进着点一点最好不过了，很多效果一目了然。</p>\n<p>　　在stackoverflow上，有人给出了不错的<a href=\"http://stackoverflow.com/a/388282\">书籍大纲</a>，这些对于积累知识的初学者更有益。对于那些对于传统c++已经很熟悉，只是希望快速的了解c++11的新特性，并择机使用的选手来说，实验楼的<a href=\"https://www.shiyanlou.com/courses/605/labs/2022/document\">《C++ 11/14 高速上手教程》</a>免费在线课程可能会更有帮助。</p>\n<p>　　本文主要基于实验楼的课程大纲进行整理，并进行部分知识点的拓展完善。</p>\n<h2 id=\"2-1-弃用-deprecated-特性\"><a href=\"#2-1-弃用-deprecated-特性\" class=\"headerlink\" title=\"2.1 弃用(deprecated)特性\"></a>2.1 弃用(deprecated)特性</h2><p>　　c++11提及到部分弃用特性。这里弃用并不等于废除并从标准中移除，而是警醒程序员在使用c++的时候能够意识到某些特性应避免使用。其实可能为了保证兼容性，这些特性可能永远不会被剔除出去（通常情况下是在编译的时，会显示一个弃用的warning），依旧可以被使用。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">lennybai@lennybai:~/Desktop/cpp11$ g++ main.cpp -std=c++11</div><div class=\"line\">main.cpp: In <span class=\"keyword\">function</span> ‘int main()’:</div><div class=\"line\">main.cpp:7:15: warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]</div><div class=\"line\">     char* a = <span class=\"string\">\"hello world\"</span>;</div></pre></td></tr></table></figure></p>\n<p>　　但是我们应该尽量遵循语言的发展与变迁，适当的改变自己对语言的使用方式。一个不恰当的例子，就好比黑白彩电置于当今社会，依然可以被使用，但是有更好的选择时为什么不去尝试呢？</p>\n<h3 id=\"2-1-1-被移除或者弃用的特性\"><a href=\"#2-1-1-被移除或者弃用的特性\" class=\"headerlink\" title=\"2.1.1 被移除或者弃用的特性\"></a>2.1.1 被移除或者弃用的特性</h3><blockquote>\n<ul>\n<li>std::auto_ptr 被 std::unique_ptr 取代。</li>\n<li>exception specifications</li>\n<li>bool 类型的 ++ 操作被弃用。</li>\n<li>export: 用法已被去掉,但关键字还是被保留了,给将来可能的特性使用</li>\n<li>函数对象的基类(std::unary_function, std::binary_function)、函数指针适配器、类型成员指针适配器以及绑定器 (binder)。</li>\n<li><a href=\"http://www.cnblogs.com/dolphin0520/archive/2011/04/20/2022330.html\">顺序点</a> (sequence point): 这个术语正被更为易懂的描述所取代。一个运算可以发生 (is sequenced before) 在另一个运算之前; 又或者两个运算彼此之间没有顺序关系 (are unsequenced)。</li>\n</ul>\n</blockquote>\n<p>　　就像前面提到的，被弃用的特性应该引起一定的重视。这里主要参考维基百科上面提到的内容列出了一些已经被弃用的特性。在以后的学习过程中也会不断完善这一部分。</p>\n<h2 id=\"2-2-新特性\"><a href=\"#2-2-新特性\" class=\"headerlink\" title=\"2.2 新特性\"></a>2.2 新特性</h2><p>　　对于c++11的新特性应该是阅读本文的客官们更关心的。c++11新特性包括但不完全是：lambda表达式，类型推断关键字auto、decltype和对模板的大量改进。在这一章节我们进行详细阐述。</p>\n<h3 id=\"2-2-1-自动类型推断（auto-decltype）\"><a href=\"#2-2-1-自动类型推断（auto-decltype）\" class=\"headerlink\" title=\"2.2.1 自动类型推断（auto/decltype）\"></a>2.2.1 自动类型推断（auto/decltype）</h3><p>　　对于传统c++而言，变量的类型都必须明确定义。虽然已经习惯传统c++编程的朋友们在声明或者定义基本类型(如int、char等)的变量时，并没有太多不妥的感觉。然而，可能也会在使用复杂模板时，觉得代码有点又丑又长。比如常见的迭代器声明:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"built_in\">map</span> &lt; <span class=\"keyword\">int</span>,UserDefClass&lt;userDefTemptype&gt; &gt;::iterator itr= userMap.begin(); itr !=userMap.end(); ++itr)</div></pre></td></tr></table></figure></p>\n<p>　　这里我列出了一个比较夸张的例子，目的是希望指出自动类型推断存在的意义。它其实已经很普遍的存在于现代编程语言之中(如python, javascript等脚本语言)。而在c++11中，通过对传统c++中auto关键字的修改得到自动类型推断的支持。<br>　　auto关键字在传统c++中用来指定存储期，一般用于指明具有自动生命周期的变量。最常见的就是函数内的局部变量。编译器在做编译时，对一般不是static修饰的变量，则默认赋予auto类型，所以auto关键字几乎很少被使用。在传统c++中，auto关键字的使用方法如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">int</span> a;</div></pre></td></tr></table></figure></p>\n<p>　　而在c++11中，auto的功能变为了类型自动推断,编译器会根据初始代码推断所声明变量的真实类型。将类型判断的工作由程序员交给了编译器，这样，在一定程度提高了代码开发的效率。而且，大部分情况下会直观的发现，代码变的更简短(当然int类型还是要比auto少一个字符)。这里是使用auto对上面繁重代码的优化:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> ( <span class=\"keyword\">auto</span> itr= userMap.begin(); itr !=userMap.end(); ++itr)</div></pre></td></tr></table></figure></p>\n<p>　　有没有很酷！接下来我们来看一下auto的具体使用，来更详细的了解一下它的功能。同时，也要学习一下它的使用规则。auto在c++11中，最容易理解的使用方式莫过于变量定义时的类型推断:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> a = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> b = <span class=\"string\">'A'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">c</span><span class=\"params\">(<span class=\"string\">\"hello\"</span>)</span></span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a:\"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(a).name() &lt;&lt; <span class=\"built_in\">endl</span>;    　<span class=\"comment\">// “a:i”</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"b:\"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(b).name() &lt;&lt; <span class=\"built_in\">endl</span>;    　<span class=\"comment\">// \"b:c\"</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"c:\"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(c).name() &lt;&lt; <span class=\"built_in\">endl</span>;    　<span class=\"comment\">// \"c:PKc\"</span></div></pre></td></tr></table></figure></p>\n<p>　　这里我们可以看到，对于变量可以不用明确的去定义其类型，而是用auto代替。其最终效果与传统c++的变量定义效果没有差别。这里可以通过typeid函数进行验证(#include&lt; typeinfo &gt;).<br>　　在很多对于auto的讲解中，它常常被称作占位符。所谓占位符，我的理解是它不能像数据类型那样去声明一个变量。所以使用auto的变量必须进行初始化。理所当然的，也就不能使用c++类型转化将变量转换为auto类型。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> a;         <span class=\"comment\">//error: declaration of ‘auto a’ has no initializer</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> value1 = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> value2 = (<span class=\"keyword\">auto</span>)value1;    <span class=\"comment\">// error: invalid use of ‘auto’</span></div><div class=\"line\"><span class=\"keyword\">auto</span> value3 = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">auto</span>&gt;(value１);    <span class=\"comment\">// error: invalid use of ‘auto’</span></div></pre></td></tr></table></figure></p>\n<p>　　c++11已经彻底废弃了原有auto的使用方式，如代码所示:<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;  <span class=\"comment\">//error: two or more data types in declaration of ‘a’</span></div></pre></td></tr></table></figure></p>\n<p>　　auto可以接受c++的变量名表列的方式定义多个变量，但所有变量应具有相同的数据类型。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">auto</span> a1=<span class=\"number\">10</span>, a2=<span class=\"number\">20</span>, a3=<span class=\"number\">30</span>;</div><div class=\"line\"><span class=\"keyword\">auto</span> a4=<span class=\"number\">10</span>, a5=<span class=\"number\">20.0</span>, a6 = <span class=\"string\">'A'</span>;    <span class=\"comment\">// error: conflicting declaration</span></div></pre></td></tr></table></figure></p>\n<p>　　auto在初始化时，会自动去除引用、const、volatile的语意。这种说法可能很难理解。其实就是如果原始变量为引用、const、volatile类型，auto初始化时需要自行指明。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> refa = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">int</span> &amp;refb = refa;</div><div class=\"line\"><span class=\"keyword\">auto</span> refc = refb;</div><div class=\"line\"><span class=\"keyword\">auto</span> &amp;refd = refb;</div><div class=\"line\">refa = <span class=\"number\">100</span>;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refa: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refa).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refa &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 100</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refb: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refb).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refb &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 100</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refc: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refc).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refc &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 10</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refd: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refd).name() &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; refd &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// 100</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">int</span> arrA[<span class=\"number\">3</span>] = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</div><div class=\"line\"><span class=\"keyword\">auto</span> arrB = arrA;</div><div class=\"line\"><span class=\"keyword\">auto</span> &amp;refArrB = arrA;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"arrA: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(arrA).name() &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// A3_i</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"arrB: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(arrB).name() &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">//Pi</span></div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"refArrB: \"</span> &lt;&lt; <span class=\"keyword\">typeid</span>(refArrB).name() &lt;&lt; <span class=\"built_in\">endl</span>;    <span class=\"comment\">// A3_i</span></div></pre></td></tr></table></figure></p>\n<p>　　auto关键字不仅可以配合变量使用，它在对传统c++函数的代码优化上也可以说是大放异彩。特别是针对那些具有模板类型的函数，更是让我们在编写时变的简单高效。我们来看第一个例子。这里我们在模板函数中使用auto定义了一个站位变量。这样就使得该变量在随着传入值的类型发生变化时，自动进行类型转换。是不是很方便。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _Tx,<span class=\"keyword\">typename</span> _Ty&gt;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(_Tx x, _Ty y)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">auto</span> v = x*y;</div><div class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; v &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//call func</span></div><div class=\"line\">func3(<span class=\"number\">1</span>,<span class=\"number\">2</span>);    <span class=\"comment\">// 2</span></div><div class=\"line\">func3(<span class=\"number\">1.1</span>,<span class=\"number\">2.2</span>);    <span class=\"comment\">// 2.42</span></div></pre></td></tr></table></figure>\n<p>　　auto关键字可以在函数中使用，那我们自然会想到，它能不能作为函数的返回值占位符。c++11自然提供了这种机制。但是用法可能和我们预期有一定的差距。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">auto func(int x, int y)-&gt;int</div><div class=\"line\">&#123;</div><div class=\"line\">    return x+y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　在c++11中，这样的返回值看起来很奇葩。使用auto来标注函数返回值时，还需要在末尾指定返回类型。会不会觉得还不如不用auto类型。但我觉得制定标准的人肯定也会考虑到这个问题。自然就去搜索了一些相关内容:</p>\n<ol>\n<li>在函数返回值特别长的时候放在末尾，会显得好看。</li>\n<li>c++14会把返回值去掉，让编译器直接支持自动推倒（c++14确实是做到了）</li>\n<li>出现在函数后面的表达式在代码编译时也是出现在函数之后的，这就使得很多函数中的临时变量可以出现在这个表达式中。这个我们在后面的decltype使用中可以看到效果。(显然，这个才是我认为最重要的)</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//c++14　支持</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x+y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　这种auto作为函数返回值占位符的用法，会使编写复杂的模板函数时变得相当简单和灵活。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">template &lt;typename _Tx, typename _Ty&gt;</div><div class=\"line\">auto func(_Tx x, _Ty y) -&gt; decltype(x*y)</div><div class=\"line\">&#123;</div><div class=\"line\">    return x*y;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//call func</div><div class=\"line\">auto funcA = func(1,2);</div><div class=\"line\">cout &lt;&lt; funcA &lt;&lt; endl;    // 2</div><div class=\"line\">funcA = func(1.1,2.2);</div><div class=\"line\">cout &lt;&lt; funcA &lt;&lt; endl;    // 2</div><div class=\"line\">auto funcB = func(1.1,2.2);</div><div class=\"line\">cout &lt;&lt; funcB &lt;&lt; endl;    // 2.42</div></pre></td></tr></table></figure>\n<p>  这里用到了decltype(declared type)，它可以用来通过传入的参数来声明类型。这样func这个模板函数的会很方便的随着模板传入类型来自动改变返回值类型。bravo！</p>\n<p>  decltype不存在太多的歧义，这里直接列出代码。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">int declint = 10;</div><div class=\"line\">decltype(declint) declintt;</div><div class=\"line\"></div><div class=\"line\">vector&lt;int&gt; vec;</div><div class=\"line\">typedef decltype(vec.begin()) vectype;</div><div class=\"line\"></div><div class=\"line\">decltype(declint) temp1 = declint;</div><div class=\"line\">decltype((declint)) temp2 = declint; //decltype(())定义的是引用类型</div><div class=\"line\">decltype((declint)) temp3;    // error: ‘temp3’ declared as reference but not initialized</div></pre></td></tr></table></figure>\n<p>　　接下来我们说一下刚才我们提到的函数返回类型后置的问题。我们已经知道通过decltype可以根据传入参数获取最终的数据类型。那么我们将下面代码进行修改：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// origin, ok~</div><div class=\"line\">template &lt;typename _Tx, typename _Ty&gt;</div><div class=\"line\">auto func(_Tx x, _Ty y) -&gt; decltype(x*y)</div><div class=\"line\">&#123;</div><div class=\"line\">    return x*y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>　　一般想法是认为，返回值不就是decltype(x*y)类型么？　那我们直接放前面不是更方便。好的，我们改写一下.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// update</span></div><div class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _Tx, <span class=\"keyword\">typename</span> _Ty&gt;</div><div class=\"line\"><span class=\"keyword\">decltype</span>(x*y) func(_Tx x, _Ty y)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> x*y;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  然而：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">lennybai@lennybai:~/project/cpp11$ g++ main.cpp -std=c++11</div><div class=\"line\">main.cpp:16:10: error: ‘x’ was not declared <span class=\"keyword\">in</span> this scope</div><div class=\"line\"> decltype(x*y) func4(_Tx x, _Ty y)</div><div class=\"line\">          ^</div><div class=\"line\">main.cpp:16:10: error: ‘x’ was not declared <span class=\"keyword\">in</span> this scope</div><div class=\"line\">main.cpp:16:12: error: ‘y’ was not declared <span class=\"keyword\">in</span> this scope</div><div class=\"line\"> decltype(x*y) func4(_Tx x, _Ty y)</div><div class=\"line\">            ^</div></pre></td></tr></table></figure>\n<p>　　是的，结果就是这么神奇。这也说明　’function-&gt;expr‘ 中的expr是出现在函数之后的。如果不使用auto占位符，而直接使用decltype(x*y)声明函数类型。由于x,y在函数运行前尚未明确类型，所以这里就会出现编译错误。</p>\n<p>　　在这一小节最后需要指出的是，auto是不能作为参数占位符出现的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 客官不可以哦</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">auto</span> x)</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">     <span class=\"comment\">//do something</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-2-指针空值nullptr\"><a href=\"#2-2-2-指针空值nullptr\" class=\"headerlink\" title=\"2.2.2 指针空值nullptr\"></a>2.2.2 指针空值nullptr</h3><p>　　在传统c++中，通常使用NULL来标识空指针。NULL通常是一个与0相关的宏定义。这里是/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h中对NULL的定义。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> defined (_STDDEF_H) || defined (__need_NULL)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span> NULL\t\t<span class=\"comment\">/* in case &lt;stdio.h&gt; has defined it. */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __GNUG__</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL __null</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>   <span class=\"comment\">/* G++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> __cplusplus</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL ((void *)0)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span>   <span class=\"comment\">/* C++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NULL 0</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  <span class=\"comment\">/* C++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>  <span class=\"comment\">/* G++ */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span>\t<span class=\"comment\">/* NULL not defined and &lt;stddef.h&gt; or need NULL.  */</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">undef</span>\t__need_NULL</span></div></pre></td></tr></table></figure></p>\n<p>　　我们发现在传统C++中，NULL被定义为0。由于没有类型限制，它可以被强制转换为各种其他数据类型。最常见的例子就是当出现函数重载时会发生混乱。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int n) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> *p)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int *p) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"></div><div class=\"line\">func(<span class=\"literal\">NULL</span>); <span class=\"comment\">// error: call of overloaded ‘func(NULL)’ is ambiguous</span></div></pre></td></tr></table></figure></p>\n<p>　　为了区分不同类型的空指针，C++11引入了nullptr_t类型的指针空值nullptr。它可以自动隐性的转换为所需的成员指针或者函数指针的类型。从而使程序更加清晰明了。值得注意的是，nullptr只能用来标识指针类型。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int n) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> *p)</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"call func(int *p) : \"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> nIntNull = <span class=\"literal\">NULL</span>;        <span class=\"comment\">// ok</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *pIntNull = <span class=\"literal\">NULL</span>;        <span class=\"comment\">// ok</span></div><div class=\"line\">    <span class=\"keyword\">int</span> *pIntNullptr = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">// ok</span></div><div class=\"line\">    <span class=\"keyword\">int</span> nIntNullptr = <span class=\"literal\">nullptr</span>;    <span class=\"comment\">// error: cannot convert ‘std::nullptr_t’ to ‘int’ in initialization</span></div><div class=\"line\"></div><div class=\"line\">    func(<span class=\"literal\">NULL</span>); <span class=\"comment\">// error: call of overloaded ‘func(NULL)’ is ambiguous</span></div><div class=\"line\">    func(<span class=\"literal\">nullptr</span>); <span class=\"comment\">// call func(int *p)</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-3-常量区分符constexpr\"><a href=\"#2-2-3-常量区分符constexpr\" class=\"headerlink\" title=\"2.2.3 常量区分符constexpr\"></a>2.2.3 常量区分符constexpr</h3><p>　　常量表达式在c++中还是很常见的，特别是在数组或者容器等初始化时传入的大小通常为常量表达式。在C++中，常量表达式通常被解释为在编译时可以明确其值的表达式。最常见的常量表达式就是被const标识的变量：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>, n&gt; a1; <span class=\"comment\">// error, n is not a constant expression</span></div><div class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> cn = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>, cn&gt; a2; <span class=\"comment\">// OK, cn is a constant expression</span></div></pre></td></tr></table></figure></p>\n<p>　　其实，在我们进行程序设计的时候，常常会发现很多情况是需要根据运行情况去获取一个值，然后再进行数据或者容器大小的分配。而这些值我们在给定条件值之后，很容易就会被推导出来。而对于计算机来说，却需要在每次运行时不断重复相同的推倒工作。那么我们可能会觉得，如果可以像常量表达式那样在编译时就确定其值，是不是在运行时就可以得到更高的运行效率呢。c++为我们提供了常量区分符constexpr来实现这一效果。<br>　　constexpr用来标示一个变量或者函数为常量表达式，也是告诉编译器需要去验证它们是不是一个常量表达式。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">int x;</div><div class=\"line\">struct A &#123;</div><div class=\"line\">    constexpr A(bool b) : m(b?42:x) &#123; &#125;</div><div class=\"line\">    int m;</div><div class=\"line\">&#125;;</div><div class=\"line\">constexpr int v = A(true).m; // OK</div><div class=\"line\">constexpr int w = A(false).m; // error: non-const x</div><div class=\"line\">constexpr int mf = 20;          // 20是常量表达式</div><div class=\"line\">constexpr int limit = mf + 1;   // mf + 1是常量表达式</div><div class=\"line\">constexpr int sz = size();      // 只有当size是一个constexpr函数时才是一条正确的声明语句</div><div class=\"line\"></div><div class=\"line\">constexpr int A()</div><div class=\"line\">&#123;</div><div class=\"line\">    return 10;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">constexpr int fibonacci1(const int n) &#123;</div><div class=\"line\">    return n == 1 || n == 2 ? 1 : fibonacci1(n-1)+fibonacci1(n-2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// c++11 error error: body of constexpr function ‘constexpr int fibonacci2(int)’ not a return-statement</div><div class=\"line\">// c++14 OK</div><div class=\"line\"> constexpr int fibonacci2(const int n) &#123;</div><div class=\"line\">     if(n == 1) return 1;</div><div class=\"line\">  　 if(n == 2) return 1;</div><div class=\"line\">  　 return fibonacci2(n-1)+fibonacci2(n-2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int i1 = 10;</div><div class=\"line\">const int i2 = i1;</div><div class=\"line\">const int i3 = 10;</div><div class=\"line\">constexpr int x1 = i1;    // error: the value of ‘i1’ is not usable in a constant expression</div><div class=\"line\">constexpr int x2 = i2;    // error: the value of ‘i2’ is not usable in a constant expression</div><div class=\"line\">constexpr int x3 = i3;    // ok</div><div class=\"line\">constexpr int x4 = 10;    // ok</div><div class=\"line\">constexpr int x5 = A();   // ok</div><div class=\"line\">constexpr int x6 = fibonacci1(10);    // ok</div><div class=\"line\">constexpr int x7 = cin.get(); // !error</div><div class=\"line\">constexpr int x8 = fibonacci2(10);</div><div class=\"line\"></div><div class=\"line\">int a[i2];    // ok</div><div class=\"line\">int b[x4];    // ok</div></pre></td></tr></table></figure></p>\n<p>　　从上面的代码中我们可以大概了解到constexpr的作用与用法。这里以上代码进行一些说明：</p>\n<ol>\n<li>c++11中对constexpr修饰的函数只能直接返回常量表达式。c++14中进行了增强，它可以支持局部变量和条件语句等。</li>\n<li><p>const int i2为运行时赋值，所以x2 = i2 报错； const int i3为常量表达式，所以x3=i3没问题</p>\n<p> 对于constexpr可以在这里<a href=\"http://cpptruths.blogspot.jp/2011/07/want-speed-use-constexpr-meta.html\">了解更多</a>。</p>\n</li>\n</ol>\n<h3 id=\"2-2-4-range-based-for-loop\"><a href=\"#2-2-4-range-based-for-loop\" class=\"headerlink\" title=\"2.2.4 range-based for loop\"></a>2.2.4 range-based for loop</h3><p>　　在cppreference中，这个特性被描述为：</p>\n<blockquote>\n<p>Executes a for loop over a range.Used as a more readable equivalent to the traditional for loop operating over a range of values, such as all elements in a container.　</p>\n</blockquote>\n<p>　<br>　　这个描述有些官方和笼统。其实，range-based for loop在c++11中加入，它使得c++开始支持类似于’foreach’的范式格式。这种新格式使得我们获取或者操作数组时变得更容易，前提是我们不去关心索引，迭代器和数量的前提下。range-based　for loop可以支持迭代所有的c类型数组，初始化列表和重载了begin()和end()函数的容器。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;map&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></div><div class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">    <span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&gt; m;</div><div class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v;</div><div class=\"line\">    v.push_back(<span class=\"number\">1</span>);</div><div class=\"line\">    v.push_back(<span class=\"number\">2</span>);</div><div class=\"line\">    v.push_back(<span class=\"number\">3</span>);</div><div class=\"line\">    m[<span class=\"string\">\"my_vector\"</span>] = v;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; tempM : m)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; tempM.first &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; tempV : tempM.second)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; tempV &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">int</span> arr[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>&amp; e : arr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; e &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">        e = e*e;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>&amp; e : arr)</div><div class=\"line\">    &#123;</div><div class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; e &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-2-5-快速初始化列表\"><a href=\"#2-2-5-快速初始化列表\" class=\"headerlink\" title=\"2.2.5 快速初始化列表\"></a>2.2.5 快速初始化列表</h3><p>　　在c++11中，它提供了更便捷，或者说是更人性化的初始化方式。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//c++ 98 error: in C++98 ‘m’ must be initialized by constructor, not by ‘&#123;...&#125;’</span></div><div class=\"line\"><span class=\"comment\">//c++ 11</span></div><div class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; v[<span class=\"number\">3</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//c++98 error: could not convert ‘&#123;&#123;1, 2&#125;&#125;’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘std::map&lt;int, int&gt;’</span></div><div class=\"line\"><span class=\"comment\">//c++11 ok</span></div><div class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; m = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;&#125;;</div><div class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; m[<span class=\"number\">1</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</div></pre></td></tr></table></figure></p>\n<p>  对于对象的内部属性初始化，我们可以通过调用参数为initializer_list的方法快速初始化。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> myclass &#123;</div><div class=\"line\">  myclass (<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>);</div><div class=\"line\">  myclass (<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">int</span>&gt;);</div><div class=\"line\">  <span class=\"comment\">/* definitions ... */</span></div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">myclass foo &#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>&#125;;  <span class=\"comment\">// calls initializer_list ctor</span></div><div class=\"line\"><span class=\"function\">myclass <span class=\"title\">bar</span> <span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">20</span>)</span></span>;  <span class=\"comment\">// calls first constructor</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"2-2-6-类型别名\"><a href=\"#2-2-6-类型别名\" class=\"headerlink\" title=\"2.2.6 类型别名\"></a>2.2.6 类型别名</h3><p>　　传统c++同常使用typedef为类型定义一个新的名称。给函数声明去做个别名是比较常见的使用方式。</p>\n<blockquote>\n<p>typedef void (*SigHandler)(int);</p>\n</blockquote>\n<p>　　这个是unix中信号处理的圆形函数。它讲一个参数为int并返回值为void的函数原型重命名为SigHandler.这个原型相对还比较容易理解。但在我们平时的编程过程中，遇到的情况往往比这要复杂得多。c++11为我们提供了一个更符合人类思维和更直观的表述方式(这话是我自己说的，不要追究责任２３３３３３)。</p>\n<blockquote>\n<p>using SigHandler = void(*)(int);</p>\n</blockquote>\n<p>　　这里就提高了using关键字。在传统c++中，对于using 我们可能唯一的用法就是using namespace。而在c++11中，它获得了更多的功能。下面我们继续说一些其他的别名使用情况。提到类型别名，我们有的时候会想到，能不能讲某些又臭又长的模板类型给做个别名。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> X, <span class=\"keyword\">typename</span> Y, <span class=\"keyword\">typename</span> Z&gt;</div><div class=\"line\"><span class=\"keyword\">class</span> MyTest</div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">public</span>:</div><div class=\"line\">    MyTest();</div><div class=\"line\">    <span class=\"keyword\">virtual</span> ~MyTest();</div><div class=\"line\">  <span class=\"keyword\">private</span>:</div><div class=\"line\">    X x;</div><div class=\"line\">    Y y;</div><div class=\"line\">    Z z;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> U&gt;</div><div class=\"line\"><span class=\"keyword\">typedef</span> MyTest&lt;<span class=\"keyword\">int</span>,U,<span class=\"keyword\">int</span>&gt; mm; <span class=\"comment\">//error: template declaration of ‘typedef’</span></div></pre></td></tr></table></figure></p>\n<p>  在传统c++中，它并不支持对上述初始化部分类型的模板类进行再次重命名。而c++11中可以通过using关键字得到实现。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> U&gt;</div><div class=\"line\"><span class=\"keyword\">using</span> mm = MyTest&lt;<span class=\"keyword\">int</span>,U,<span class=\"keyword\">int</span>&gt;;</div></pre></td></tr></table></figure></p>\n<hr>\n<h1 id=\"3-参考文献\"><a href=\"#3-参考文献\" class=\"headerlink\" title=\"3 参考文献\"></a>3 参考文献</h1><ul>\n<li>[1]: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\">c++标准</a></li>\n<li>[2]: <a href=\"http://en.cppreference.com/w/cpp/types/NULL\">cppreference</a></li>\n<li>[3]: <a href=\"http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\">Ten C++11 Features Every C++ Developer Should Use</a></li>\n</ul>"},{"title":"编程珠玑","comments":0,"date":"2016-12-06T02:27:32.000Z","_content":"\n# 一、绪论\n　　编程珠玑是一本很有影响力的书籍。它是作者对自己在长期的计算机程序设计实践中积累下来的宝贵经验的总结。行文生动形象，可读性高。在美国，它被作为低年级数据结构与算法的教材，同时，也作为高年级的算法辅助教材。它涵盖了算法课程和数据结构课程的大部分内容。不同于其他教材，他不强调单纯的从数学上分析，而是强调结合实际问题进行分析、应用和实现。话不多说，开卷有益。\n<!--more-->\n# 二、概述\n　　这是第二次翻开本书。虽然被很多人推荐，但阅读一遍后，我并没有抓到什么重点。这次边读边记录，希望能够做到讲本书融会贯通。主要是记录为主，可能每一段都没有核心，也可能上下文没有逻辑性，强迫症或者性情暴躁者，慎读。\n### 准确的问题描述\n　　在程序员的日常工作中，更多的工作更像是通过程序解决问题的过程。所以更好的描述问题，或者说是自己能够对需求更准确的转化成为问题，会对后续的程序设计帮助十足。将复杂的问题简单化，模块化。同时，能否准确的描述问题，也决定这你是否将要解决一个“正确”的问题。\n　　一般情况下，对问题的描述可以概括为三个方面:\n> 准确的输入　　\n>\n> 准确的输出　　\n>\n> 准确的约束条件\n\n\n### 算法，灵机一动\n　　先进的算法有时候对软件系统影响很大——减少开发时间，同时使得执行效率更快。在算法中所谓的灵机一动，看似是“看起来很困难的问题也可以有一个简单的、意想不到的答案”。算法的灵机一动，并非只有大量的研究以后才能出现，需要的是编程之前、之中和之后进行认真的思考。伴随着这种思考，往往就能捕获到这灵机一动。\n\n### 数据决定数据结构\n　　恰当的数据视图实际上决定了程序的结构。通过重新组织内部数据是程序变得更好。在我们工作中，很多时候是可以用小程序完成任务的情况下，程序员往往最终写出了又大又纯的程序。其主要原因就是惰性：不去尝试思考，而急于完成最初的想法。\n　　程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心机去研究数据，常常会有奇效。数据的表示形式是程序设计的根本。退回起点的原则：\n1. 使用数组代替重复的代码\n2. 封装复杂结构\n3. 尽可能使用高级工具\n4. 从数据得出程序结构\n\n### 编写正确的程序\n　　必须引起注意的是，编程技巧仅仅是编写正确程序的很小一部分，大部分内容还是：问题定义、算法设计和数据结构的选择。遵循这几点的话，编写正常的程序通常是很容易的。除此之外，要记得使用测试用例和断言等去验证程序的正确性。\n\n### 让编写的程序真正可用\n　　程序员都是乐观主义者，他们总是认为讲编写完的程序，插入系统中就可以正常运行。在大部分时间是可行的，但是有的时候确实灾难性的存在，我们不得不需要在庞大的系统中，去寻找这个错误的小小的程序。\n　　良好的使用断言，可以知道程序的开发，同时也可以用来判断程序的正确性。这里作者提到了一个对于断言使用的一个小嘲讽：在测试时使用断言，而产品发布时将断言关闭的程序员，就好比在岸上操练时穿着救生衣，而下海时将救生衣脱下的水手。\n　　为了程序的可用性，往往自动测试和时间计数也显得至关重要。具有完整且完善边界测试用例能够保证程序的准确性，而且可以提高测试效率。同时，时间计数可以直观的观察程序的运行时间复杂度。\n\n### 来聊聊性能\n　　一个简单而又功能强大的程序，往往令用户欣喜而不令开发者烦恼，这是程序的终极目标。而其中一个重要的元素就是效率。低效率的程序往往令用户沮丧。等待的时间越长，也就意味着越高的概率会失去用户。而如何提高效率我们往往考虑以下途径：\n1. 通过积累经验，选择恰当的方法\n2. 粗略估算运行时间\n3. 算法设计\n4. 代码调优\n\n### 性能分析\n　　而在真正进行效率优化的时候，从计算机系统的层面我们应该从以下方面进行：\n1. 问题定义\n2. 系统结构:模块化；性能分析在系统设计阶段至关重要\n3. 算法和数据结构：快速的模块是基于其良好的表示的数据结构和操纵这些数据结构的算法\n4. 代码调优\n5. 系统软件\n6. 硬件\n\n### 粗略评估\n>　　任何事都应尽量简单，但不易于过于简单　——　爱因斯坦\n\n　　我们知道简单的计算并不简单，因为我们为了补偿估算参数时的错误和对问题的了解不足，我们往往会选定和包含安全系数。\n\n### 算法设计技术\n　　几个重要的算法设计技术\n1. 保存状态，避免重复计算\n2. 将信息预处理至数据结构中\n3. 分治算法\n4. 扫描算法\n5. 累加算法\n6. 下界\n\n### 代码调优\n　　代码调优很重要的一点是把握调优的尺度。有些程序猿过于关注程序的效率，由于太在乎细小的“优化”，它们编写出的程序过于精妙，难以维护。而一些程序员很少关注程序的效率，它们编写的程序有着清晰漂亮的结构，但效率极低以至于毫无用处。往往获取更多的可用内存空间，需要在程序的性能、功能或者可维护性上做出牺牲，所以优化的前提永远是正确的决策。\n　　代码调优是一个在程序中需要做整体考虑的工作项目，但其根本目的是解决程序中开销过大的部分，对其进行少量修改，以提高运行效率。所谓开销包括CPU时间和程序存储空间。\n　　作者在文中给出了代码调优的原理:\n> 代码调优的最重要远离就是尽量少用它　　\n> 1. 效率的角色： 没有坏的话就不要修\n> 2. 设计层面: 只有确定没有更好的解决方案时，才考虑进行代码调优\n> 3. 双刃剑\n\n### 节省空间\n　　努力的考虑一下空间紧凑的程序是很有意义的。在节省空间的同时，我们往往会得到运行时间上产生的副作用:程序小意味着加载更快，也更容易填入高速缓存中，操作的数据变少意味着操作时间变少等等。\n　　简单性可以衍生出功能性、健壮性以及速度和空间。\n　　这里列出一些较少程序所需数据的存储空间的技术:\n1. 不存储、重新计算\n2. 稀疏数据结构\n3. 数据压缩\n4. 分配策略\n5. 垃圾回收\n\n### 排序\n　　将一些列记录排成有序的，最后也是最容易的办法就是使用排序函数库。但是并非总是有效的，这时我们别无选择，只能编写自己的排序函数。\n\n### 堆\n　　采用堆排序不会超过O(nlogn)，并且只需要几个额外的字节。\n\n---\n# 写到最后\n　　读者用实践和经验去讲述程序中的问题，其实也是对我们工作和学习方法的一种提示。勿要死读书，读死书，要结合实际灵活运用。\n","source":"_posts/编程珠玑.md","raw":"---\ntitle: 编程珠玑\ncomments: false\ndate: 2016-12-06 10:27:32\ntags:\n  - 编程珠玑\n  - 读书笔记\ncategories:\n  - 读书笔记\n  - 编程珠玑\n---\n\n# 一、绪论\n　　编程珠玑是一本很有影响力的书籍。它是作者对自己在长期的计算机程序设计实践中积累下来的宝贵经验的总结。行文生动形象，可读性高。在美国，它被作为低年级数据结构与算法的教材，同时，也作为高年级的算法辅助教材。它涵盖了算法课程和数据结构课程的大部分内容。不同于其他教材，他不强调单纯的从数学上分析，而是强调结合实际问题进行分析、应用和实现。话不多说，开卷有益。\n<!--more-->\n# 二、概述\n　　这是第二次翻开本书。虽然被很多人推荐，但阅读一遍后，我并没有抓到什么重点。这次边读边记录，希望能够做到讲本书融会贯通。主要是记录为主，可能每一段都没有核心，也可能上下文没有逻辑性，强迫症或者性情暴躁者，慎读。\n### 准确的问题描述\n　　在程序员的日常工作中，更多的工作更像是通过程序解决问题的过程。所以更好的描述问题，或者说是自己能够对需求更准确的转化成为问题，会对后续的程序设计帮助十足。将复杂的问题简单化，模块化。同时，能否准确的描述问题，也决定这你是否将要解决一个“正确”的问题。\n　　一般情况下，对问题的描述可以概括为三个方面:\n> 准确的输入　　\n>\n> 准确的输出　　\n>\n> 准确的约束条件\n\n\n### 算法，灵机一动\n　　先进的算法有时候对软件系统影响很大——减少开发时间，同时使得执行效率更快。在算法中所谓的灵机一动，看似是“看起来很困难的问题也可以有一个简单的、意想不到的答案”。算法的灵机一动，并非只有大量的研究以后才能出现，需要的是编程之前、之中和之后进行认真的思考。伴随着这种思考，往往就能捕获到这灵机一动。\n\n### 数据决定数据结构\n　　恰当的数据视图实际上决定了程序的结构。通过重新组织内部数据是程序变得更好。在我们工作中，很多时候是可以用小程序完成任务的情况下，程序员往往最终写出了又大又纯的程序。其主要原因就是惰性：不去尝试思考，而急于完成最初的想法。\n　　程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心机去研究数据，常常会有奇效。数据的表示形式是程序设计的根本。退回起点的原则：\n1. 使用数组代替重复的代码\n2. 封装复杂结构\n3. 尽可能使用高级工具\n4. 从数据得出程序结构\n\n### 编写正确的程序\n　　必须引起注意的是，编程技巧仅仅是编写正确程序的很小一部分，大部分内容还是：问题定义、算法设计和数据结构的选择。遵循这几点的话，编写正常的程序通常是很容易的。除此之外，要记得使用测试用例和断言等去验证程序的正确性。\n\n### 让编写的程序真正可用\n　　程序员都是乐观主义者，他们总是认为讲编写完的程序，插入系统中就可以正常运行。在大部分时间是可行的，但是有的时候确实灾难性的存在，我们不得不需要在庞大的系统中，去寻找这个错误的小小的程序。\n　　良好的使用断言，可以知道程序的开发，同时也可以用来判断程序的正确性。这里作者提到了一个对于断言使用的一个小嘲讽：在测试时使用断言，而产品发布时将断言关闭的程序员，就好比在岸上操练时穿着救生衣，而下海时将救生衣脱下的水手。\n　　为了程序的可用性，往往自动测试和时间计数也显得至关重要。具有完整且完善边界测试用例能够保证程序的准确性，而且可以提高测试效率。同时，时间计数可以直观的观察程序的运行时间复杂度。\n\n### 来聊聊性能\n　　一个简单而又功能强大的程序，往往令用户欣喜而不令开发者烦恼，这是程序的终极目标。而其中一个重要的元素就是效率。低效率的程序往往令用户沮丧。等待的时间越长，也就意味着越高的概率会失去用户。而如何提高效率我们往往考虑以下途径：\n1. 通过积累经验，选择恰当的方法\n2. 粗略估算运行时间\n3. 算法设计\n4. 代码调优\n\n### 性能分析\n　　而在真正进行效率优化的时候，从计算机系统的层面我们应该从以下方面进行：\n1. 问题定义\n2. 系统结构:模块化；性能分析在系统设计阶段至关重要\n3. 算法和数据结构：快速的模块是基于其良好的表示的数据结构和操纵这些数据结构的算法\n4. 代码调优\n5. 系统软件\n6. 硬件\n\n### 粗略评估\n>　　任何事都应尽量简单，但不易于过于简单　——　爱因斯坦\n\n　　我们知道简单的计算并不简单，因为我们为了补偿估算参数时的错误和对问题的了解不足，我们往往会选定和包含安全系数。\n\n### 算法设计技术\n　　几个重要的算法设计技术\n1. 保存状态，避免重复计算\n2. 将信息预处理至数据结构中\n3. 分治算法\n4. 扫描算法\n5. 累加算法\n6. 下界\n\n### 代码调优\n　　代码调优很重要的一点是把握调优的尺度。有些程序猿过于关注程序的效率，由于太在乎细小的“优化”，它们编写出的程序过于精妙，难以维护。而一些程序员很少关注程序的效率，它们编写的程序有着清晰漂亮的结构，但效率极低以至于毫无用处。往往获取更多的可用内存空间，需要在程序的性能、功能或者可维护性上做出牺牲，所以优化的前提永远是正确的决策。\n　　代码调优是一个在程序中需要做整体考虑的工作项目，但其根本目的是解决程序中开销过大的部分，对其进行少量修改，以提高运行效率。所谓开销包括CPU时间和程序存储空间。\n　　作者在文中给出了代码调优的原理:\n> 代码调优的最重要远离就是尽量少用它　　\n> 1. 效率的角色： 没有坏的话就不要修\n> 2. 设计层面: 只有确定没有更好的解决方案时，才考虑进行代码调优\n> 3. 双刃剑\n\n### 节省空间\n　　努力的考虑一下空间紧凑的程序是很有意义的。在节省空间的同时，我们往往会得到运行时间上产生的副作用:程序小意味着加载更快，也更容易填入高速缓存中，操作的数据变少意味着操作时间变少等等。\n　　简单性可以衍生出功能性、健壮性以及速度和空间。\n　　这里列出一些较少程序所需数据的存储空间的技术:\n1. 不存储、重新计算\n2. 稀疏数据结构\n3. 数据压缩\n4. 分配策略\n5. 垃圾回收\n\n### 排序\n　　将一些列记录排成有序的，最后也是最容易的办法就是使用排序函数库。但是并非总是有效的，这时我们别无选择，只能编写自己的排序函数。\n\n### 堆\n　　采用堆排序不会超过O(nlogn)，并且只需要几个额外的字节。\n\n---\n# 写到最后\n　　读者用实践和经验去讲述程序中的问题，其实也是对我们工作和学习方法的一种提示。勿要死读书，读死书，要结合实际灵活运用。\n","slug":"编程珠玑","published":1,"updated":"2016-12-23T06:02:51.835Z","layout":"post","photos":[],"link":"","_id":"cix1e5cfn0015nvouu4iesqd8","content":"<h1 id=\"一、绪论\"><a href=\"#一、绪论\" class=\"headerlink\" title=\"一、绪论\"></a>一、绪论</h1><p>　　编程珠玑是一本很有影响力的书籍。它是作者对自己在长期的计算机程序设计实践中积累下来的宝贵经验的总结。行文生动形象，可读性高。在美国，它被作为低年级数据结构与算法的教材，同时，也作为高年级的算法辅助教材。它涵盖了算法课程和数据结构课程的大部分内容。不同于其他教材，他不强调单纯的从数学上分析，而是强调结合实际问题进行分析、应用和实现。话不多说，开卷有益。<br><a id=\"more\"></a></p>\n<h1 id=\"二、概述\"><a href=\"#二、概述\" class=\"headerlink\" title=\"二、概述\"></a>二、概述</h1><p>　　这是第二次翻开本书。虽然被很多人推荐，但阅读一遍后，我并没有抓到什么重点。这次边读边记录，希望能够做到讲本书融会贯通。主要是记录为主，可能每一段都没有核心，也可能上下文没有逻辑性，强迫症或者性情暴躁者，慎读。</p>\n<h3 id=\"准确的问题描述\"><a href=\"#准确的问题描述\" class=\"headerlink\" title=\"准确的问题描述\"></a>准确的问题描述</h3><p>　　在程序员的日常工作中，更多的工作更像是通过程序解决问题的过程。所以更好的描述问题，或者说是自己能够对需求更准确的转化成为问题，会对后续的程序设计帮助十足。将复杂的问题简单化，模块化。同时，能否准确的描述问题，也决定这你是否将要解决一个“正确”的问题。<br>　　一般情况下，对问题的描述可以概括为三个方面:</p>\n<blockquote>\n<p>准确的输入　　</p>\n<p>准确的输出　　</p>\n<p>准确的约束条件</p>\n</blockquote>\n<h3 id=\"算法，灵机一动\"><a href=\"#算法，灵机一动\" class=\"headerlink\" title=\"算法，灵机一动\"></a>算法，灵机一动</h3><p>　　先进的算法有时候对软件系统影响很大——减少开发时间，同时使得执行效率更快。在算法中所谓的灵机一动，看似是“看起来很困难的问题也可以有一个简单的、意想不到的答案”。算法的灵机一动，并非只有大量的研究以后才能出现，需要的是编程之前、之中和之后进行认真的思考。伴随着这种思考，往往就能捕获到这灵机一动。</p>\n<h3 id=\"数据决定数据结构\"><a href=\"#数据决定数据结构\" class=\"headerlink\" title=\"数据决定数据结构\"></a>数据决定数据结构</h3><p>　　恰当的数据视图实际上决定了程序的结构。通过重新组织内部数据是程序变得更好。在我们工作中，很多时候是可以用小程序完成任务的情况下，程序员往往最终写出了又大又纯的程序。其主要原因就是惰性：不去尝试思考，而急于完成最初的想法。<br>　　程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心机去研究数据，常常会有奇效。数据的表示形式是程序设计的根本。退回起点的原则：</p>\n<ol>\n<li>使用数组代替重复的代码</li>\n<li>封装复杂结构</li>\n<li>尽可能使用高级工具</li>\n<li>从数据得出程序结构</li>\n</ol>\n<h3 id=\"编写正确的程序\"><a href=\"#编写正确的程序\" class=\"headerlink\" title=\"编写正确的程序\"></a>编写正确的程序</h3><p>　　必须引起注意的是，编程技巧仅仅是编写正确程序的很小一部分，大部分内容还是：问题定义、算法设计和数据结构的选择。遵循这几点的话，编写正常的程序通常是很容易的。除此之外，要记得使用测试用例和断言等去验证程序的正确性。</p>\n<h3 id=\"让编写的程序真正可用\"><a href=\"#让编写的程序真正可用\" class=\"headerlink\" title=\"让编写的程序真正可用\"></a>让编写的程序真正可用</h3><p>　　程序员都是乐观主义者，他们总是认为讲编写完的程序，插入系统中就可以正常运行。在大部分时间是可行的，但是有的时候确实灾难性的存在，我们不得不需要在庞大的系统中，去寻找这个错误的小小的程序。<br>　　良好的使用断言，可以知道程序的开发，同时也可以用来判断程序的正确性。这里作者提到了一个对于断言使用的一个小嘲讽：在测试时使用断言，而产品发布时将断言关闭的程序员，就好比在岸上操练时穿着救生衣，而下海时将救生衣脱下的水手。<br>　　为了程序的可用性，往往自动测试和时间计数也显得至关重要。具有完整且完善边界测试用例能够保证程序的准确性，而且可以提高测试效率。同时，时间计数可以直观的观察程序的运行时间复杂度。</p>\n<h3 id=\"来聊聊性能\"><a href=\"#来聊聊性能\" class=\"headerlink\" title=\"来聊聊性能\"></a>来聊聊性能</h3><p>　　一个简单而又功能强大的程序，往往令用户欣喜而不令开发者烦恼，这是程序的终极目标。而其中一个重要的元素就是效率。低效率的程序往往令用户沮丧。等待的时间越长，也就意味着越高的概率会失去用户。而如何提高效率我们往往考虑以下途径：</p>\n<ol>\n<li>通过积累经验，选择恰当的方法</li>\n<li>粗略估算运行时间</li>\n<li>算法设计</li>\n<li>代码调优</li>\n</ol>\n<h3 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h3><p>　　而在真正进行效率优化的时候，从计算机系统的层面我们应该从以下方面进行：</p>\n<ol>\n<li>问题定义</li>\n<li>系统结构:模块化；性能分析在系统设计阶段至关重要</li>\n<li>算法和数据结构：快速的模块是基于其良好的表示的数据结构和操纵这些数据结构的算法</li>\n<li>代码调优</li>\n<li>系统软件</li>\n<li>硬件</li>\n</ol>\n<h3 id=\"粗略评估\"><a href=\"#粗略评估\" class=\"headerlink\" title=\"粗略评估\"></a>粗略评估</h3><blockquote>\n<p>　　任何事都应尽量简单，但不易于过于简单　——　爱因斯坦</p>\n</blockquote>\n<p>　　我们知道简单的计算并不简单，因为我们为了补偿估算参数时的错误和对问题的了解不足，我们往往会选定和包含安全系数。</p>\n<h3 id=\"算法设计技术\"><a href=\"#算法设计技术\" class=\"headerlink\" title=\"算法设计技术\"></a>算法设计技术</h3><p>　　几个重要的算法设计技术</p>\n<ol>\n<li>保存状态，避免重复计算</li>\n<li>将信息预处理至数据结构中</li>\n<li>分治算法</li>\n<li>扫描算法</li>\n<li>累加算法</li>\n<li>下界</li>\n</ol>\n<h3 id=\"代码调优\"><a href=\"#代码调优\" class=\"headerlink\" title=\"代码调优\"></a>代码调优</h3><p>　　代码调优很重要的一点是把握调优的尺度。有些程序猿过于关注程序的效率，由于太在乎细小的“优化”，它们编写出的程序过于精妙，难以维护。而一些程序员很少关注程序的效率，它们编写的程序有着清晰漂亮的结构，但效率极低以至于毫无用处。往往获取更多的可用内存空间，需要在程序的性能、功能或者可维护性上做出牺牲，所以优化的前提永远是正确的决策。<br>　　代码调优是一个在程序中需要做整体考虑的工作项目，但其根本目的是解决程序中开销过大的部分，对其进行少量修改，以提高运行效率。所谓开销包括CPU时间和程序存储空间。<br>　　作者在文中给出了代码调优的原理:</p>\n<blockquote>\n<p>代码调优的最重要远离就是尽量少用它　　</p>\n<ol>\n<li>效率的角色： 没有坏的话就不要修</li>\n<li>设计层面: 只有确定没有更好的解决方案时，才考虑进行代码调优</li>\n<li>双刃剑</li>\n</ol>\n</blockquote>\n<h3 id=\"节省空间\"><a href=\"#节省空间\" class=\"headerlink\" title=\"节省空间\"></a>节省空间</h3><p>　　努力的考虑一下空间紧凑的程序是很有意义的。在节省空间的同时，我们往往会得到运行时间上产生的副作用:程序小意味着加载更快，也更容易填入高速缓存中，操作的数据变少意味着操作时间变少等等。<br>　　简单性可以衍生出功能性、健壮性以及速度和空间。<br>　　这里列出一些较少程序所需数据的存储空间的技术:</p>\n<ol>\n<li>不存储、重新计算</li>\n<li>稀疏数据结构</li>\n<li>数据压缩</li>\n<li>分配策略</li>\n<li>垃圾回收</li>\n</ol>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>　　将一些列记录排成有序的，最后也是最容易的办法就是使用排序函数库。但是并非总是有效的，这时我们别无选择，只能编写自己的排序函数。</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>　　采用堆排序不会超过O(nlogn)，并且只需要几个额外的字节。</p>\n<hr>\n<h1 id=\"写到最后\"><a href=\"#写到最后\" class=\"headerlink\" title=\"写到最后\"></a>写到最后</h1><p>　　读者用实践和经验去讲述程序中的问题，其实也是对我们工作和学习方法的一种提示。勿要死读书，读死书，要结合实际灵活运用。</p>\n","excerpt":"<h1 id=\"一、绪论\"><a href=\"#一、绪论\" class=\"headerlink\" title=\"一、绪论\"></a>一、绪论</h1><p>　　编程珠玑是一本很有影响力的书籍。它是作者对自己在长期的计算机程序设计实践中积累下来的宝贵经验的总结。行文生动形象，可读性高。在美国，它被作为低年级数据结构与算法的教材，同时，也作为高年级的算法辅助教材。它涵盖了算法课程和数据结构课程的大部分内容。不同于其他教材，他不强调单纯的从数学上分析，而是强调结合实际问题进行分析、应用和实现。话不多说，开卷有益。<br>","more":"</p>\n<h1 id=\"二、概述\"><a href=\"#二、概述\" class=\"headerlink\" title=\"二、概述\"></a>二、概述</h1><p>　　这是第二次翻开本书。虽然被很多人推荐，但阅读一遍后，我并没有抓到什么重点。这次边读边记录，希望能够做到讲本书融会贯通。主要是记录为主，可能每一段都没有核心，也可能上下文没有逻辑性，强迫症或者性情暴躁者，慎读。</p>\n<h3 id=\"准确的问题描述\"><a href=\"#准确的问题描述\" class=\"headerlink\" title=\"准确的问题描述\"></a>准确的问题描述</h3><p>　　在程序员的日常工作中，更多的工作更像是通过程序解决问题的过程。所以更好的描述问题，或者说是自己能够对需求更准确的转化成为问题，会对后续的程序设计帮助十足。将复杂的问题简单化，模块化。同时，能否准确的描述问题，也决定这你是否将要解决一个“正确”的问题。<br>　　一般情况下，对问题的描述可以概括为三个方面:</p>\n<blockquote>\n<p>准确的输入　　</p>\n<p>准确的输出　　</p>\n<p>准确的约束条件</p>\n</blockquote>\n<h3 id=\"算法，灵机一动\"><a href=\"#算法，灵机一动\" class=\"headerlink\" title=\"算法，灵机一动\"></a>算法，灵机一动</h3><p>　　先进的算法有时候对软件系统影响很大——减少开发时间，同时使得执行效率更快。在算法中所谓的灵机一动，看似是“看起来很困难的问题也可以有一个简单的、意想不到的答案”。算法的灵机一动，并非只有大量的研究以后才能出现，需要的是编程之前、之中和之后进行认真的思考。伴随着这种思考，往往就能捕获到这灵机一动。</p>\n<h3 id=\"数据决定数据结构\"><a href=\"#数据决定数据结构\" class=\"headerlink\" title=\"数据决定数据结构\"></a>数据决定数据结构</h3><p>　　恰当的数据视图实际上决定了程序的结构。通过重新组织内部数据是程序变得更好。在我们工作中，很多时候是可以用小程序完成任务的情况下，程序员往往最终写出了又大又纯的程序。其主要原因就是惰性：不去尝试思考，而急于完成最初的想法。<br>　　程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中心机去研究数据，常常会有奇效。数据的表示形式是程序设计的根本。退回起点的原则：</p>\n<ol>\n<li>使用数组代替重复的代码</li>\n<li>封装复杂结构</li>\n<li>尽可能使用高级工具</li>\n<li>从数据得出程序结构</li>\n</ol>\n<h3 id=\"编写正确的程序\"><a href=\"#编写正确的程序\" class=\"headerlink\" title=\"编写正确的程序\"></a>编写正确的程序</h3><p>　　必须引起注意的是，编程技巧仅仅是编写正确程序的很小一部分，大部分内容还是：问题定义、算法设计和数据结构的选择。遵循这几点的话，编写正常的程序通常是很容易的。除此之外，要记得使用测试用例和断言等去验证程序的正确性。</p>\n<h3 id=\"让编写的程序真正可用\"><a href=\"#让编写的程序真正可用\" class=\"headerlink\" title=\"让编写的程序真正可用\"></a>让编写的程序真正可用</h3><p>　　程序员都是乐观主义者，他们总是认为讲编写完的程序，插入系统中就可以正常运行。在大部分时间是可行的，但是有的时候确实灾难性的存在，我们不得不需要在庞大的系统中，去寻找这个错误的小小的程序。<br>　　良好的使用断言，可以知道程序的开发，同时也可以用来判断程序的正确性。这里作者提到了一个对于断言使用的一个小嘲讽：在测试时使用断言，而产品发布时将断言关闭的程序员，就好比在岸上操练时穿着救生衣，而下海时将救生衣脱下的水手。<br>　　为了程序的可用性，往往自动测试和时间计数也显得至关重要。具有完整且完善边界测试用例能够保证程序的准确性，而且可以提高测试效率。同时，时间计数可以直观的观察程序的运行时间复杂度。</p>\n<h3 id=\"来聊聊性能\"><a href=\"#来聊聊性能\" class=\"headerlink\" title=\"来聊聊性能\"></a>来聊聊性能</h3><p>　　一个简单而又功能强大的程序，往往令用户欣喜而不令开发者烦恼，这是程序的终极目标。而其中一个重要的元素就是效率。低效率的程序往往令用户沮丧。等待的时间越长，也就意味着越高的概率会失去用户。而如何提高效率我们往往考虑以下途径：</p>\n<ol>\n<li>通过积累经验，选择恰当的方法</li>\n<li>粗略估算运行时间</li>\n<li>算法设计</li>\n<li>代码调优</li>\n</ol>\n<h3 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h3><p>　　而在真正进行效率优化的时候，从计算机系统的层面我们应该从以下方面进行：</p>\n<ol>\n<li>问题定义</li>\n<li>系统结构:模块化；性能分析在系统设计阶段至关重要</li>\n<li>算法和数据结构：快速的模块是基于其良好的表示的数据结构和操纵这些数据结构的算法</li>\n<li>代码调优</li>\n<li>系统软件</li>\n<li>硬件</li>\n</ol>\n<h3 id=\"粗略评估\"><a href=\"#粗略评估\" class=\"headerlink\" title=\"粗略评估\"></a>粗略评估</h3><blockquote>\n<p>　　任何事都应尽量简单，但不易于过于简单　——　爱因斯坦</p>\n</blockquote>\n<p>　　我们知道简单的计算并不简单，因为我们为了补偿估算参数时的错误和对问题的了解不足，我们往往会选定和包含安全系数。</p>\n<h3 id=\"算法设计技术\"><a href=\"#算法设计技术\" class=\"headerlink\" title=\"算法设计技术\"></a>算法设计技术</h3><p>　　几个重要的算法设计技术</p>\n<ol>\n<li>保存状态，避免重复计算</li>\n<li>将信息预处理至数据结构中</li>\n<li>分治算法</li>\n<li>扫描算法</li>\n<li>累加算法</li>\n<li>下界</li>\n</ol>\n<h3 id=\"代码调优\"><a href=\"#代码调优\" class=\"headerlink\" title=\"代码调优\"></a>代码调优</h3><p>　　代码调优很重要的一点是把握调优的尺度。有些程序猿过于关注程序的效率，由于太在乎细小的“优化”，它们编写出的程序过于精妙，难以维护。而一些程序员很少关注程序的效率，它们编写的程序有着清晰漂亮的结构，但效率极低以至于毫无用处。往往获取更多的可用内存空间，需要在程序的性能、功能或者可维护性上做出牺牲，所以优化的前提永远是正确的决策。<br>　　代码调优是一个在程序中需要做整体考虑的工作项目，但其根本目的是解决程序中开销过大的部分，对其进行少量修改，以提高运行效率。所谓开销包括CPU时间和程序存储空间。<br>　　作者在文中给出了代码调优的原理:</p>\n<blockquote>\n<p>代码调优的最重要远离就是尽量少用它　　</p>\n<ol>\n<li>效率的角色： 没有坏的话就不要修</li>\n<li>设计层面: 只有确定没有更好的解决方案时，才考虑进行代码调优</li>\n<li>双刃剑</li>\n</ol>\n</blockquote>\n<h3 id=\"节省空间\"><a href=\"#节省空间\" class=\"headerlink\" title=\"节省空间\"></a>节省空间</h3><p>　　努力的考虑一下空间紧凑的程序是很有意义的。在节省空间的同时，我们往往会得到运行时间上产生的副作用:程序小意味着加载更快，也更容易填入高速缓存中，操作的数据变少意味着操作时间变少等等。<br>　　简单性可以衍生出功能性、健壮性以及速度和空间。<br>　　这里列出一些较少程序所需数据的存储空间的技术:</p>\n<ol>\n<li>不存储、重新计算</li>\n<li>稀疏数据结构</li>\n<li>数据压缩</li>\n<li>分配策略</li>\n<li>垃圾回收</li>\n</ol>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>　　将一些列记录排成有序的，最后也是最容易的办法就是使用排序函数库。但是并非总是有效的，这时我们别无选择，只能编写自己的排序函数。</p>\n<h3 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h3><p>　　采用堆排序不会超过O(nlogn)，并且只需要几个额外的字节。</p>\n<hr>\n<h1 id=\"写到最后\"><a href=\"#写到最后\" class=\"headerlink\" title=\"写到最后\"></a>写到最后</h1><p>　　读者用实践和经验去讲述程序中的问题，其实也是对我们工作和学习方法的一种提示。勿要死读书，读死书，要结合实际灵活运用。</p>"},{"title":"网站浏览记录","comments":0,"date":"2016-12-05T07:04:18.000Z","_content":"\n　　我习惯每天花上一些时间，根据今天的疑问去搜索一些博客读一读。经常会看到一些让人为之振奋的讲解，但也因为读的多读的泛，让自己很难记起某些知识点的具体位置。这让自己想再次翻阅的时候很是焦灼。现在想想何不记录一番，方便以后查阅呢？\n\n<!--more-->\n\n### 大型网站架构\n1. [大型网站改进历程](http://www.cnblogs.com/elves/p/4259188.html)\n2. [大型网站架构案例](http://www.cnblogs.com/itfly8/p/5006197.html)\n\n### 数据库缓存\n1. [mysql+memcached](http://www.360sdn.com/architect/2015/0504/8691.html)\n2. [mysql+redis](http://www.voidcn.com/blog/bantiaomichong/article/p-6158870.html)\n3. [redis应用](http://storage.ctocio.com.cn/394/12737894.shtml)\n\n### 编程珠玑\n1. [把编程珠玑读薄](http://www.hawstein.com/posts/make-thiner-programming-pearls.html)\n2. [编程珠玑](http://mingyangshang.github.io/2016/01/01/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/)\n\n### elasticsearch\n1. [官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\n2. [mastering elasticsearch(中文版)](http://udn.yyuap.com/doc/mastering-elasticsearch/index.html)\n","source":"_posts/网站浏览记录.md","raw":"---\ntitle: 网站浏览记录\ncomments: false\ndate: 2016-12-05 15:04:18\ntags:\n  - 网址推荐\n  - 学习笔记\ncategories:\n  - 读书笔记\n  - 网站地址\n---\n\n　　我习惯每天花上一些时间，根据今天的疑问去搜索一些博客读一读。经常会看到一些让人为之振奋的讲解，但也因为读的多读的泛，让自己很难记起某些知识点的具体位置。这让自己想再次翻阅的时候很是焦灼。现在想想何不记录一番，方便以后查阅呢？\n\n<!--more-->\n\n### 大型网站架构\n1. [大型网站改进历程](http://www.cnblogs.com/elves/p/4259188.html)\n2. [大型网站架构案例](http://www.cnblogs.com/itfly8/p/5006197.html)\n\n### 数据库缓存\n1. [mysql+memcached](http://www.360sdn.com/architect/2015/0504/8691.html)\n2. [mysql+redis](http://www.voidcn.com/blog/bantiaomichong/article/p-6158870.html)\n3. [redis应用](http://storage.ctocio.com.cn/394/12737894.shtml)\n\n### 编程珠玑\n1. [把编程珠玑读薄](http://www.hawstein.com/posts/make-thiner-programming-pearls.html)\n2. [编程珠玑](http://mingyangshang.github.io/2016/01/01/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/)\n\n### elasticsearch\n1. [官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html)\n2. [mastering elasticsearch(中文版)](http://udn.yyuap.com/doc/mastering-elasticsearch/index.html)\n","slug":"网站浏览记录","published":1,"updated":"2016-12-20T08:23:41.065Z","layout":"post","photos":[],"link":"","_id":"cix1e5cfx0017nvoutb8fdmq7","content":"<p>　　我习惯每天花上一些时间，根据今天的疑问去搜索一些博客读一读。经常会看到一些让人为之振奋的讲解，但也因为读的多读的泛，让自己很难记起某些知识点的具体位置。这让自己想再次翻阅的时候很是焦灼。现在想想何不记录一番，方便以后查阅呢？</p>\n<a id=\"more\"></a>\n<h3 id=\"大型网站架构\"><a href=\"#大型网站架构\" class=\"headerlink\" title=\"大型网站架构\"></a>大型网站架构</h3><ol>\n<li><a href=\"http://www.cnblogs.com/elves/p/4259188.html\" target=\"_blank\" rel=\"external\">大型网站改进历程</a></li>\n<li><a href=\"http://www.cnblogs.com/itfly8/p/5006197.html\" target=\"_blank\" rel=\"external\">大型网站架构案例</a></li>\n</ol>\n<h3 id=\"数据库缓存\"><a href=\"#数据库缓存\" class=\"headerlink\" title=\"数据库缓存\"></a>数据库缓存</h3><ol>\n<li><a href=\"http://www.360sdn.com/architect/2015/0504/8691.html\" target=\"_blank\" rel=\"external\">mysql+memcached</a></li>\n<li><a href=\"http://www.voidcn.com/blog/bantiaomichong/article/p-6158870.html\" target=\"_blank\" rel=\"external\">mysql+redis</a></li>\n<li><a href=\"http://storage.ctocio.com.cn/394/12737894.shtml\" target=\"_blank\" rel=\"external\">redis应用</a></li>\n</ol>\n<h3 id=\"编程珠玑\"><a href=\"#编程珠玑\" class=\"headerlink\" title=\"编程珠玑\"></a>编程珠玑</h3><ol>\n<li><a href=\"http://www.hawstein.com/posts/make-thiner-programming-pearls.html\" target=\"_blank\" rel=\"external\">把编程珠玑读薄</a></li>\n<li><a href=\"http://mingyangshang.github.io/2016/01/01/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/\" target=\"_blank\" rel=\"external\">编程珠玑</a></li>\n</ol>\n<h3 id=\"elasticsearch\"><a href=\"#elasticsearch\" class=\"headerlink\" title=\"elasticsearch\"></a>elasticsearch</h3><ol>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html\" target=\"_blank\" rel=\"external\">官方文档</a></li>\n<li><a href=\"http://udn.yyuap.com/doc/mastering-elasticsearch/index.html\" target=\"_blank\" rel=\"external\">mastering elasticsearch(中文版)</a></li>\n</ol>\n","excerpt":"<p>　　我习惯每天花上一些时间，根据今天的疑问去搜索一些博客读一读。经常会看到一些让人为之振奋的讲解，但也因为读的多读的泛，让自己很难记起某些知识点的具体位置。这让自己想再次翻阅的时候很是焦灼。现在想想何不记录一番，方便以后查阅呢？</p>","more":"<h3 id=\"大型网站架构\"><a href=\"#大型网站架构\" class=\"headerlink\" title=\"大型网站架构\"></a>大型网站架构</h3><ol>\n<li><a href=\"http://www.cnblogs.com/elves/p/4259188.html\">大型网站改进历程</a></li>\n<li><a href=\"http://www.cnblogs.com/itfly8/p/5006197.html\">大型网站架构案例</a></li>\n</ol>\n<h3 id=\"数据库缓存\"><a href=\"#数据库缓存\" class=\"headerlink\" title=\"数据库缓存\"></a>数据库缓存</h3><ol>\n<li><a href=\"http://www.360sdn.com/architect/2015/0504/8691.html\">mysql+memcached</a></li>\n<li><a href=\"http://www.voidcn.com/blog/bantiaomichong/article/p-6158870.html\">mysql+redis</a></li>\n<li><a href=\"http://storage.ctocio.com.cn/394/12737894.shtml\">redis应用</a></li>\n</ol>\n<h3 id=\"编程珠玑\"><a href=\"#编程珠玑\" class=\"headerlink\" title=\"编程珠玑\"></a>编程珠玑</h3><ol>\n<li><a href=\"http://www.hawstein.com/posts/make-thiner-programming-pearls.html\">把编程珠玑读薄</a></li>\n<li><a href=\"http://mingyangshang.github.io/2016/01/01/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/\">编程珠玑</a></li>\n</ol>\n<h3 id=\"elasticsearch\"><a href=\"#elasticsearch\" class=\"headerlink\" title=\"elasticsearch\"></a>elasticsearch</h3><ol>\n<li><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html\">官方文档</a></li>\n<li><a href=\"http://udn.yyuap.com/doc/mastering-elasticsearch/index.html\">mastering elasticsearch(中文版)</a></li>\n</ol>"},{"title":"算法导论-动态规划","comments":0,"date":"2016-12-13T02:24:22.000Z","_content":"\n# 概述\n　　前面我们已经介绍了分治思想。分治思想是将问题划分为**互不相交的子问题**，递归的求解子问题，再将它们的解组合起来，求出原问题的解。这一篇文章我们将一起来讨论一下动态规划。它是算法中另一个重要的思想。　\n　　动态规划的思想与分治思想相反，动态规划是用于**子问题重叠**的情况，即不同的子问题具有相同的子子问题。在这种情况下，动态规划相对于分治算法的优势在于，分治算法会重复的计算本是相同的子子问题，导致运算时间的浪费，而动态规划则只会计算一次。\n　　动态规划常常用于解决最优解的问题。这类问题常常有很多可行的解，我们希望的是从这些解中找到最优解。\n<!--more-->\n\n# 简介\n　　类似于分治算法的三个步骤，动态规划的思考和设计层面也具有四个步骤。\n1. 刻画一个最优解结构\n2. 递归定义最优解的值\n3. 计算最优解的值，通常使用自底向上的方法\n4. 利用计算出来的信息构造最优解\n\n# 实践\n　　这里我们通过一个简单的例子对动态规划的思想进行一下实践。\n### 问题\n长度i |1|2|3|4|5|6|7|8|9|10\n--- | ---\n**价格Pi** |1|5|8|9|10|17|17|20|24|30\n\n　　上述表格描述的是一个钢条公司的钢条长度和价格的关系。它们希望得到给定长度为n的钢条，如何切割才能达到利益最大化。\n\n### 分析\n　　我们用n表示钢条的长度，i表示切割的长度，Pi表示切割长度对应的收益，Rn代表长度为n的钢条对应的最大收益。\n　　则我们可以得出Rn=max(Pi + Rn-1)。这个推倒式的表明的是对于n长的钢条。进行i(i从1到n)的长度的切割，获得的切割收益与剩余收益的和。再从i=1到i=n中选取最大的值，就是该n长钢条能获取的最大收益。\n\n### 解决\n　　动态规划有两种等价的实现方法，分别为带备忘的自顶向下法和自底向上法。带备忘的自顶向下法，是按照自然的递归形式编写过程，但是过程中会保存没格子问题的解。自底向上法则需要恰当的定义子问题的规模，使得任何子问题都只依赖更小的子问题求解。\n下面列出两种实现的伪代码。\n\n自顶向下:\n```\nMEMOIZED-CUT-ROD(p,n)\n        let r[0..n] be a new array\n        for i = 0 to n\n                r[i]=-∞\n        return MEMOIZED-CUT-ROD-AUX(p,n,r)\n\nMEMOIZED-CUT-ROD-AUX(p,n,r)\n        if r[n]≥0\n                return r[n]\n        if n== 0\n                q = 0\n        else q = -∞\n                for i = 1 to n\n                        q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i, r))\n        r[n]=q\n        return q\n```\n\n自底向上:\n```\nBOTTOM-UP-CUT-ROD(p,n)\n        let r[0..n] be a new array\n        r[0]=0\n        for j = 1 to n\n              q = -∞\n              for i = 1 to j\n                      q=max(q,p[i]+r[j-i])\n              r[j]=q\n        return r[n]\n```\n","source":"_posts/算法导论-动态规划.md","raw":"---\ntitle: 算法导论-动态规划\ncomments: false\ndate: 2016-12-13 10:24:22\ntags:\n  - 读书笔记\n  - 算法导论\n  - 动态规划\ncategories:\n  - 读书笔记\n  - 算法导论\n---\n\n# 概述\n　　前面我们已经介绍了分治思想。分治思想是将问题划分为**互不相交的子问题**，递归的求解子问题，再将它们的解组合起来，求出原问题的解。这一篇文章我们将一起来讨论一下动态规划。它是算法中另一个重要的思想。　\n　　动态规划的思想与分治思想相反，动态规划是用于**子问题重叠**的情况，即不同的子问题具有相同的子子问题。在这种情况下，动态规划相对于分治算法的优势在于，分治算法会重复的计算本是相同的子子问题，导致运算时间的浪费，而动态规划则只会计算一次。\n　　动态规划常常用于解决最优解的问题。这类问题常常有很多可行的解，我们希望的是从这些解中找到最优解。\n<!--more-->\n\n# 简介\n　　类似于分治算法的三个步骤，动态规划的思考和设计层面也具有四个步骤。\n1. 刻画一个最优解结构\n2. 递归定义最优解的值\n3. 计算最优解的值，通常使用自底向上的方法\n4. 利用计算出来的信息构造最优解\n\n# 实践\n　　这里我们通过一个简单的例子对动态规划的思想进行一下实践。\n### 问题\n长度i |1|2|3|4|5|6|7|8|9|10\n--- | ---\n**价格Pi** |1|5|8|9|10|17|17|20|24|30\n\n　　上述表格描述的是一个钢条公司的钢条长度和价格的关系。它们希望得到给定长度为n的钢条，如何切割才能达到利益最大化。\n\n### 分析\n　　我们用n表示钢条的长度，i表示切割的长度，Pi表示切割长度对应的收益，Rn代表长度为n的钢条对应的最大收益。\n　　则我们可以得出Rn=max(Pi + Rn-1)。这个推倒式的表明的是对于n长的钢条。进行i(i从1到n)的长度的切割，获得的切割收益与剩余收益的和。再从i=1到i=n中选取最大的值，就是该n长钢条能获取的最大收益。\n\n### 解决\n　　动态规划有两种等价的实现方法，分别为带备忘的自顶向下法和自底向上法。带备忘的自顶向下法，是按照自然的递归形式编写过程，但是过程中会保存没格子问题的解。自底向上法则需要恰当的定义子问题的规模，使得任何子问题都只依赖更小的子问题求解。\n下面列出两种实现的伪代码。\n\n自顶向下:\n```\nMEMOIZED-CUT-ROD(p,n)\n        let r[0..n] be a new array\n        for i = 0 to n\n                r[i]=-∞\n        return MEMOIZED-CUT-ROD-AUX(p,n,r)\n\nMEMOIZED-CUT-ROD-AUX(p,n,r)\n        if r[n]≥0\n                return r[n]\n        if n== 0\n                q = 0\n        else q = -∞\n                for i = 1 to n\n                        q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i, r))\n        r[n]=q\n        return q\n```\n\n自底向上:\n```\nBOTTOM-UP-CUT-ROD(p,n)\n        let r[0..n] be a new array\n        r[0]=0\n        for j = 1 to n\n              q = -∞\n              for i = 1 to j\n                      q=max(q,p[i]+r[j-i])\n              r[j]=q\n        return r[n]\n```\n","slug":"算法导论-动态规划","published":1,"updated":"2016-12-13T03:41:17.991Z","layout":"post","photos":[],"link":"","_id":"cix1e5cg1001bnvou8pcgaby2","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>　　前面我们已经介绍了分治思想。分治思想是将问题划分为<strong>互不相交的子问题</strong>，递归的求解子问题，再将它们的解组合起来，求出原问题的解。这一篇文章我们将一起来讨论一下动态规划。它是算法中另一个重要的思想。　<br>　　动态规划的思想与分治思想相反，动态规划是用于<strong>子问题重叠</strong>的情况，即不同的子问题具有相同的子子问题。在这种情况下，动态规划相对于分治算法的优势在于，分治算法会重复的计算本是相同的子子问题，导致运算时间的浪费，而动态规划则只会计算一次。<br>　　动态规划常常用于解决最优解的问题。这类问题常常有很多可行的解，我们希望的是从这些解中找到最优解。<br><a id=\"more\"></a></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>　　类似于分治算法的三个步骤，动态规划的思考和设计层面也具有四个步骤。</p>\n<ol>\n<li>刻画一个最优解结构</li>\n<li>递归定义最优解的值</li>\n<li>计算最优解的值，通常使用自底向上的方法</li>\n<li>利用计算出来的信息构造最优解</li>\n</ol>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>　　这里我们通过一个简单的例子对动态规划的思想进行一下实践。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><table>\n<thead>\n<tr>\n<th>长度i</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>价格Pi</strong></td>\n<td>1</td>\n<td>5</td>\n<td>8</td>\n<td>9</td>\n<td>10</td>\n<td>17</td>\n<td>17</td>\n<td>20</td>\n<td>24</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n<p>　　上述表格描述的是一个钢条公司的钢条长度和价格的关系。它们希望得到给定长度为n的钢条，如何切割才能达到利益最大化。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>　　我们用n表示钢条的长度，i表示切割的长度，Pi表示切割长度对应的收益，Rn代表长度为n的钢条对应的最大收益。<br>　　则我们可以得出Rn=max(Pi + Rn-1)。这个推倒式的表明的是对于n长的钢条。进行i(i从1到n)的长度的切割，获得的切割收益与剩余收益的和。再从i=1到i=n中选取最大的值，就是该n长钢条能获取的最大收益。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>　　动态规划有两种等价的实现方法，分别为带备忘的自顶向下法和自底向上法。带备忘的自顶向下法，是按照自然的递归形式编写过程，但是过程中会保存没格子问题的解。自底向上法则需要恰当的定义子问题的规模，使得任何子问题都只依赖更小的子问题求解。<br>下面列出两种实现的伪代码。</p>\n<p>自顶向下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">MEMOIZED-CUT-ROD(p,n)</div><div class=\"line\">        let r[0..n] be a new array</div><div class=\"line\">        for i = 0 to n</div><div class=\"line\">                r[i]=-∞</div><div class=\"line\">        return MEMOIZED-CUT-ROD-AUX(p,n,r)</div><div class=\"line\"></div><div class=\"line\">MEMOIZED-CUT-ROD-AUX(p,n,r)</div><div class=\"line\">        if r[n]≥0</div><div class=\"line\">                return r[n]</div><div class=\"line\">        if n== 0</div><div class=\"line\">                q = 0</div><div class=\"line\">        else q = -∞</div><div class=\"line\">                for i = 1 to n</div><div class=\"line\">                        q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i, r))</div><div class=\"line\">        r[n]=q</div><div class=\"line\">        return q</div></pre></td></tr></table></figure></p>\n<p>自底向上:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">BOTTOM-UP-CUT-ROD(p,n)</div><div class=\"line\">        let r[0..n] be a new array</div><div class=\"line\">        r[0]=0</div><div class=\"line\">        for j = 1 to n</div><div class=\"line\">              q = -∞</div><div class=\"line\">              for i = 1 to j</div><div class=\"line\">                      q=max(q,p[i]+r[j-i])</div><div class=\"line\">              r[j]=q</div><div class=\"line\">        return r[n]</div></pre></td></tr></table></figure></p>\n","excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>　　前面我们已经介绍了分治思想。分治思想是将问题划分为<strong>互不相交的子问题</strong>，递归的求解子问题，再将它们的解组合起来，求出原问题的解。这一篇文章我们将一起来讨论一下动态规划。它是算法中另一个重要的思想。　<br>　　动态规划的思想与分治思想相反，动态规划是用于<strong>子问题重叠</strong>的情况，即不同的子问题具有相同的子子问题。在这种情况下，动态规划相对于分治算法的优势在于，分治算法会重复的计算本是相同的子子问题，导致运算时间的浪费，而动态规划则只会计算一次。<br>　　动态规划常常用于解决最优解的问题。这类问题常常有很多可行的解，我们希望的是从这些解中找到最优解。<br>","more":"</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>　　类似于分治算法的三个步骤，动态规划的思考和设计层面也具有四个步骤。</p>\n<ol>\n<li>刻画一个最优解结构</li>\n<li>递归定义最优解的值</li>\n<li>计算最优解的值，通常使用自底向上的方法</li>\n<li>利用计算出来的信息构造最优解</li>\n</ol>\n<h1 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h1><p>　　这里我们通过一个简单的例子对动态规划的思想进行一下实践。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><table>\n<thead>\n<tr>\n<th>长度i</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>价格Pi</strong></td>\n<td>1</td>\n<td>5</td>\n<td>8</td>\n<td>9</td>\n<td>10</td>\n<td>17</td>\n<td>17</td>\n<td>20</td>\n<td>24</td>\n<td>30</td>\n</tr>\n</tbody>\n</table>\n<p>　　上述表格描述的是一个钢条公司的钢条长度和价格的关系。它们希望得到给定长度为n的钢条，如何切割才能达到利益最大化。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>　　我们用n表示钢条的长度，i表示切割的长度，Pi表示切割长度对应的收益，Rn代表长度为n的钢条对应的最大收益。<br>　　则我们可以得出Rn=max(Pi + Rn-1)。这个推倒式的表明的是对于n长的钢条。进行i(i从1到n)的长度的切割，获得的切割收益与剩余收益的和。再从i=1到i=n中选取最大的值，就是该n长钢条能获取的最大收益。</p>\n<h3 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h3><p>　　动态规划有两种等价的实现方法，分别为带备忘的自顶向下法和自底向上法。带备忘的自顶向下法，是按照自然的递归形式编写过程，但是过程中会保存没格子问题的解。自底向上法则需要恰当的定义子问题的规模，使得任何子问题都只依赖更小的子问题求解。<br>下面列出两种实现的伪代码。</p>\n<p>自顶向下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">MEMOIZED-CUT-ROD(p,n)</div><div class=\"line\">        let r[0..n] be a new array</div><div class=\"line\">        for i = 0 to n</div><div class=\"line\">                r[i]=-∞</div><div class=\"line\">        return MEMOIZED-CUT-ROD-AUX(p,n,r)</div><div class=\"line\"></div><div class=\"line\">MEMOIZED-CUT-ROD-AUX(p,n,r)</div><div class=\"line\">        if r[n]≥0</div><div class=\"line\">                return r[n]</div><div class=\"line\">        if n== 0</div><div class=\"line\">                q = 0</div><div class=\"line\">        else q = -∞</div><div class=\"line\">                for i = 1 to n</div><div class=\"line\">                        q = max(q, p[i] + MEMOIZED-CUT-ROD-AUX(p, n-i, r))</div><div class=\"line\">        r[n]=q</div><div class=\"line\">        return q</div></pre></td></tr></table></figure></p>\n<p>自底向上:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">BOTTOM-UP-CUT-ROD(p,n)</div><div class=\"line\">        let r[0..n] be a new array</div><div class=\"line\">        r[0]=0</div><div class=\"line\">        for j = 1 to n</div><div class=\"line\">              q = -∞</div><div class=\"line\">              for i = 1 to j</div><div class=\"line\">                      q=max(q,p[i]+r[j-i])</div><div class=\"line\">              r[j]=q</div><div class=\"line\">        return r[n]</div></pre></td></tr></table></figure></p>"},{"title":"算法导论(1)——写好伪代码","comments":0,"date":"2016-12-02T08:51:00.000Z","_content":"\n　　在学习各种编程语言的时候，数据结构与算法一般都会作为重点课程来指出。而谈到算法，算法导论一书又常常被大家提起。然而作为一个编程界的老鸟，技术层面的菜鸟，最近才开始啃算法导论，实属令自己汗颜。不过拾起总比放下的要好，所以这里根据自己的理解做一些记录。并在阅读初期就设定了一些目标，包括理解并学习各种常用算法及其设计思路，***学习并写好伪代码***等。\n\n<!--more-->\n\n### 什么是算法\n\n　　书中讲到，算法就是任何良定义的计算过程。算法的目的是解决问题。问题陈述说明了期望的输入和输出，而算法则描述一个特定的计算过程来实现输入输出的关系。\n### 算法的描述（伪代码）\n　　算法可以使用英语说明，也可以用中文说明，当然也可以说明成计算机程序。它的唯一要求是这个说明必须精确的描述所需要遵循的计算过程。\n　　我个人更欣赏将算法描述为用一种伪代码书写的程序。它的优势在于，能够使用最清晰最简洁的方法来说明给定的算法。并且根据伪代码可以将算法转化成各种所需的编程语言。\n\n### 如何写好伪代码\n\n　　在我们常用的编程语言中，通常按照所需的命名规范和运算逻辑的使用，讲所想的用该语言展示出来。伪代码同样也可以按照相似的方法展示。其实伪代码并没有明确的规范要求，但是在算法导论一书中，他列出了一些所谓的约定。当然，这些约定我们可以不去遵守。但是如果按着约定去书写伪代码的话，会使我们的伪代码变得清晰易懂，何乐不为。\n\n- 缩进表示块结构。参考python的语言结构。　\n- while,for,if-else等结构具有和c语言等相同的解释。但是方便理解，我们去除额外的细节，表示重点。比如当一个for循环时，当循环上升时使用to，下降时使用downto，步数使用by。\n- //表示注释\n- 变量直接使用无需声明。一般变量默认为局部变量。\n- 数据访问通过数组名和下标的方式访问。\n- 使用error表示过程中出现错误。\n\n　　伪代码的使用方法和约定都比较宽松，目的都是能够写出清晰易懂的伪代码。\n\n### 伪代码实践\n   这里列举一个插入排序的算法的伪代码实现，大家一起来感受一下气场。\n```\nINSERT-SORT(A)\n    for j=2 to A.length\n        key=A[j]\n        // Insert A[j] into the sorted sequence A[1..j-1].\n        i = j-1;\n      while i>0 and A[i]>key\n          A[i+1]=A[j]\n          i = i-1\n      A[i+1]=key\n```\n\n### 归并排序(merge sort)\n```\nMERGE(A,p,q,r)\n        n1=q-p+1\n        n2=r-q\n        let L[0..n1] and R[0..n2] be a new array\n        for i = 0 to n1-1\n                L[i]=A[p+i]\n        for j = 0 to n2-1\n                R[j]=A[q+1+j]\n        L[n1]=∞\n        L[n2]=∞\n        i=0\n        j=0\n        for k = p to r\n                if L[i] < R[j]\n                        A[k]=L[i]\n                        i = i + 1\n                else\n                        A[k]=R[j]\n                        j = j +1\n\nMERGE-SORT(A,p,r)\n        if(p<r)\n                q=[(p+r)/2]\n                MERGE-SORT(A,p,q)\n                MERGE-SORT(A,q+1,r)\n                MERGE(A,p,q,r)\n```\n","source":"_posts/算法导论1.md","raw":"---\ntitle: 算法导论(1)——写好伪代码\ncomments: false\ndate: 2016-12-02 16:51:00\ntags:\n  - 读书笔记\n  - 算法导论\ncategories:\n  - 读书笔记\n  - 算法导论\n---\n\n　　在学习各种编程语言的时候，数据结构与算法一般都会作为重点课程来指出。而谈到算法，算法导论一书又常常被大家提起。然而作为一个编程界的老鸟，技术层面的菜鸟，最近才开始啃算法导论，实属令自己汗颜。不过拾起总比放下的要好，所以这里根据自己的理解做一些记录。并在阅读初期就设定了一些目标，包括理解并学习各种常用算法及其设计思路，***学习并写好伪代码***等。\n\n<!--more-->\n\n### 什么是算法\n\n　　书中讲到，算法就是任何良定义的计算过程。算法的目的是解决问题。问题陈述说明了期望的输入和输出，而算法则描述一个特定的计算过程来实现输入输出的关系。\n### 算法的描述（伪代码）\n　　算法可以使用英语说明，也可以用中文说明，当然也可以说明成计算机程序。它的唯一要求是这个说明必须精确的描述所需要遵循的计算过程。\n　　我个人更欣赏将算法描述为用一种伪代码书写的程序。它的优势在于，能够使用最清晰最简洁的方法来说明给定的算法。并且根据伪代码可以将算法转化成各种所需的编程语言。\n\n### 如何写好伪代码\n\n　　在我们常用的编程语言中，通常按照所需的命名规范和运算逻辑的使用，讲所想的用该语言展示出来。伪代码同样也可以按照相似的方法展示。其实伪代码并没有明确的规范要求，但是在算法导论一书中，他列出了一些所谓的约定。当然，这些约定我们可以不去遵守。但是如果按着约定去书写伪代码的话，会使我们的伪代码变得清晰易懂，何乐不为。\n\n- 缩进表示块结构。参考python的语言结构。　\n- while,for,if-else等结构具有和c语言等相同的解释。但是方便理解，我们去除额外的细节，表示重点。比如当一个for循环时，当循环上升时使用to，下降时使用downto，步数使用by。\n- //表示注释\n- 变量直接使用无需声明。一般变量默认为局部变量。\n- 数据访问通过数组名和下标的方式访问。\n- 使用error表示过程中出现错误。\n\n　　伪代码的使用方法和约定都比较宽松，目的都是能够写出清晰易懂的伪代码。\n\n### 伪代码实践\n   这里列举一个插入排序的算法的伪代码实现，大家一起来感受一下气场。\n```\nINSERT-SORT(A)\n    for j=2 to A.length\n        key=A[j]\n        // Insert A[j] into the sorted sequence A[1..j-1].\n        i = j-1;\n      while i>0 and A[i]>key\n          A[i+1]=A[j]\n          i = i-1\n      A[i+1]=key\n```\n\n### 归并排序(merge sort)\n```\nMERGE(A,p,q,r)\n        n1=q-p+1\n        n2=r-q\n        let L[0..n1] and R[0..n2] be a new array\n        for i = 0 to n1-1\n                L[i]=A[p+i]\n        for j = 0 to n2-1\n                R[j]=A[q+1+j]\n        L[n1]=∞\n        L[n2]=∞\n        i=0\n        j=0\n        for k = p to r\n                if L[i] < R[j]\n                        A[k]=L[i]\n                        i = i + 1\n                else\n                        A[k]=R[j]\n                        j = j +1\n\nMERGE-SORT(A,p,r)\n        if(p<r)\n                q=[(p+r)/2]\n                MERGE-SORT(A,p,q)\n                MERGE-SORT(A,q+1,r)\n                MERGE(A,p,q,r)\n```\n","slug":"算法导论1","published":1,"updated":"2016-12-19T02:01:53.945Z","layout":"post","photos":[],"link":"","_id":"cix1e5cg5001envou6drghovd","content":"<p>　　在学习各种编程语言的时候，数据结构与算法一般都会作为重点课程来指出。而谈到算法，算法导论一书又常常被大家提起。然而作为一个编程界的老鸟，技术层面的菜鸟，最近才开始啃算法导论，实属令自己汗颜。不过拾起总比放下的要好，所以这里根据自己的理解做一些记录。并在阅读初期就设定了一些目标，包括理解并学习各种常用算法及其设计思路，<strong><em>学习并写好伪代码</em></strong>等。</p>\n<a id=\"more\"></a>\n<h3 id=\"什么是算法\"><a href=\"#什么是算法\" class=\"headerlink\" title=\"什么是算法\"></a>什么是算法</h3><p>　　书中讲到，算法就是任何良定义的计算过程。算法的目的是解决问题。问题陈述说明了期望的输入和输出，而算法则描述一个特定的计算过程来实现输入输出的关系。</p>\n<h3 id=\"算法的描述（伪代码）\"><a href=\"#算法的描述（伪代码）\" class=\"headerlink\" title=\"算法的描述（伪代码）\"></a>算法的描述（伪代码）</h3><p>　　算法可以使用英语说明，也可以用中文说明，当然也可以说明成计算机程序。它的唯一要求是这个说明必须精确的描述所需要遵循的计算过程。<br>　　我个人更欣赏将算法描述为用一种伪代码书写的程序。它的优势在于，能够使用最清晰最简洁的方法来说明给定的算法。并且根据伪代码可以将算法转化成各种所需的编程语言。</p>\n<h3 id=\"如何写好伪代码\"><a href=\"#如何写好伪代码\" class=\"headerlink\" title=\"如何写好伪代码\"></a>如何写好伪代码</h3><p>　　在我们常用的编程语言中，通常按照所需的命名规范和运算逻辑的使用，讲所想的用该语言展示出来。伪代码同样也可以按照相似的方法展示。其实伪代码并没有明确的规范要求，但是在算法导论一书中，他列出了一些所谓的约定。当然，这些约定我们可以不去遵守。但是如果按着约定去书写伪代码的话，会使我们的伪代码变得清晰易懂，何乐不为。</p>\n<ul>\n<li>缩进表示块结构。参考python的语言结构。　</li>\n<li>while,for,if-else等结构具有和c语言等相同的解释。但是方便理解，我们去除额外的细节，表示重点。比如当一个for循环时，当循环上升时使用to，下降时使用downto，步数使用by。</li>\n<li>//表示注释</li>\n<li>变量直接使用无需声明。一般变量默认为局部变量。</li>\n<li>数据访问通过数组名和下标的方式访问。</li>\n<li>使用error表示过程中出现错误。</li>\n</ul>\n<p>　　伪代码的使用方法和约定都比较宽松，目的都是能够写出清晰易懂的伪代码。</p>\n<h3 id=\"伪代码实践\"><a href=\"#伪代码实践\" class=\"headerlink\" title=\"伪代码实践\"></a>伪代码实践</h3><p>   这里列举一个插入排序的算法的伪代码实现，大家一起来感受一下气场。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">INSERT-SORT(A)</div><div class=\"line\">    for j=2 to A.length</div><div class=\"line\">        key=A[j]</div><div class=\"line\">        // Insert A[j] into the sorted sequence A[1..j-1].</div><div class=\"line\">        i = j-1;</div><div class=\"line\">      while i&gt;0 and A[i]&gt;key</div><div class=\"line\">          A[i+1]=A[j]</div><div class=\"line\">          i = i-1</div><div class=\"line\">      A[i+1]=key</div></pre></td></tr></table></figure></p>\n<h3 id=\"归并排序-merge-sort\"><a href=\"#归并排序-merge-sort\" class=\"headerlink\" title=\"归并排序(merge sort)\"></a>归并排序(merge sort)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">MERGE(A,p,q,r)</div><div class=\"line\">        n1=q-p+1</div><div class=\"line\">        n2=r-q</div><div class=\"line\">        let L[0..n1] and R[0..n2] be a new array</div><div class=\"line\">        for i = 0 to n1-1</div><div class=\"line\">                L[i]=A[p+i]</div><div class=\"line\">        for j = 0 to n2-1</div><div class=\"line\">                R[j]=A[q+1+j]</div><div class=\"line\">        L[n1]=∞</div><div class=\"line\">        L[n2]=∞</div><div class=\"line\">        i=0</div><div class=\"line\">        j=0</div><div class=\"line\">        for k = p to r</div><div class=\"line\">                if L[i] &lt; R[j]</div><div class=\"line\">                        A[k]=L[i]</div><div class=\"line\">                        i = i + 1</div><div class=\"line\">                else</div><div class=\"line\">                        A[k]=R[j]</div><div class=\"line\">                        j = j +1</div><div class=\"line\"></div><div class=\"line\">MERGE-SORT(A,p,r)</div><div class=\"line\">        if(p&lt;r)</div><div class=\"line\">                q=[(p+r)/2]</div><div class=\"line\">                MERGE-SORT(A,p,q)</div><div class=\"line\">                MERGE-SORT(A,q+1,r)</div><div class=\"line\">                MERGE(A,p,q,r)</div></pre></td></tr></table></figure>\n","excerpt":"<p>　　在学习各种编程语言的时候，数据结构与算法一般都会作为重点课程来指出。而谈到算法，算法导论一书又常常被大家提起。然而作为一个编程界的老鸟，技术层面的菜鸟，最近才开始啃算法导论，实属令自己汗颜。不过拾起总比放下的要好，所以这里根据自己的理解做一些记录。并在阅读初期就设定了一些目标，包括理解并学习各种常用算法及其设计思路，<strong><em>学习并写好伪代码</em></strong>等。</p>","more":"<h3 id=\"什么是算法\"><a href=\"#什么是算法\" class=\"headerlink\" title=\"什么是算法\"></a>什么是算法</h3><p>　　书中讲到，算法就是任何良定义的计算过程。算法的目的是解决问题。问题陈述说明了期望的输入和输出，而算法则描述一个特定的计算过程来实现输入输出的关系。</p>\n<h3 id=\"算法的描述（伪代码）\"><a href=\"#算法的描述（伪代码）\" class=\"headerlink\" title=\"算法的描述（伪代码）\"></a>算法的描述（伪代码）</h3><p>　　算法可以使用英语说明，也可以用中文说明，当然也可以说明成计算机程序。它的唯一要求是这个说明必须精确的描述所需要遵循的计算过程。<br>　　我个人更欣赏将算法描述为用一种伪代码书写的程序。它的优势在于，能够使用最清晰最简洁的方法来说明给定的算法。并且根据伪代码可以将算法转化成各种所需的编程语言。</p>\n<h3 id=\"如何写好伪代码\"><a href=\"#如何写好伪代码\" class=\"headerlink\" title=\"如何写好伪代码\"></a>如何写好伪代码</h3><p>　　在我们常用的编程语言中，通常按照所需的命名规范和运算逻辑的使用，讲所想的用该语言展示出来。伪代码同样也可以按照相似的方法展示。其实伪代码并没有明确的规范要求，但是在算法导论一书中，他列出了一些所谓的约定。当然，这些约定我们可以不去遵守。但是如果按着约定去书写伪代码的话，会使我们的伪代码变得清晰易懂，何乐不为。</p>\n<ul>\n<li>缩进表示块结构。参考python的语言结构。　</li>\n<li>while,for,if-else等结构具有和c语言等相同的解释。但是方便理解，我们去除额外的细节，表示重点。比如当一个for循环时，当循环上升时使用to，下降时使用downto，步数使用by。</li>\n<li>//表示注释</li>\n<li>变量直接使用无需声明。一般变量默认为局部变量。</li>\n<li>数据访问通过数组名和下标的方式访问。</li>\n<li>使用error表示过程中出现错误。</li>\n</ul>\n<p>　　伪代码的使用方法和约定都比较宽松，目的都是能够写出清晰易懂的伪代码。</p>\n<h3 id=\"伪代码实践\"><a href=\"#伪代码实践\" class=\"headerlink\" title=\"伪代码实践\"></a>伪代码实践</h3><p>   这里列举一个插入排序的算法的伪代码实现，大家一起来感受一下气场。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">INSERT-SORT(A)</div><div class=\"line\">    for j=2 to A.length</div><div class=\"line\">        key=A[j]</div><div class=\"line\">        // Insert A[j] into the sorted sequence A[1..j-1].</div><div class=\"line\">        i = j-1;</div><div class=\"line\">      while i&gt;0 and A[i]&gt;key</div><div class=\"line\">          A[i+1]=A[j]</div><div class=\"line\">          i = i-1</div><div class=\"line\">      A[i+1]=key</div></pre></td></tr></table></figure></p>\n<h3 id=\"归并排序-merge-sort\"><a href=\"#归并排序-merge-sort\" class=\"headerlink\" title=\"归并排序(merge sort)\"></a>归并排序(merge sort)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">MERGE(A,p,q,r)</div><div class=\"line\">        n1=q-p+1</div><div class=\"line\">        n2=r-q</div><div class=\"line\">        let L[0..n1] and R[0..n2] be a new array</div><div class=\"line\">        for i = 0 to n1-1</div><div class=\"line\">                L[i]=A[p+i]</div><div class=\"line\">        for j = 0 to n2-1</div><div class=\"line\">                R[j]=A[q+1+j]</div><div class=\"line\">        L[n1]=∞</div><div class=\"line\">        L[n2]=∞</div><div class=\"line\">        i=0</div><div class=\"line\">        j=0</div><div class=\"line\">        for k = p to r</div><div class=\"line\">                if L[i] &lt; R[j]</div><div class=\"line\">                        A[k]=L[i]</div><div class=\"line\">                        i = i + 1</div><div class=\"line\">                else</div><div class=\"line\">                        A[k]=R[j]</div><div class=\"line\">                        j = j +1</div><div class=\"line\"></div><div class=\"line\">MERGE-SORT(A,p,r)</div><div class=\"line\">        if(p&lt;r)</div><div class=\"line\">                q=[(p+r)/2]</div><div class=\"line\">                MERGE-SORT(A,p,q)</div><div class=\"line\">                MERGE-SORT(A,q+1,r)</div><div class=\"line\">                MERGE(A,p,q,r)</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cix1e5cd30001nvou2ijam72b","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cfj000ynvouayyusy83"},{"post_id":"cix1e5cd30001nvou2ijam72b","category_id":"cix1e5cf8000pnvoumpgxlb3m","_id":"cix1e5cfn0013nvout6e34mot"},{"post_id":"cix1e5cef000dnvoud7n1cmar","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cfu0016nvou65fjoy7q"},{"post_id":"cix1e5cef000dnvoud7n1cmar","category_id":"cix1e5cfd000tnvoulzyqrzz1","_id":"cix1e5cg1001anvou4fdr9qy5"},{"post_id":"cix1e5cfl0011nvou4oq16phl","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cg4001dnvoubsfrpee9"},{"post_id":"cix1e5cfl0011nvou4oq16phl","category_id":"cix1e5cfk000znvouiqqo6eqf","_id":"cix1e5cga001invou9ngz0g0a"},{"post_id":"cix1e5cdi0003nvoudj7fwj5k","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgb001jnvoun4sqoqcc"},{"post_id":"cix1e5cdi0003nvoudj7fwj5k","category_id":"cix1e5cfk000znvouiqqo6eqf","_id":"cix1e5cgc001lnvou8i64i1zu"},{"post_id":"cix1e5cep000hnvou2rad3s27","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgd001onvou6qo23m7d"},{"post_id":"cix1e5cep000hnvou2rad3s27","category_id":"cix1e5cfd000tnvoulzyqrzz1","_id":"cix1e5cge001rnvouog8fpfga"},{"post_id":"cix1e5cdu0007nvoujd9fk1ow","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgf001tnvouj5smc794"},{"post_id":"cix1e5cdu0007nvoujd9fk1ow","category_id":"cix1e5cg7001fnvou5pe0hmki","_id":"cix1e5cgg001vnvouxcu02rbf"},{"post_id":"cix1e5cet000jnvoui7ges4n1","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgh001xnvoufgt3638v"},{"post_id":"cix1e5cet000jnvoui7ges4n1","category_id":"cix1e5cfd000tnvoulzyqrzz1","_id":"cix1e5cgi0020nvoue5v957pz"},{"post_id":"cix1e5cey000nnvou4teqgv5k","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgj0023nvouy6phmmzo"},{"post_id":"cix1e5cey000nnvou4teqgv5k","category_id":"cix1e5cfd000tnvoulzyqrzz1","_id":"cix1e5cgj0024nvouc99ju2wn"},{"post_id":"cix1e5cea0009nvoupuynlv6h","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgl0027nvousq43mq1a"},{"post_id":"cix1e5cea0009nvoupuynlv6h","category_id":"cix1e5cgg001unvou0svurgaj","_id":"cix1e5cgl0029nvouqud127uu"},{"post_id":"cix1e5cfb000rnvoupbvp11h0","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgn002fnvouinvy5yoh"},{"post_id":"cix1e5cfb000rnvoupbvp11h0","category_id":"cix1e5cgk0025nvoufzfkjych","_id":"cix1e5cgp002jnvoui3pfii00"},{"post_id":"cix1e5cfc000snvou9h4yrauv","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgq002lnvou1u3el5bu"},{"post_id":"cix1e5cfc000snvou9h4yrauv","category_id":"cix1e5cfd000tnvoulzyqrzz1","_id":"cix1e5cgs002pnvouxupyy22f"},{"post_id":"cix1e5cfe000unvou3qv389rh","category_id":"cix1e5cee000bnvou0eemddmd","_id":"cix1e5cgs002rnvou7botmz1c"},{"post_id":"cix1e5cfe000unvou3qv389rh","category_id":"cix1e5cgo002hnvoudzgxeiu8","_id":"cix1e5cgu002unvou1k9mwr8c"},{"post_id":"cix1e5cfh000xnvouo12nom3e","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgu002vnvoug9zphip6"},{"post_id":"cix1e5cfh000xnvouo12nom3e","category_id":"cix1e5cgq002nnvouub7xyrx5","_id":"cix1e5cgv002znvouttvspk12"},{"post_id":"cix1e5cfn0015nvouu4iesqd8","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5cgw0031nvouba1dy6hw"},{"post_id":"cix1e5cfn0015nvouu4iesqd8","category_id":"cix1e5cgt002tnvouu98xqtkm","_id":"cix1e5cgy0035nvoukz2ong54"},{"post_id":"cix1e5cfx0017nvoutb8fdmq7","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5ch10037nvou249p301s"},{"post_id":"cix1e5cfx0017nvoutb8fdmq7","category_id":"cix1e5cgv002xnvouhb26yybz","_id":"cix1e5ch3003anvou792t9bvx"},{"post_id":"cix1e5cg1001bnvou8pcgaby2","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5ch3003cnvou6hgkse1d"},{"post_id":"cix1e5cg1001bnvou8pcgaby2","category_id":"cix1e5cgq002nnvouub7xyrx5","_id":"cix1e5ch5003fnvouorrh69rb"},{"post_id":"cix1e5cg5001envou6drghovd","category_id":"cix1e5cdp0005nvouyczw5r2v","_id":"cix1e5ch6003gnvouwvhemyxh"},{"post_id":"cix1e5cg5001envou6drghovd","category_id":"cix1e5cgq002nnvouub7xyrx5","_id":"cix1e5ch8003invouza1k1im1"},{"post_id":"cix1e5cf4000onvounasrg49a","category_id":"cix1e5cgh001znvou2dpgdqky","_id":"cix1e5ch9003lnvou39ivxpnx"},{"post_id":"cix1e5cf4000onvounasrg49a","category_id":"cix1e5ch4003envou2j0ocel2","_id":"cix1e5chb003onvousmxc9wlq"}],"PostTag":[{"post_id":"cix1e5cd30001nvou2ijam72b","tag_id":"cix1e5cdt0006nvou02fxvsoa","_id":"cix1e5cer000invouthbs873a"},{"post_id":"cix1e5cd30001nvou2ijam72b","tag_id":"cix1e5cee000cnvou6dt0y6wt","_id":"cix1e5cev000knvou036a8enf"},{"post_id":"cix1e5cdi0003nvoudj7fwj5k","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5cfh000wnvoush0c1f52"},{"post_id":"cix1e5cdi0003nvoudj7fwj5k","tag_id":"cix1e5cex000mnvoudwifwxlk","_id":"cix1e5cfk0010nvoux5wsmib8"},{"post_id":"cix1e5cdi0003nvoudj7fwj5k","tag_id":"cix1e5cf9000qnvoux6rjkhjd","_id":"cix1e5cfn0014nvou6bexldos"},{"post_id":"cix1e5cdu0007nvoujd9fk1ow","tag_id":"cix1e5cdt0006nvou02fxvsoa","_id":"cix1e5cg3001cnvoug44hlt65"},{"post_id":"cix1e5cdu0007nvoujd9fk1ow","tag_id":"cix1e5cfm0012nvouh61s90r0","_id":"cix1e5cg8001gnvouyqb8cau6"},{"post_id":"cix1e5cea0009nvoupuynlv6h","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5cgd001nnvoun2b9jy3p"},{"post_id":"cix1e5cea0009nvoupuynlv6h","tag_id":"cix1e5cg8001hnvouxqoptf11","_id":"cix1e5cge001qnvoubl4w2k73"},{"post_id":"cix1e5cef000dnvoud7n1cmar","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5cgh001ynvou1xqs3snp"},{"post_id":"cix1e5cef000dnvoud7n1cmar","tag_id":"cix1e5cge001snvouusbv2h0k","_id":"cix1e5cgi0021nvouibnl2zrp"},{"post_id":"cix1e5cej000envou2c6s9jkx","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5cgl0028nvounzx2w15e"},{"post_id":"cix1e5cej000envou2c6s9jkx","tag_id":"cix1e5cge001snvouusbv2h0k","_id":"cix1e5cgl002anvou4fxz5kra"},{"post_id":"cix1e5cep000hnvou2rad3s27","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5cgn002dnvou3gtnqp8r"},{"post_id":"cix1e5cep000hnvou2rad3s27","tag_id":"cix1e5cge001snvouusbv2h0k","_id":"cix1e5cgn002envouv2z6d682"},{"post_id":"cix1e5cet000jnvoui7ges4n1","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5cgp002invoumf5p8slm"},{"post_id":"cix1e5cet000jnvoui7ges4n1","tag_id":"cix1e5cge001snvouusbv2h0k","_id":"cix1e5cgq002knvouhs2ejm04"},{"post_id":"cix1e5cey000nnvou4teqgv5k","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5cgr002onvouq11vczhz"},{"post_id":"cix1e5cey000nnvou4teqgv5k","tag_id":"cix1e5cge001snvouusbv2h0k","_id":"cix1e5cgs002qnvou68whvn8r"},{"post_id":"cix1e5cf4000onvounasrg49a","tag_id":"cix1e5cgq002mnvouffd38rbx","_id":"cix1e5cgv002ynvou1b34bgfq"},{"post_id":"cix1e5cf4000onvounasrg49a","tag_id":"cix1e5cgs002snvouoicgasi9","_id":"cix1e5cgw0030nvoug4pdz4h4"},{"post_id":"cix1e5cfb000rnvoupbvp11h0","tag_id":"cix1e5cgu002wnvouebpvlw2b","_id":"cix1e5cgy0034nvou5731mpc1"},{"post_id":"cix1e5cfc000snvou9h4yrauv","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5ch20039nvoungxfnbcw"},{"post_id":"cix1e5cfc000snvou9h4yrauv","tag_id":"cix1e5cge001snvouusbv2h0k","_id":"cix1e5ch3003bnvouweki5u6k"},{"post_id":"cix1e5cfe000unvou3qv389rh","tag_id":"cix1e5cel000gnvouzh122zis","_id":"cix1e5ch8003jnvouv4s87iv9"},{"post_id":"cix1e5cfe000unvou3qv389rh","tag_id":"cix1e5ch00036nvourdjcuwmk","_id":"cix1e5ch8003knvoui1ppptug"},{"post_id":"cix1e5cfe000unvou3qv389rh","tag_id":"cix1e5ch4003dnvoulcguy50j","_id":"cix1e5chb003nnvouifvkqs94"},{"post_id":"cix1e5cfh000xnvouo12nom3e","tag_id":"cix1e5cdt0006nvou02fxvsoa","_id":"cix1e5chg003snvoun5mtjqnb"},{"post_id":"cix1e5cfh000xnvouo12nom3e","tag_id":"cix1e5ch6003hnvoui0ncz949","_id":"cix1e5chg003tnvougw4j8pkd"},{"post_id":"cix1e5cfh000xnvouo12nom3e","tag_id":"cix1e5ch9003mnvoufwwsd7vt","_id":"cix1e5chg003vnvou4hgr792x"},{"post_id":"cix1e5cfh000xnvouo12nom3e","tag_id":"cix1e5che003pnvou3yi6k7j5","_id":"cix1e5chg003wnvou45dta4r6"},{"post_id":"cix1e5cfh000xnvouo12nom3e","tag_id":"cix1e5chf003qnvou9rxw4961","_id":"cix1e5chh003ynvou7anoczu6"},{"post_id":"cix1e5cfl0011nvou4oq16phl","tag_id":"cix1e5chf003rnvouuiuv4jpp","_id":"cix1e5chh003znvouh2k1lpm5"},{"post_id":"cix1e5cfl0011nvou4oq16phl","tag_id":"cix1e5cex000mnvoudwifwxlk","_id":"cix1e5chh0041nvouifanp6k1"},{"post_id":"cix1e5cfn0015nvouu4iesqd8","tag_id":"cix1e5chg003unvoud8r2k8q7","_id":"cix1e5chh0042nvou090adbsz"},{"post_id":"cix1e5cfn0015nvouu4iesqd8","tag_id":"cix1e5cdt0006nvou02fxvsoa","_id":"cix1e5chh0043nvouv5p2yd5j"},{"post_id":"cix1e5cfx0017nvoutb8fdmq7","tag_id":"cix1e5chh003xnvou9qpczf8s","_id":"cix1e5chi0045nvoucn1km356"},{"post_id":"cix1e5cfx0017nvoutb8fdmq7","tag_id":"cix1e5chh0040nvoutauv4k77","_id":"cix1e5chi0046nvouyjd7t5v4"},{"post_id":"cix1e5cg1001bnvou8pcgaby2","tag_id":"cix1e5cdt0006nvou02fxvsoa","_id":"cix1e5chj0049nvouydqdc94x"},{"post_id":"cix1e5cg1001bnvou8pcgaby2","tag_id":"cix1e5ch6003hnvoui0ncz949","_id":"cix1e5chj004anvou9vwncszg"},{"post_id":"cix1e5cg1001bnvou8pcgaby2","tag_id":"cix1e5chi0047nvouw8k8ybvr","_id":"cix1e5chj004bnvouaxsnhct5"},{"post_id":"cix1e5cg5001envou6drghovd","tag_id":"cix1e5cdt0006nvou02fxvsoa","_id":"cix1e5chj004cnvoudeucd3ub"},{"post_id":"cix1e5cg5001envou6drghovd","tag_id":"cix1e5ch6003hnvoui0ncz949","_id":"cix1e5chj004dnvoudatvhe1x"}],"Tag":[{"name":"读书笔记","_id":"cix1e5cdt0006nvou02fxvsoa"},{"name":"ActiveMQ","_id":"cix1e5cee000cnvou6dt0y6wt"},{"name":"程序设计","_id":"cix1e5cel000gnvouzh122zis"},{"name":"c++11","_id":"cix1e5cex000mnvoudwifwxlk"},{"name":"条件变量","_id":"cix1e5cf9000qnvoux6rjkhjd"},{"name":"more effective c++","_id":"cix1e5cfm0012nvouh61s90r0"},{"name":"elasticsearch","_id":"cix1e5cg8001hnvouxqoptf11"},{"name":"leetcode","_id":"cix1e5cge001snvouusbv2h0k"},{"name":"linux","_id":"cix1e5cgq002mnvouffd38rbx"},{"name":"系统相关","_id":"cix1e5cgs002snvouoicgasi9"},{"name":"redis","_id":"cix1e5cgu002wnvouebpvlw2b"},{"name":"c++","_id":"cix1e5ch00036nvourdjcuwmk"},{"name":"数据库连接池","_id":"cix1e5ch4003dnvoulcguy50j"},{"name":"算法导论","_id":"cix1e5ch6003hnvoui0ncz949"},{"name":"分治策略","_id":"cix1e5ch9003mnvoufwwsd7vt"},{"name":"快速排序","_id":"cix1e5che003pnvou3yi6k7j5"},{"name":"堆排序","_id":"cix1e5chf003qnvou9rxw4961"},{"name":"编程","_id":"cix1e5chf003rnvouuiuv4jpp"},{"name":"编程珠玑","_id":"cix1e5chg003unvoud8r2k8q7"},{"name":"网址推荐","_id":"cix1e5chh003xnvou9qpczf8s"},{"name":"学习笔记","_id":"cix1e5chh0040nvoutauv4k77"},{"name":"动态规划","_id":"cix1e5chi0047nvouw8k8ybvr"}]}}